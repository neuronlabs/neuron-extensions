// Code generated by neuron/generator. DO NOT EDIT.
// This file was generated at:
// Tue, 25 Aug 2020 22:05:55 +0200

package json

import (
	"strconv"
	"time"

	"github.com/neuronlabs/neuron/errors"
	"github.com/neuronlabs/neuron/mapping"
	"github.com/neuronlabs/neuron/query"
)

// Neuron_Models stores all generated models in this package.
var Neuron_Models = []mapping.Model{
	&Pet{},
	&User{},
}

// Compile time check if Pet implements mapping.Model interface.
var _ mapping.Model = &Pet{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'Pet'.
func (p *Pet) NeuronCollectionName() string {
	return "pets"
}

// IsPrimaryKeyZero implements mapping.Model interface method.
func (p *Pet) IsPrimaryKeyZero() bool {
	return p.ID == 0
}

// GetPrimaryKeyValue implements mapping.Model interface method.
func (p *Pet) GetPrimaryKeyValue() interface{} {
	return p.ID
}

// GetPrimaryKeyStringValue implements mapping.Model interface method.
func (p *Pet) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(p.ID), 10), nil
}

// GetPrimaryKeyAddress implements mapping.Model interface method.
func (p *Pet) GetPrimaryKeyAddress() interface{} {
	return &p.ID
}

// GetPrimaryKeyHashableValue implements mapping.Model interface method.
func (p *Pet) GetPrimaryKeyHashableValue() interface{} {
	return p.ID
}

// GetPrimaryKeyZeroValue implements mapping.Model interface method.
func (p *Pet) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements mapping.Model interface method.
func (p *Pet) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		p.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		p.ID = int(valueType)
	case int16:
		p.ID = int(valueType)
	case int32:
		p.ID = int(valueType)
	case int64:
		p.ID = int(valueType)
	case uint:
		p.ID = int(valueType)
	case uint8:
		p.ID = int(valueType)
	case uint16:
		p.ID = int(valueType)
	case uint32:
		p.ID = int(valueType)
	case uint64:
		p.ID = int(valueType)
	case float32:
		p.ID = int(valueType)
	case float64:
		p.ID = int(valueType)
	default:
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'Pet'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (p *Pet) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	if err != nil {
		return err
	}
	p.ID = int(tmp)
	return nil
}

// SetFrom implements FromSetter interface.
func (p *Pet) SetFrom(model mapping.Model) error {
	if model == nil {
		return errors.Wrap(query.ErrInvalidInput, "provided nil model to set from")
	}
	from, ok := model.(*Pet)
	if !ok {
		return errors.WrapDetf(mapping.ErrModelNotMatch, "provided model doesn't match the input: %T", model)
	}
	*p = *from
	return nil
}

// Compile time check if Pet implements mapping.Fielder interface.
var _ mapping.Fielder = &Pet{}

// GetFieldsAddress gets the address of provided 'field'.
func (p *Pet) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &p.ID, nil
	case 1: // Name
		return &p.Name, nil
	case 3: // OwnerID
		return &p.OwnerID, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: Pet'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (p *Pet) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // Name
		return "", nil
	case 3: // OwnerID
		return 0, nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (p *Pet) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return p.ID == 0, nil
	case 1: // Name
		return p.Name == "", nil
	case 3: // OwnerID
		return p.OwnerID == 0, nil
	}
	return false, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (p *Pet) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		p.ID = 0
	case 1: // Name
		p.Name = ""
	case 3: // OwnerID
		p.OwnerID = 0
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (p *Pet) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return p.ID, nil
	case 1: // Name
		return p.Name, nil
	case 3: // OwnerID
		return p.OwnerID, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: 'Pet'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (p *Pet) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return p.ID, nil
	case 1: // Name
		return p.Name, nil
	case 3: // OwnerID
		return p.OwnerID, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: Pet'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (p *Pet) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			p.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			p.ID = int(v)
		case int16:
			p.ID = int(v)
		case int32:
			p.ID = int(v)
		case int64:
			p.ID = int(v)
		case uint:
			p.ID = int(v)
		case uint8:
			p.ID = int(v)
		case uint16:
			p.ID = int(v)
		case uint32:
			p.ID = int(v)
		case uint64:
			p.ID = int(v)
		case float32:
			p.ID = int(v)
		case float64:
			p.ID = int(v)
		default:
			return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // Name
		if v, ok := value.(string); ok {
			p.Name = v
			return nil
		}

		// Check alternate types for the Name.
		if v, ok := value.([]byte); ok {
			p.Name = string(v)
			return nil
		}
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // OwnerID
		if v, ok := value.(int); ok {
			p.OwnerID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			p.OwnerID = int(v)
		case int16:
			p.OwnerID = int(v)
		case int32:
			p.OwnerID = int(v)
		case int64:
			p.OwnerID = int(v)
		case uint:
			p.OwnerID = int(v)
		case uint8:
			p.OwnerID = int(v)
		case uint16:
			p.OwnerID = int(v)
		case uint32:
			p.OwnerID = int(v)
		case uint64:
			p.OwnerID = int(v)
		case float32:
			p.OwnerID = int(v)
		case float64:
			p.OwnerID = int(v)
		default:
			return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for the model: 'Pet'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (p *Pet) ParseFieldsStringValue(field *mapping.StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	case 1: // Name
		return value, nil
	case 3: // OwnerID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: Pet'", field.Name())
}

// Compile time check if Pet implements mapping.SingleRelationer interface.
var _ mapping.SingleRelationer = &Pet{}

// GetRelationModel implements mapping.SingleRelationer interface.
func (p *Pet) GetRelationModel(relation *mapping.StructField) (mapping.Model, error) {
	switch relation.Index[0] {
	case 2: // Owner
		if p.Owner == nil {
			return nil, nil
		}
		return p.Owner, nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, p)
	}
}

// SetRelationModel implements mapping.SingleRelationer interface.
func (p *Pet) SetRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 2: // Owner
		if model == nil {
			p.Owner = nil
			return nil
		} else if owner, ok := model.(*User); ok {
			p.Owner = owner
			return nil
		}
		return errors.Wrapf(mapping.ErrInvalidRelationValue, "provided invalid model value: '%T' for relation Owner", model)
	default:
		return errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, p)
	}
}

// Compile time check if User implements mapping.Model interface.
var _ mapping.Model = &User{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'User'.
func (u *User) NeuronCollectionName() string {
	return "users"
}

// IsPrimaryKeyZero implements mapping.Model interface method.
func (u *User) IsPrimaryKeyZero() bool {
	return u.ID == 0
}

// GetPrimaryKeyValue implements mapping.Model interface method.
func (u *User) GetPrimaryKeyValue() interface{} {
	return u.ID
}

// GetPrimaryKeyStringValue implements mapping.Model interface method.
func (u *User) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(u.ID), 10), nil
}

// GetPrimaryKeyAddress implements mapping.Model interface method.
func (u *User) GetPrimaryKeyAddress() interface{} {
	return &u.ID
}

// GetPrimaryKeyHashableValue implements mapping.Model interface method.
func (u *User) GetPrimaryKeyHashableValue() interface{} {
	return u.ID
}

// GetPrimaryKeyZeroValue implements mapping.Model interface method.
func (u *User) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements mapping.Model interface method.
func (u *User) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		u.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		u.ID = int(valueType)
	case int16:
		u.ID = int(valueType)
	case int32:
		u.ID = int(valueType)
	case int64:
		u.ID = int(valueType)
	case uint:
		u.ID = int(valueType)
	case uint8:
		u.ID = int(valueType)
	case uint16:
		u.ID = int(valueType)
	case uint32:
		u.ID = int(valueType)
	case uint64:
		u.ID = int(valueType)
	case float32:
		u.ID = int(valueType)
	case float64:
		u.ID = int(valueType)
	default:
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'User'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (u *User) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	if err != nil {
		return err
	}
	u.ID = int(tmp)
	return nil
}

// SetFrom implements FromSetter interface.
func (u *User) SetFrom(model mapping.Model) error {
	if model == nil {
		return errors.Wrap(query.ErrInvalidInput, "provided nil model to set from")
	}
	from, ok := model.(*User)
	if !ok {
		return errors.WrapDetf(mapping.ErrModelNotMatch, "provided model doesn't match the input: %T", model)
	}
	*u = *from
	return nil
}

// Compile time check if User implements mapping.Fielder interface.
var _ mapping.Fielder = &User{}

// GetFieldsAddress gets the address of provided 'field'.
func (u *User) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &u.ID, nil
	case 1: // Name
		return &u.Name, nil
	case 2: // CreatedAt
		return &u.CreatedAt, nil
	case 3: // CreatedAtIso
		return &u.CreatedAtIso, nil
	case 5: // MotherID
		return &u.MotherID, nil
	case 7: // FatherID
		return &u.FatherID, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: User'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (u *User) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // Name
		return "", nil
	case 2: // CreatedAt
		return time.Time{}, nil
	case 3: // CreatedAtIso
		return time.Time{}, nil
	case 5: // MotherID
		return 0, nil
	case 7: // FatherID
		return 0, nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (u *User) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return u.ID == 0, nil
	case 1: // Name
		return u.Name == "", nil
	case 2: // CreatedAt
		return u.CreatedAt == time.Time{}, nil
	case 3: // CreatedAtIso
		return u.CreatedAtIso == time.Time{}, nil
	case 5: // MotherID
		return u.MotherID == 0, nil
	case 7: // FatherID
		return u.FatherID == 0, nil
	}
	return false, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (u *User) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		u.ID = 0
	case 1: // Name
		u.Name = ""
	case 2: // CreatedAt
		u.CreatedAt = time.Time{}
	case 3: // CreatedAtIso
		u.CreatedAtIso = time.Time{}
	case 5: // MotherID
		u.MotherID = 0
	case 7: // FatherID
		u.FatherID = 0
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (u *User) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return u.ID, nil
	case 1: // Name
		return u.Name, nil
	case 2: // CreatedAt
		return u.CreatedAt, nil
	case 3: // CreatedAtIso
		return u.CreatedAtIso, nil
	case 5: // MotherID
		return u.MotherID, nil
	case 7: // FatherID
		return u.FatherID, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: 'User'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (u *User) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return u.ID, nil
	case 1: // Name
		return u.Name, nil
	case 2: // CreatedAt
		return u.CreatedAt, nil
	case 3: // CreatedAtIso
		return u.CreatedAtIso, nil
	case 5: // MotherID
		return u.MotherID, nil
	case 7: // FatherID
		return u.FatherID, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: User'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (u *User) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			u.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			u.ID = int(v)
		case int16:
			u.ID = int(v)
		case int32:
			u.ID = int(v)
		case int64:
			u.ID = int(v)
		case uint:
			u.ID = int(v)
		case uint8:
			u.ID = int(v)
		case uint16:
			u.ID = int(v)
		case uint32:
			u.ID = int(v)
		case uint64:
			u.ID = int(v)
		case float32:
			u.ID = int(v)
		case float64:
			u.ID = int(v)
		default:
			return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // Name
		if v, ok := value.(string); ok {
			u.Name = v
			return nil
		}

		// Check alternate types for the Name.
		if v, ok := value.([]byte); ok {
			u.Name = string(v)
			return nil
		}
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // CreatedAt
		if v, ok := value.(time.Time); ok {
			u.CreatedAt = v
			return nil
		}

		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // CreatedAtIso
		if v, ok := value.(time.Time); ok {
			u.CreatedAtIso = v
			return nil
		}

		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 5: // MotherID
		if v, ok := value.(int); ok {
			u.MotherID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			u.MotherID = int(v)
		case int16:
			u.MotherID = int(v)
		case int32:
			u.MotherID = int(v)
		case int64:
			u.MotherID = int(v)
		case uint:
			u.MotherID = int(v)
		case uint8:
			u.MotherID = int(v)
		case uint16:
			u.MotherID = int(v)
		case uint32:
			u.MotherID = int(v)
		case uint64:
			u.MotherID = int(v)
		case float32:
			u.MotherID = int(v)
		case float64:
			u.MotherID = int(v)
		default:
			return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 7: // FatherID
		if v, ok := value.(int); ok {
			u.FatherID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			u.FatherID = int(v)
		case int16:
			u.FatherID = int(v)
		case int32:
			u.FatherID = int(v)
		case int64:
			u.FatherID = int(v)
		case uint:
			u.FatherID = int(v)
		case uint8:
			u.FatherID = int(v)
		case uint16:
			u.FatherID = int(v)
		case uint32:
			u.FatherID = int(v)
		case uint64:
			u.FatherID = int(v)
		case float32:
			u.FatherID = int(v)
		case float64:
			u.FatherID = int(v)
		default:
			return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for the model: 'User'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (u *User) ParseFieldsStringValue(field *mapping.StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	case 1: // Name
		return value, nil
	case 2: // CreatedAt
		temp := u.CreatedAt
		if err := u.CreatedAt.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'CreatedAt' value: '%v' to parse string. Err: %v", u.CreatedAt, err)
		}
		bt, err := u.CreatedAt.MarshalText()
		if err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'CreatedAt' value: '%v' to parse string. Err: %v", u.CreatedAt, err)
		}
		u.CreatedAt = temp
		return string(bt), nil
	case 3: // CreatedAtIso
		temp := u.CreatedAtIso
		if err := u.CreatedAtIso.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'CreatedAtIso' value: '%v' to parse string. Err: %v", u.CreatedAtIso, err)
		}
		bt, err := u.CreatedAtIso.MarshalText()
		if err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'CreatedAtIso' value: '%v' to parse string. Err: %v", u.CreatedAtIso, err)
		}
		u.CreatedAtIso = temp
		return string(bt), nil
	case 5: // MotherID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	case 7: // FatherID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: User'", field.Name())
}

// Compile time check if User implements mapping.SingleRelationer interface.
var _ mapping.SingleRelationer = &User{}

// GetRelationModel implements mapping.SingleRelationer interface.
func (u *User) GetRelationModel(relation *mapping.StructField) (mapping.Model, error) {
	switch relation.Index[0] {
	case 4: // Mother
		if u.Mother == nil {
			return nil, nil
		}
		return u.Mother, nil
	case 6: // Father
		if u.Father == nil {
			return nil, nil
		}
		return u.Father, nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, u)
	}
}

// SetRelationModel implements mapping.SingleRelationer interface.
func (u *User) SetRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 4: // Mother
		if model == nil {
			u.Mother = nil
			return nil
		} else if mother, ok := model.(*User); ok {
			u.Mother = mother
			return nil
		}
		return errors.Wrapf(mapping.ErrInvalidRelationValue, "provided invalid model value: '%T' for relation Mother", model)
	case 6: // Father
		if model == nil {
			u.Father = nil
			return nil
		} else if father, ok := model.(*User); ok {
			u.Father = father
			return nil
		}
		return errors.Wrapf(mapping.ErrInvalidRelationValue, "provided invalid model value: '%T' for relation Father", model)
	default:
		return errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, u)
	}
}

// Compile time check for the mapping.MultiRelationer interface implementation.
var _ mapping.MultiRelationer = &User{}

// AddRelationModel implements mapping.MultiRelationer interface.
func (u *User) AddRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 8: // Pets
		pet, ok := model.(*Pet)
		if !ok {
			return errors.Wrapf(mapping.ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Pets'", model)
		}
		u.Pets = append(u.Pets, pet)
	default:
		return errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%T' for the model 'User'", model)
	}
	return nil
}

// GetRelationModels implements mapping.MultiRelationer interface.
func (u *User) GetRelationModels(relation *mapping.StructField) (models []mapping.Model, err error) {
	switch relation.Index[0] {
	case 8: // Pets
		for _, model := range u.Pets {
			models = append(models, model)
		}
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, u)
	}
	return models, nil
}

// GetRelationModelAt implements mapping.MultiRelationer interface.
func (u *User) GetRelationModelAt(relation *mapping.StructField, index int) (models mapping.Model, err error) {
	switch relation.Index[0] {
	case 8: // Pets
		if index > len(u.Pets)-1 {
			return nil, errors.Wrapf(mapping.ErrInvalidRelationIndex, "index out of possible range. Model: 'User', Field Pets")
		}
		return u.Pets[index], nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, u)
	}
	return models, nil
}

// GetRelationLen implements mapping.MultiRelationer interface.
func (u *User) GetRelationLen(relation *mapping.StructField) (int, error) {
	switch relation.Index[0] {
	case 8: // Pets
		return len(u.Pets), nil
	default:
		return 0, errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, u)
	}
}

// SetRelationModels implements mapping.MultiRelationer interface.
func (u *User) SetRelationModels(relation *mapping.StructField, models ...mapping.Model) error {
	switch relation.Index[0] {
	case 8: // Pets
		temp := make([]*Pet, len(models))
		for i, model := range models {
			pet, ok := model.(*Pet)
			if !ok {
				return errors.Wrapf(mapping.ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Pets'", model)
			}
			temp[i] = pet
		}
		u.Pets = temp
	default:
		return errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for the model 'User'", relation.String())
	}
	return nil
}
