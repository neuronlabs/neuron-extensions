// Code generated by neuron/generator. DO NOT EDIT.
// This file was generated at:
// Fri, 17 Jul 2020 14:07:48 +0200

package jsonapi

import (
	"strconv"
	"time"

	"github.com/neuronlabs/neuron/errors"
	"github.com/neuronlabs/neuron/mapping"
)

// Compile time check if UnmarshalModel implements mapping.Model interface.
var _ mapping.Model = &UnmarshalModel{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'UnmarshalModel'.
func (u *UnmarshalModel) NeuronCollectionName() string {
	return "unmarshal_models"
}

// IsPrimaryKeyZero implements mapping.Model interface method.
func (u *UnmarshalModel) IsPrimaryKeyZero() bool {
	return u.ID == ""
}

// GetPrimaryKeyValue implements mapping.Model interface method.
func (u *UnmarshalModel) GetPrimaryKeyValue() interface{} {
	return u.ID
}

// GetPrimaryKeyStringValue implements mapping.Model interface method.
func (u *UnmarshalModel) GetPrimaryKeyStringValue() (string, error) {
	return u.ID, nil
}

// GetPrimaryKeyAddress implements mapping.Model interface method.
func (u *UnmarshalModel) GetPrimaryKeyAddress() interface{} {
	return &u.ID
}

// GetPrimaryKeyHashableValue implements mapping.Model interface method.
func (u *UnmarshalModel) GetPrimaryKeyHashableValue() interface{} {
	return u.ID
}

// GetPrimaryKeyZeroValue implements mapping.Model interface method.
func (u *UnmarshalModel) GetPrimaryKeyZeroValue() interface{} {
	return ""
}

// SetPrimaryKey implements mapping.Model interface method.
func (u *UnmarshalModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(string); ok {
		u.ID = v
		return nil
	}
	// Check alternate types for given field.
	if v, ok := value.([]byte); ok {
		u.ID = string(v)
		return nil
	}
	return errors.Newf(mapping.ClassFieldValue, "provided invalid value: '%T' for the primary field for model: '%T'",
		value, u)
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (u *UnmarshalModel) SetPrimaryKeyStringValue(value string) error {
	u.ID = value
	return nil
}

// Compile time check if UnmarshalModel implements mapping.Fielder interface.
var _ mapping.Fielder = &UnmarshalModel{}

// GetFieldsAddress gets the address of provided 'field'.
func (u *UnmarshalModel) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &u.ID, nil
	case 1: // PtrString
		return &u.PtrString, nil
	case 2: // PtrTime
		return &u.PtrTime, nil
	case 3: // StringSlice
		return &u.StringSlice, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: UnmarshalModel'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (u *UnmarshalModel) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return "", nil
	case 1: // PtrString
		return nil, nil
	case 2: // PtrTime
		return nil, nil
	case 3: // StringSlice
		return nil, nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (u *UnmarshalModel) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return u.ID == "", nil
	case 1: // PtrString
		return u.PtrString == nil, nil
	case 2: // PtrTime
		return u.PtrTime == nil, nil
	case 3: // StringSlice
		return len(u.StringSlice) == 0, nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (u *UnmarshalModel) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		u.ID = ""
	case 1: // PtrString
		u.PtrString = nil
	case 2: // PtrTime
		u.PtrTime = nil
	case 3: // StringSlice
		u.StringSlice = nil
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (u *UnmarshalModel) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return u.ID, nil
	case 1: // PtrString
		if u.PtrString == nil {
			return nil, nil
		}
		return *u.PtrString, nil
	case 2: // PtrTime
		if u.PtrTime == nil {
			return nil, nil
		}
		return *u.PtrTime, nil
	case 3: // StringSlice
		return u.StringSlice, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'UnmarshalModel'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (u *UnmarshalModel) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return u.ID, nil
	case 1: // PtrString
		return u.PtrString, nil
	case 2: // PtrTime
		return u.PtrTime, nil
	case 3: // StringSlice
		return u.StringSlice, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: UnmarshalModel'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (u *UnmarshalModel) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(string); ok {
			u.ID = v
			return nil
		}

		// Check alternate types for the ID.
		if v, ok := value.([]byte); ok {
			u.ID = string(v)
			return nil
		}
		return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 1: // PtrString
		if value == nil {
			u.PtrString = nil
			return nil
		}
		if v, ok := value.(*string); ok {
			u.PtrString = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(string); ok {
			u.PtrString = &v
			return nil
		}

		// Check alternate types for the PtrString.
		if v, ok := value.([]byte); ok {
			temp := string(v)
			u.PtrString = &temp
			return nil
		}
		return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // PtrTime
		if value == nil {
			u.PtrTime = nil
			return nil
		}
		if v, ok := value.(*time.Time); ok {
			u.PtrTime = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(time.Time); ok {
			u.PtrTime = &v
			return nil
		}

		return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // StringSlice
		if value == nil {
			u.StringSlice = nil
			return nil
		}
		if v, ok := value.([]string); ok {
			u.StringSlice = v
			return nil
		}
		if generic, ok := value.([]interface{}); ok {
			for _, item := range generic {
				if v, ok := item.(string); ok {
					u.StringSlice = append(u.StringSlice, v)
					continue
				}
				// Check alternate types for the StringSlice.
				if v, ok := item.([]byte); ok {
					u.StringSlice = append(u.StringSlice, string(v))
					continue
				}
				return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
			}
			return nil
		}
		return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'UnmarshalModel'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (u *UnmarshalModel) ParseFieldsStringValue(field *mapping.StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return value, nil
	case 1: // PtrString
		return value, nil
	case 2: // PtrTime
		var base time.Time
		temp := &base
		if err := temp.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Newf(mapping.ClassFieldValue, "invalid field 'PtrTime' value: '%v' to parse string. Err: %v", u.PtrTime, err)
		}
		bt, err := temp.MarshalText()
		if err != nil {
			return "", errors.Newf(mapping.ClassFieldValue, "invalid field 'PtrTime' value: '%v' to parse string. Err: %v", u.PtrTime, err)
		}

		return string(bt), nil
	case 3: // StringSlice
		return value, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: UnmarshalModel'", field.Name())
}

// Compile time check if UserPets implements mapping.Model interface.
var _ mapping.Model = &UserPets{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'UserPets'.
func (u *UserPets) NeuronCollectionName() string {
	return "user_pets"
}

// IsPrimaryKeyZero implements mapping.Model interface method.
func (u *UserPets) IsPrimaryKeyZero() bool {
	return u.ID == 0
}

// GetPrimaryKeyValue implements mapping.Model interface method.
func (u *UserPets) GetPrimaryKeyValue() interface{} {
	return u.ID
}

// GetPrimaryKeyStringValue implements mapping.Model interface method.
func (u *UserPets) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(u.ID), 10), nil
}

// GetPrimaryKeyAddress implements mapping.Model interface method.
func (u *UserPets) GetPrimaryKeyAddress() interface{} {
	return &u.ID
}

// GetPrimaryKeyHashableValue implements mapping.Model interface method.
func (u *UserPets) GetPrimaryKeyHashableValue() interface{} {
	return u.ID
}

// GetPrimaryKeyZeroValue implements mapping.Model interface method.
func (u *UserPets) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements mapping.Model interface method.
func (u *UserPets) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		u.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		u.ID = int(valueType)
	case int16:
		u.ID = int(valueType)
	case int32:
		u.ID = int(valueType)
	case int64:
		u.ID = int(valueType)
	case uint:
		u.ID = int(valueType)
	case uint8:
		u.ID = int(valueType)
	case uint16:
		u.ID = int(valueType)
	case uint32:
		u.ID = int(valueType)
	case uint64:
		u.ID = int(valueType)
	case float32:
		u.ID = int(valueType)
	case float64:
		u.ID = int(valueType)
	default:
		return errors.Newf(mapping.ClassFieldValue, "provided invalid value: '%T' for the primary field for model: 'UserPets'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (u *UserPets) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	if err != nil {
		return err
	}
	u.ID = int(tmp)
	return nil
}

// Compile time check if UserPets implements mapping.Fielder interface.
var _ mapping.Fielder = &UserPets{}

// GetFieldsAddress gets the address of provided 'field'.
func (u *UserPets) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &u.ID, nil
	case 1: // PetID
		return &u.PetID, nil
	case 2: // UserID
		return &u.UserID, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: UserPets'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (u *UserPets) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // PetID
		return 0, nil
	case 2: // UserID
		return 0, nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (u *UserPets) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return u.ID == 0, nil
	case 1: // PetID
		return u.PetID == 0, nil
	case 2: // UserID
		return u.UserID == 0, nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (u *UserPets) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		u.ID = 0
	case 1: // PetID
		u.PetID = 0
	case 2: // UserID
		u.UserID = 0
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (u *UserPets) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return u.ID, nil
	case 1: // PetID
		return u.PetID, nil
	case 2: // UserID
		return u.UserID, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'UserPets'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (u *UserPets) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return u.ID, nil
	case 1: // PetID
		return u.PetID, nil
	case 2: // UserID
		return u.UserID, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: UserPets'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (u *UserPets) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			u.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			u.ID = int(v)
		case int16:
			u.ID = int(v)
		case int32:
			u.ID = int(v)
		case int64:
			u.ID = int(v)
		case uint:
			u.ID = int(v)
		case uint8:
			u.ID = int(v)
		case uint16:
			u.ID = int(v)
		case uint32:
			u.ID = int(v)
		case uint64:
			u.ID = int(v)
		case float32:
			u.ID = int(v)
		case float64:
			u.ID = int(v)
		default:
			return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // PetID
		if v, ok := value.(int); ok {
			u.PetID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			u.PetID = int(v)
		case int16:
			u.PetID = int(v)
		case int32:
			u.PetID = int(v)
		case int64:
			u.PetID = int(v)
		case uint:
			u.PetID = int(v)
		case uint8:
			u.PetID = int(v)
		case uint16:
			u.PetID = int(v)
		case uint32:
			u.PetID = int(v)
		case uint64:
			u.PetID = int(v)
		case float32:
			u.PetID = int(v)
		case float64:
			u.PetID = int(v)
		default:
			return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 2: // UserID
		if v, ok := value.(int); ok {
			u.UserID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			u.UserID = int(v)
		case int16:
			u.UserID = int(v)
		case int32:
			u.UserID = int(v)
		case int64:
			u.UserID = int(v)
		case uint:
			u.UserID = int(v)
		case uint8:
			u.UserID = int(v)
		case uint16:
			u.UserID = int(v)
		case uint32:
			u.UserID = int(v)
		case uint64:
			u.UserID = int(v)
		case float32:
			u.UserID = int(v)
		case float64:
			u.UserID = int(v)
		default:
			return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'UserPets'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (u *UserPets) ParseFieldsStringValue(field *mapping.StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	case 1: // PetID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	case 2: // UserID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: UserPets'", field.Name())
}

// Compile time check if Comment implements mapping.Model interface.
var _ mapping.Model = &Comment{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'Comment'.
func (c *Comment) NeuronCollectionName() string {
	return "comments"
}

// IsPrimaryKeyZero implements mapping.Model interface method.
func (c *Comment) IsPrimaryKeyZero() bool {
	return c.ID == 0
}

// GetPrimaryKeyValue implements mapping.Model interface method.
func (c *Comment) GetPrimaryKeyValue() interface{} {
	return c.ID
}

// GetPrimaryKeyStringValue implements mapping.Model interface method.
func (c *Comment) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(c.ID), 10), nil
}

// GetPrimaryKeyAddress implements mapping.Model interface method.
func (c *Comment) GetPrimaryKeyAddress() interface{} {
	return &c.ID
}

// GetPrimaryKeyHashableValue implements mapping.Model interface method.
func (c *Comment) GetPrimaryKeyHashableValue() interface{} {
	return c.ID
}

// GetPrimaryKeyZeroValue implements mapping.Model interface method.
func (c *Comment) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements mapping.Model interface method.
func (c *Comment) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		c.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		c.ID = int(valueType)
	case int16:
		c.ID = int(valueType)
	case int32:
		c.ID = int(valueType)
	case int64:
		c.ID = int(valueType)
	case uint:
		c.ID = int(valueType)
	case uint8:
		c.ID = int(valueType)
	case uint16:
		c.ID = int(valueType)
	case uint32:
		c.ID = int(valueType)
	case uint64:
		c.ID = int(valueType)
	case float32:
		c.ID = int(valueType)
	case float64:
		c.ID = int(valueType)
	default:
		return errors.Newf(mapping.ClassFieldValue, "provided invalid value: '%T' for the primary field for model: 'Comment'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (c *Comment) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	if err != nil {
		return err
	}
	c.ID = int(tmp)
	return nil
}

// Compile time check if Comment implements mapping.Fielder interface.
var _ mapping.Fielder = &Comment{}

// GetFieldsAddress gets the address of provided 'field'.
func (c *Comment) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &c.ID, nil
	case 1: // PostID
		return &c.PostID, nil
	case 2: // Body
		return &c.Body, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: Comment'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (c *Comment) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // PostID
		return 0, nil
	case 2: // Body
		return "", nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (c *Comment) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return c.ID == 0, nil
	case 1: // PostID
		return c.PostID == 0, nil
	case 2: // Body
		return c.Body == "", nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (c *Comment) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		c.ID = 0
	case 1: // PostID
		c.PostID = 0
	case 2: // Body
		c.Body = ""
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (c *Comment) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return c.ID, nil
	case 1: // PostID
		return c.PostID, nil
	case 2: // Body
		return c.Body, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'Comment'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (c *Comment) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return c.ID, nil
	case 1: // PostID
		return c.PostID, nil
	case 2: // Body
		return c.Body, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: Comment'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (c *Comment) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			c.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			c.ID = int(v)
		case int16:
			c.ID = int(v)
		case int32:
			c.ID = int(v)
		case int64:
			c.ID = int(v)
		case uint:
			c.ID = int(v)
		case uint8:
			c.ID = int(v)
		case uint16:
			c.ID = int(v)
		case uint32:
			c.ID = int(v)
		case uint64:
			c.ID = int(v)
		case float32:
			c.ID = int(v)
		case float64:
			c.ID = int(v)
		default:
			return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // PostID
		if v, ok := value.(uint64); ok {
			c.PostID = v
			return nil
		}

		switch v := value.(type) {
		case int:
			c.PostID = uint64(v)
		case int8:
			c.PostID = uint64(v)
		case int16:
			c.PostID = uint64(v)
		case int32:
			c.PostID = uint64(v)
		case int64:
			c.PostID = uint64(v)
		case uint:
			c.PostID = uint64(v)
		case uint8:
			c.PostID = uint64(v)
		case uint16:
			c.PostID = uint64(v)
		case uint32:
			c.PostID = uint64(v)
		case float32:
			c.PostID = uint64(v)
		case float64:
			c.PostID = uint64(v)
		default:
			return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 2: // Body
		if v, ok := value.(string); ok {
			c.Body = v
			return nil
		}

		// Check alternate types for the Body.
		if v, ok := value.([]byte); ok {
			c.Body = string(v)
			return nil
		}
		return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'Comment'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (c *Comment) ParseFieldsStringValue(field *mapping.StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	case 1: // PostID
		return strconv.ParseUint(value, 10, 64)
	case 2: // Body
		return value, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: Comment'", field.Name())
}

// Compile time check if ModelPtrTime implements mapping.Model interface.
var _ mapping.Model = &ModelPtrTime{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'ModelPtrTime'.
func (m *ModelPtrTime) NeuronCollectionName() string {
	return "model_ptr_times"
}

// IsPrimaryKeyZero implements mapping.Model interface method.
func (m *ModelPtrTime) IsPrimaryKeyZero() bool {
	return m.ID == 0
}

// GetPrimaryKeyValue implements mapping.Model interface method.
func (m *ModelPtrTime) GetPrimaryKeyValue() interface{} {
	return m.ID
}

// GetPrimaryKeyStringValue implements mapping.Model interface method.
func (m *ModelPtrTime) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(m.ID), 10), nil
}

// GetPrimaryKeyAddress implements mapping.Model interface method.
func (m *ModelPtrTime) GetPrimaryKeyAddress() interface{} {
	return &m.ID
}

// GetPrimaryKeyHashableValue implements mapping.Model interface method.
func (m *ModelPtrTime) GetPrimaryKeyHashableValue() interface{} {
	return m.ID
}

// GetPrimaryKeyZeroValue implements mapping.Model interface method.
func (m *ModelPtrTime) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements mapping.Model interface method.
func (m *ModelPtrTime) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		m.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		m.ID = int(valueType)
	case int16:
		m.ID = int(valueType)
	case int32:
		m.ID = int(valueType)
	case int64:
		m.ID = int(valueType)
	case uint:
		m.ID = int(valueType)
	case uint8:
		m.ID = int(valueType)
	case uint16:
		m.ID = int(valueType)
	case uint32:
		m.ID = int(valueType)
	case uint64:
		m.ID = int(valueType)
	case float32:
		m.ID = int(valueType)
	case float64:
		m.ID = int(valueType)
	default:
		return errors.Newf(mapping.ClassFieldValue, "provided invalid value: '%T' for the primary field for model: 'ModelPtrTime'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (m *ModelPtrTime) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	if err != nil {
		return err
	}
	m.ID = int(tmp)
	return nil
}

// Compile time check if ModelPtrTime implements mapping.Fielder interface.
var _ mapping.Fielder = &ModelPtrTime{}

// GetFieldsAddress gets the address of provided 'field'.
func (m *ModelPtrTime) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &m.ID, nil
	case 1: // Time
		return &m.Time, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: ModelPtrTime'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (m *ModelPtrTime) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // Time
		return nil, nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (m *ModelPtrTime) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID == 0, nil
	case 1: // Time
		return m.Time == nil, nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (m *ModelPtrTime) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		m.ID = 0
	case 1: // Time
		m.Time = nil
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (m *ModelPtrTime) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID, nil
	case 1: // Time
		if m.Time == nil {
			return nil, nil
		}
		return *m.Time, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'ModelPtrTime'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (m *ModelPtrTime) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID, nil
	case 1: // Time
		return m.Time, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: ModelPtrTime'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (m *ModelPtrTime) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			m.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			m.ID = int(v)
		case int16:
			m.ID = int(v)
		case int32:
			m.ID = int(v)
		case int64:
			m.ID = int(v)
		case uint:
			m.ID = int(v)
		case uint8:
			m.ID = int(v)
		case uint16:
			m.ID = int(v)
		case uint32:
			m.ID = int(v)
		case uint64:
			m.ID = int(v)
		case float32:
			m.ID = int(v)
		case float64:
			m.ID = int(v)
		default:
			return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // Time
		if value == nil {
			m.Time = nil
			return nil
		}
		if v, ok := value.(*time.Time); ok {
			m.Time = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(time.Time); ok {
			m.Time = &v
			return nil
		}

		return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'ModelPtrTime'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (m *ModelPtrTime) ParseFieldsStringValue(field *mapping.StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	case 1: // Time
		var base time.Time
		temp := &base
		if err := temp.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Newf(mapping.ClassFieldValue, "invalid field 'Time' value: '%v' to parse string. Err: %v", m.Time, err)
		}
		bt, err := temp.MarshalText()
		if err != nil {
			return "", errors.Newf(mapping.ClassFieldValue, "invalid field 'Time' value: '%v' to parse string. Err: %v", m.Time, err)
		}

		return string(bt), nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: ModelPtrTime'", field.Name())
}

// Compile time check if HiddenModel implements mapping.Model interface.
var _ mapping.Model = &HiddenModel{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'HiddenModel'.
func (h *HiddenModel) NeuronCollectionName() string {
	return "hidden_models"
}

// IsPrimaryKeyZero implements mapping.Model interface method.
func (h *HiddenModel) IsPrimaryKeyZero() bool {
	return h.ID == 0
}

// GetPrimaryKeyValue implements mapping.Model interface method.
func (h *HiddenModel) GetPrimaryKeyValue() interface{} {
	return h.ID
}

// GetPrimaryKeyStringValue implements mapping.Model interface method.
func (h *HiddenModel) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(h.ID), 10), nil
}

// GetPrimaryKeyAddress implements mapping.Model interface method.
func (h *HiddenModel) GetPrimaryKeyAddress() interface{} {
	return &h.ID
}

// GetPrimaryKeyHashableValue implements mapping.Model interface method.
func (h *HiddenModel) GetPrimaryKeyHashableValue() interface{} {
	return h.ID
}

// GetPrimaryKeyZeroValue implements mapping.Model interface method.
func (h *HiddenModel) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements mapping.Model interface method.
func (h *HiddenModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		h.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		h.ID = int(valueType)
	case int16:
		h.ID = int(valueType)
	case int32:
		h.ID = int(valueType)
	case int64:
		h.ID = int(valueType)
	case uint:
		h.ID = int(valueType)
	case uint8:
		h.ID = int(valueType)
	case uint16:
		h.ID = int(valueType)
	case uint32:
		h.ID = int(valueType)
	case uint64:
		h.ID = int(valueType)
	case float32:
		h.ID = int(valueType)
	case float64:
		h.ID = int(valueType)
	default:
		return errors.Newf(mapping.ClassFieldValue, "provided invalid value: '%T' for the primary field for model: 'HiddenModel'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (h *HiddenModel) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	if err != nil {
		return err
	}
	h.ID = int(tmp)
	return nil
}

// Compile time check if HiddenModel implements mapping.Fielder interface.
var _ mapping.Fielder = &HiddenModel{}

// GetFieldsAddress gets the address of provided 'field'.
func (h *HiddenModel) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &h.ID, nil
	case 1: // Visibile
		return &h.Visibile, nil
	case 2: // HiddenField
		return &h.HiddenField, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: HiddenModel'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (h *HiddenModel) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // Visibile
		return "", nil
	case 2: // HiddenField
		return "", nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (h *HiddenModel) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return h.ID == 0, nil
	case 1: // Visibile
		return h.Visibile == "", nil
	case 2: // HiddenField
		return h.HiddenField == "", nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (h *HiddenModel) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		h.ID = 0
	case 1: // Visibile
		h.Visibile = ""
	case 2: // HiddenField
		h.HiddenField = ""
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (h *HiddenModel) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return h.ID, nil
	case 1: // Visibile
		return h.Visibile, nil
	case 2: // HiddenField
		return h.HiddenField, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'HiddenModel'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (h *HiddenModel) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return h.ID, nil
	case 1: // Visibile
		return h.Visibile, nil
	case 2: // HiddenField
		return h.HiddenField, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: HiddenModel'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (h *HiddenModel) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			h.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			h.ID = int(v)
		case int16:
			h.ID = int(v)
		case int32:
			h.ID = int(v)
		case int64:
			h.ID = int(v)
		case uint:
			h.ID = int(v)
		case uint8:
			h.ID = int(v)
		case uint16:
			h.ID = int(v)
		case uint32:
			h.ID = int(v)
		case uint64:
			h.ID = int(v)
		case float32:
			h.ID = int(v)
		case float64:
			h.ID = int(v)
		default:
			return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // Visibile
		if v, ok := value.(string); ok {
			h.Visibile = v
			return nil
		}

		// Check alternate types for the Visibile.
		if v, ok := value.([]byte); ok {
			h.Visibile = string(v)
			return nil
		}
		return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // HiddenField
		if v, ok := value.(string); ok {
			h.HiddenField = v
			return nil
		}

		// Check alternate types for the HiddenField.
		if v, ok := value.([]byte); ok {
			h.HiddenField = string(v)
			return nil
		}
		return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'HiddenModel'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (h *HiddenModel) ParseFieldsStringValue(field *mapping.StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	case 1: // Visibile
		return value, nil
	case 2: // HiddenField
		return value, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: HiddenModel'", field.Name())
}

// Compile time check if CustomTagModel implements mapping.Model interface.
var _ mapping.Model = &CustomTagModel{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'CustomTagModel'.
func (c *CustomTagModel) NeuronCollectionName() string {
	return "custom_tag_models"
}

// IsPrimaryKeyZero implements mapping.Model interface method.
func (c *CustomTagModel) IsPrimaryKeyZero() bool {
	return c.ID == 0
}

// GetPrimaryKeyValue implements mapping.Model interface method.
func (c *CustomTagModel) GetPrimaryKeyValue() interface{} {
	return c.ID
}

// GetPrimaryKeyStringValue implements mapping.Model interface method.
func (c *CustomTagModel) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(c.ID), 10), nil
}

// GetPrimaryKeyAddress implements mapping.Model interface method.
func (c *CustomTagModel) GetPrimaryKeyAddress() interface{} {
	return &c.ID
}

// GetPrimaryKeyHashableValue implements mapping.Model interface method.
func (c *CustomTagModel) GetPrimaryKeyHashableValue() interface{} {
	return c.ID
}

// GetPrimaryKeyZeroValue implements mapping.Model interface method.
func (c *CustomTagModel) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements mapping.Model interface method.
func (c *CustomTagModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		c.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		c.ID = int(valueType)
	case int16:
		c.ID = int(valueType)
	case int32:
		c.ID = int(valueType)
	case int64:
		c.ID = int(valueType)
	case uint:
		c.ID = int(valueType)
	case uint8:
		c.ID = int(valueType)
	case uint16:
		c.ID = int(valueType)
	case uint32:
		c.ID = int(valueType)
	case uint64:
		c.ID = int(valueType)
	case float32:
		c.ID = int(valueType)
	case float64:
		c.ID = int(valueType)
	default:
		return errors.Newf(mapping.ClassFieldValue, "provided invalid value: '%T' for the primary field for model: 'CustomTagModel'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (c *CustomTagModel) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	if err != nil {
		return err
	}
	c.ID = int(tmp)
	return nil
}

// Compile time check if CustomTagModel implements mapping.Fielder interface.
var _ mapping.Fielder = &CustomTagModel{}

// GetFieldsAddress gets the address of provided 'field'.
func (c *CustomTagModel) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &c.ID, nil
	case 1: // VisibleCustomName
		return &c.VisibleCustomName, nil
	case 2: // HiddenField
		return &c.HiddenField, nil
	case 3: // OmitEmptyField
		return &c.OmitEmptyField, nil
	case 4: // CustomOmitEmpty
		return &c.CustomOmitEmpty, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: CustomTagModel'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (c *CustomTagModel) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // VisibleCustomName
		return "", nil
	case 2: // HiddenField
		return false, nil
	case 3: // OmitEmptyField
		return "", nil
	case 4: // CustomOmitEmpty
		return "", nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (c *CustomTagModel) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return c.ID == 0, nil
	case 1: // VisibleCustomName
		return c.VisibleCustomName == "", nil
	case 2: // HiddenField
		return c.HiddenField == false, nil
	case 3: // OmitEmptyField
		return c.OmitEmptyField == "", nil
	case 4: // CustomOmitEmpty
		return c.CustomOmitEmpty == "", nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (c *CustomTagModel) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		c.ID = 0
	case 1: // VisibleCustomName
		c.VisibleCustomName = ""
	case 2: // HiddenField
		c.HiddenField = false
	case 3: // OmitEmptyField
		c.OmitEmptyField = ""
	case 4: // CustomOmitEmpty
		c.CustomOmitEmpty = ""
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (c *CustomTagModel) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return c.ID, nil
	case 1: // VisibleCustomName
		return c.VisibleCustomName, nil
	case 2: // HiddenField
		return c.HiddenField, nil
	case 3: // OmitEmptyField
		return c.OmitEmptyField, nil
	case 4: // CustomOmitEmpty
		return c.CustomOmitEmpty, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'CustomTagModel'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (c *CustomTagModel) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return c.ID, nil
	case 1: // VisibleCustomName
		return c.VisibleCustomName, nil
	case 2: // HiddenField
		return c.HiddenField, nil
	case 3: // OmitEmptyField
		return c.OmitEmptyField, nil
	case 4: // CustomOmitEmpty
		return c.CustomOmitEmpty, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: CustomTagModel'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (c *CustomTagModel) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			c.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			c.ID = int(v)
		case int16:
			c.ID = int(v)
		case int32:
			c.ID = int(v)
		case int64:
			c.ID = int(v)
		case uint:
			c.ID = int(v)
		case uint8:
			c.ID = int(v)
		case uint16:
			c.ID = int(v)
		case uint32:
			c.ID = int(v)
		case uint64:
			c.ID = int(v)
		case float32:
			c.ID = int(v)
		case float64:
			c.ID = int(v)
		default:
			return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // VisibleCustomName
		if v, ok := value.(string); ok {
			c.VisibleCustomName = v
			return nil
		}

		// Check alternate types for the VisibleCustomName.
		if v, ok := value.([]byte); ok {
			c.VisibleCustomName = string(v)
			return nil
		}
		return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // HiddenField
		if v, ok := value.(bool); ok {
			c.HiddenField = v
			return nil
		}

		return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // OmitEmptyField
		if v, ok := value.(string); ok {
			c.OmitEmptyField = v
			return nil
		}

		// Check alternate types for the OmitEmptyField.
		if v, ok := value.([]byte); ok {
			c.OmitEmptyField = string(v)
			return nil
		}
		return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 4: // CustomOmitEmpty
		if v, ok := value.(string); ok {
			c.CustomOmitEmpty = v
			return nil
		}

		// Check alternate types for the CustomOmitEmpty.
		if v, ok := value.([]byte); ok {
			c.CustomOmitEmpty = string(v)
			return nil
		}
		return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'CustomTagModel'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (c *CustomTagModel) ParseFieldsStringValue(field *mapping.StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	case 1: // VisibleCustomName
		return value, nil
	case 2: // HiddenField
		return strconv.ParseBool(value)
	case 3: // OmitEmptyField
		return value, nil
	case 4: // CustomOmitEmpty
		return value, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: CustomTagModel'", field.Name())
}

// Compile time check if User implements mapping.Model interface.
var _ mapping.Model = &User{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'User'.
func (u *User) NeuronCollectionName() string {
	return "users"
}

// IsPrimaryKeyZero implements mapping.Model interface method.
func (u *User) IsPrimaryKeyZero() bool {
	return u.ID == 0
}

// GetPrimaryKeyValue implements mapping.Model interface method.
func (u *User) GetPrimaryKeyValue() interface{} {
	return u.ID
}

// GetPrimaryKeyStringValue implements mapping.Model interface method.
func (u *User) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(u.ID), 10), nil
}

// GetPrimaryKeyAddress implements mapping.Model interface method.
func (u *User) GetPrimaryKeyAddress() interface{} {
	return &u.ID
}

// GetPrimaryKeyHashableValue implements mapping.Model interface method.
func (u *User) GetPrimaryKeyHashableValue() interface{} {
	return u.ID
}

// GetPrimaryKeyZeroValue implements mapping.Model interface method.
func (u *User) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements mapping.Model interface method.
func (u *User) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		u.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		u.ID = int(valueType)
	case int16:
		u.ID = int(valueType)
	case int32:
		u.ID = int(valueType)
	case int64:
		u.ID = int(valueType)
	case uint:
		u.ID = int(valueType)
	case uint8:
		u.ID = int(valueType)
	case uint16:
		u.ID = int(valueType)
	case uint32:
		u.ID = int(valueType)
	case uint64:
		u.ID = int(valueType)
	case float32:
		u.ID = int(valueType)
	case float64:
		u.ID = int(valueType)
	default:
		return errors.Newf(mapping.ClassFieldValue, "provided invalid value: '%T' for the primary field for model: 'User'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (u *User) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	if err != nil {
		return err
	}
	u.ID = int(tmp)
	return nil
}

// Compile time check if User implements mapping.Fielder interface.
var _ mapping.Fielder = &User{}

// GetFieldsAddress gets the address of provided 'field'.
func (u *User) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // ID
		return &u.ID, nil
	case 2: // Lang
		return &u.Lang, nil
	case 3: // Name
		return &u.Name, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: User'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (u *User) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // ID
		return 0, nil
	case 2: // Lang
		return "", nil
	case 3: // Name
		return "", nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (u *User) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 1: // ID
		return u.ID == 0, nil
	case 2: // Lang
		return u.Lang == "", nil
	case 3: // Name
		return u.Name == "", nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (u *User) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 1: // ID
		u.ID = 0
	case 2: // Lang
		u.Lang = ""
	case 3: // Name
		u.Name = ""
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (u *User) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // ID
		return u.ID, nil
	case 2: // Lang
		return u.Lang, nil
	case 3: // Name
		return u.Name, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'User'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (u *User) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 1: // ID
		return u.ID, nil
	case 2: // Lang
		return u.Lang, nil
	case 3: // Name
		return u.Name, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: User'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (u *User) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 1: // ID
		if v, ok := value.(int); ok {
			u.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			u.ID = int(v)
		case int16:
			u.ID = int(v)
		case int32:
			u.ID = int(v)
		case int64:
			u.ID = int(v)
		case uint:
			u.ID = int(v)
		case uint8:
			u.ID = int(v)
		case uint16:
			u.ID = int(v)
		case uint32:
			u.ID = int(v)
		case uint64:
			u.ID = int(v)
		case float32:
			u.ID = int(v)
		case float64:
			u.ID = int(v)
		default:
			return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 2: // Lang
		if v, ok := value.(string); ok {
			u.Lang = v
			return nil
		}

		// Check alternate types for the Lang.
		if v, ok := value.([]byte); ok {
			u.Lang = string(v)
			return nil
		}
		return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // Name
		if v, ok := value.(string); ok {
			u.Name = v
			return nil
		}

		// Check alternate types for the Name.
		if v, ok := value.([]byte); ok {
			u.Name = string(v)
			return nil
		}
		return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'User'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (u *User) ParseFieldsStringValue(field *mapping.StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 1: // ID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	case 2: // Lang
		return value, nil
	case 3: // Name
		return value, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: User'", field.Name())
}

// Compile time check for the mapping.MultiRelationer interface implementation.
var _ mapping.MultiRelationer = &User{}

// AddRelationModel implements mapping.MultiRelationer interface.
func (u *User) AddRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 4: // Pets
		pet, ok := model.(*Pet)
		if !ok {
			return errors.Newf(mapping.ClassInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Pets'", model)
		}
		u.Pets = append(u.Pets, pet)
	default:
		return errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%T' for the model 'User'", model)
	}
	return nil
}

// GetRelationModels implements mapping.MultiRelationer interface.
func (u *User) GetRelationModels(relation *mapping.StructField) (models []mapping.Model, err error) {
	switch relation.Index[0] {
	case 4: // Pets
		for _, model := range u.Pets {
			models = append(models, model)
		}
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, u)
	}
	return models, nil
}

// GetRelationModelAt implements mapping.MultiRelationer interface.
func (u *User) GetRelationModelAt(relation *mapping.StructField, index int) (models mapping.Model, err error) {
	switch relation.Index[0] {
	case 4: // Pets
		if index > len(u.Pets)-1 {
			return nil, errors.Newf(mapping.ClassInvalidRelationIndex, "index out of possible range. Model: 'User', Field Pets")
		}
		return u.Pets[index], nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, u)
	}
	return models, nil
}

// GetRelationLen implements mapping.MultiRelationer interface.
func (u *User) GetRelationLen(relation *mapping.StructField) (int, error) {
	switch relation.Index[0] {
	case 4: // Pets
		return len(u.Pets), nil
	default:
		return 0, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, u)
	}
}

// Compile time check if Pet implements mapping.Model interface.
var _ mapping.Model = &Pet{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'Pet'.
func (p *Pet) NeuronCollectionName() string {
	return "pets"
}

// IsPrimaryKeyZero implements mapping.Model interface method.
func (p *Pet) IsPrimaryKeyZero() bool {
	return p.ID == 0
}

// GetPrimaryKeyValue implements mapping.Model interface method.
func (p *Pet) GetPrimaryKeyValue() interface{} {
	return p.ID
}

// GetPrimaryKeyStringValue implements mapping.Model interface method.
func (p *Pet) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(p.ID), 10), nil
}

// GetPrimaryKeyAddress implements mapping.Model interface method.
func (p *Pet) GetPrimaryKeyAddress() interface{} {
	return &p.ID
}

// GetPrimaryKeyHashableValue implements mapping.Model interface method.
func (p *Pet) GetPrimaryKeyHashableValue() interface{} {
	return p.ID
}

// GetPrimaryKeyZeroValue implements mapping.Model interface method.
func (p *Pet) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements mapping.Model interface method.
func (p *Pet) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		p.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		p.ID = int(valueType)
	case int16:
		p.ID = int(valueType)
	case int32:
		p.ID = int(valueType)
	case int64:
		p.ID = int(valueType)
	case uint:
		p.ID = int(valueType)
	case uint8:
		p.ID = int(valueType)
	case uint16:
		p.ID = int(valueType)
	case uint32:
		p.ID = int(valueType)
	case uint64:
		p.ID = int(valueType)
	case float32:
		p.ID = int(valueType)
	case float64:
		p.ID = int(valueType)
	default:
		return errors.Newf(mapping.ClassFieldValue, "provided invalid value: '%T' for the primary field for model: 'Pet'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (p *Pet) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	if err != nil {
		return err
	}
	p.ID = int(tmp)
	return nil
}

// Compile time check if Pet implements mapping.Fielder interface.
var _ mapping.Fielder = &Pet{}

// GetFieldsAddress gets the address of provided 'field'.
func (p *Pet) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &p.ID, nil
	case 1: // Name
		return &p.Name, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: Pet'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (p *Pet) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // Name
		return "", nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (p *Pet) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return p.ID == 0, nil
	case 1: // Name
		return p.Name == "", nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (p *Pet) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		p.ID = 0
	case 1: // Name
		p.Name = ""
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (p *Pet) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return p.ID, nil
	case 1: // Name
		return p.Name, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'Pet'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (p *Pet) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return p.ID, nil
	case 1: // Name
		return p.Name, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: Pet'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (p *Pet) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			p.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			p.ID = int(v)
		case int16:
			p.ID = int(v)
		case int32:
			p.ID = int(v)
		case int64:
			p.ID = int(v)
		case uint:
			p.ID = int(v)
		case uint8:
			p.ID = int(v)
		case uint16:
			p.ID = int(v)
		case uint32:
			p.ID = int(v)
		case uint64:
			p.ID = int(v)
		case float32:
			p.ID = int(v)
		case float64:
			p.ID = int(v)
		default:
			return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // Name
		if v, ok := value.(string); ok {
			p.Name = v
			return nil
		}

		// Check alternate types for the Name.
		if v, ok := value.([]byte); ok {
			p.Name = string(v)
			return nil
		}
		return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'Pet'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (p *Pet) ParseFieldsStringValue(field *mapping.StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	case 1: // Name
		return value, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: Pet'", field.Name())
}

// Compile time check for the mapping.MultiRelationer interface implementation.
var _ mapping.MultiRelationer = &Pet{}

// AddRelationModel implements mapping.MultiRelationer interface.
func (p *Pet) AddRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 2: // Owners
		user, ok := model.(*User)
		if !ok {
			return errors.Newf(mapping.ClassInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Owners'", model)
		}
		p.Owners = append(p.Owners, user)
	default:
		return errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%T' for the model 'Pet'", model)
	}
	return nil
}

// GetRelationModels implements mapping.MultiRelationer interface.
func (p *Pet) GetRelationModels(relation *mapping.StructField) (models []mapping.Model, err error) {
	switch relation.Index[0] {
	case 2: // Owners
		for _, model := range p.Owners {
			models = append(models, model)
		}
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, p)
	}
	return models, nil
}

// GetRelationModelAt implements mapping.MultiRelationer interface.
func (p *Pet) GetRelationModelAt(relation *mapping.StructField, index int) (models mapping.Model, err error) {
	switch relation.Index[0] {
	case 2: // Owners
		if index > len(p.Owners)-1 {
			return nil, errors.Newf(mapping.ClassInvalidRelationIndex, "index out of possible range. Model: 'Pet', Field Owners")
		}
		return p.Owners[index], nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, p)
	}
	return models, nil
}

// GetRelationLen implements mapping.MultiRelationer interface.
func (p *Pet) GetRelationLen(relation *mapping.StructField) (int, error) {
	switch relation.Index[0] {
	case 2: // Owners
		return len(p.Owners), nil
	default:
		return 0, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, p)
	}
}

// Compile time check if Blog implements mapping.Model interface.
var _ mapping.Model = &Blog{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'Blog'.
func (b *Blog) NeuronCollectionName() string {
	return "blogs"
}

// IsPrimaryKeyZero implements mapping.Model interface method.
func (b *Blog) IsPrimaryKeyZero() bool {
	return b.ID == 0
}

// GetPrimaryKeyValue implements mapping.Model interface method.
func (b *Blog) GetPrimaryKeyValue() interface{} {
	return b.ID
}

// GetPrimaryKeyStringValue implements mapping.Model interface method.
func (b *Blog) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(b.ID), 10), nil
}

// GetPrimaryKeyAddress implements mapping.Model interface method.
func (b *Blog) GetPrimaryKeyAddress() interface{} {
	return &b.ID
}

// GetPrimaryKeyHashableValue implements mapping.Model interface method.
func (b *Blog) GetPrimaryKeyHashableValue() interface{} {
	return b.ID
}

// GetPrimaryKeyZeroValue implements mapping.Model interface method.
func (b *Blog) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements mapping.Model interface method.
func (b *Blog) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		b.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		b.ID = int(valueType)
	case int16:
		b.ID = int(valueType)
	case int32:
		b.ID = int(valueType)
	case int64:
		b.ID = int(valueType)
	case uint:
		b.ID = int(valueType)
	case uint8:
		b.ID = int(valueType)
	case uint16:
		b.ID = int(valueType)
	case uint32:
		b.ID = int(valueType)
	case uint64:
		b.ID = int(valueType)
	case float32:
		b.ID = int(valueType)
	case float64:
		b.ID = int(valueType)
	default:
		return errors.Newf(mapping.ClassFieldValue, "provided invalid value: '%T' for the primary field for model: 'Blog'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (b *Blog) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	if err != nil {
		return err
	}
	b.ID = int(tmp)
	return nil
}

// Compile time check if Blog implements mapping.Fielder interface.
var _ mapping.Fielder = &Blog{}

// GetFieldsAddress gets the address of provided 'field'.
func (b *Blog) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &b.ID, nil
	case 1: // Title
		return &b.Title, nil
	case 4: // CurrentPostID
		return &b.CurrentPostID, nil
	case 5: // CreatedAt
		return &b.CreatedAt, nil
	case 6: // ViewCount
		return &b.ViewCount, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: Blog'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (b *Blog) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // Title
		return "", nil
	case 4: // CurrentPostID
		return 0, nil
	case 5: // CreatedAt
		return time.Time{}, nil
	case 6: // ViewCount
		return 0, nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (b *Blog) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return b.ID == 0, nil
	case 1: // Title
		return b.Title == "", nil
	case 4: // CurrentPostID
		return b.CurrentPostID == 0, nil
	case 5: // CreatedAt
		return b.CreatedAt == time.Time{}, nil
	case 6: // ViewCount
		return b.ViewCount == 0, nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (b *Blog) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		b.ID = 0
	case 1: // Title
		b.Title = ""
	case 4: // CurrentPostID
		b.CurrentPostID = 0
	case 5: // CreatedAt
		b.CreatedAt = time.Time{}
	case 6: // ViewCount
		b.ViewCount = 0
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (b *Blog) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return b.ID, nil
	case 1: // Title
		return b.Title, nil
	case 4: // CurrentPostID
		return b.CurrentPostID, nil
	case 5: // CreatedAt
		return b.CreatedAt, nil
	case 6: // ViewCount
		return b.ViewCount, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'Blog'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (b *Blog) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return b.ID, nil
	case 1: // Title
		return b.Title, nil
	case 4: // CurrentPostID
		return b.CurrentPostID, nil
	case 5: // CreatedAt
		return b.CreatedAt, nil
	case 6: // ViewCount
		return b.ViewCount, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: Blog'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (b *Blog) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			b.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			b.ID = int(v)
		case int16:
			b.ID = int(v)
		case int32:
			b.ID = int(v)
		case int64:
			b.ID = int(v)
		case uint:
			b.ID = int(v)
		case uint8:
			b.ID = int(v)
		case uint16:
			b.ID = int(v)
		case uint32:
			b.ID = int(v)
		case uint64:
			b.ID = int(v)
		case float32:
			b.ID = int(v)
		case float64:
			b.ID = int(v)
		default:
			return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // Title
		if v, ok := value.(string); ok {
			b.Title = v
			return nil
		}

		// Check alternate types for the Title.
		if v, ok := value.([]byte); ok {
			b.Title = string(v)
			return nil
		}
		return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 4: // CurrentPostID
		if v, ok := value.(uint64); ok {
			b.CurrentPostID = v
			return nil
		}

		switch v := value.(type) {
		case int:
			b.CurrentPostID = uint64(v)
		case int8:
			b.CurrentPostID = uint64(v)
		case int16:
			b.CurrentPostID = uint64(v)
		case int32:
			b.CurrentPostID = uint64(v)
		case int64:
			b.CurrentPostID = uint64(v)
		case uint:
			b.CurrentPostID = uint64(v)
		case uint8:
			b.CurrentPostID = uint64(v)
		case uint16:
			b.CurrentPostID = uint64(v)
		case uint32:
			b.CurrentPostID = uint64(v)
		case float32:
			b.CurrentPostID = uint64(v)
		case float64:
			b.CurrentPostID = uint64(v)
		default:
			return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 5: // CreatedAt
		if v, ok := value.(time.Time); ok {
			b.CreatedAt = v
			return nil
		}

		return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 6: // ViewCount
		if v, ok := value.(int); ok {
			b.ViewCount = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			b.ViewCount = int(v)
		case int16:
			b.ViewCount = int(v)
		case int32:
			b.ViewCount = int(v)
		case int64:
			b.ViewCount = int(v)
		case uint:
			b.ViewCount = int(v)
		case uint8:
			b.ViewCount = int(v)
		case uint16:
			b.ViewCount = int(v)
		case uint32:
			b.ViewCount = int(v)
		case uint64:
			b.ViewCount = int(v)
		case float32:
			b.ViewCount = int(v)
		case float64:
			b.ViewCount = int(v)
		default:
			return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'Blog'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (b *Blog) ParseFieldsStringValue(field *mapping.StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	case 1: // Title
		return value, nil
	case 4: // CurrentPostID
		return strconv.ParseUint(value, 10, 64)
	case 5: // CreatedAt
		temp := b.CreatedAt
		if err := b.CreatedAt.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Newf(mapping.ClassFieldValue, "invalid field 'CreatedAt' value: '%v' to parse string. Err: %v", b.CreatedAt, err)
		}
		bt, err := b.CreatedAt.MarshalText()
		if err != nil {
			return "", errors.Newf(mapping.ClassFieldValue, "invalid field 'CreatedAt' value: '%v' to parse string. Err: %v", b.CreatedAt, err)
		}
		b.CreatedAt = temp
		return string(bt), nil
	case 6: // ViewCount
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: Blog'", field.Name())
}

// Compile time check if Blog implements mapping.SingleRelationer interface.
var _ mapping.SingleRelationer = &Blog{}

// GetRelationModel implements mapping.SingleRelationer interface.
func (b *Blog) GetRelationModel(relation *mapping.StructField) (mapping.Model, error) {
	switch relation.Index[0] {
	case 3: // CurrentPost
		if b.CurrentPost == nil {
			return nil, nil
		}
		return b.CurrentPost, nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, b)
	}
}

// SetRelationModel implements mapping.SingleRelationer interface.
func (b *Blog) SetRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 3: // CurrentPost
		if model == nil {
			b.CurrentPost = nil
			return nil
		} else if currentPost, ok := model.(*Post); ok {
			b.CurrentPost = currentPost
			return nil
		}
		return errors.Newf(mapping.ClassInvalidRelationValue, "provided invalid model value: '%T' for relation CurrentPost", model)
	default:
		return errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, b)
	}
}

// Compile time check for the mapping.MultiRelationer interface implementation.
var _ mapping.MultiRelationer = &Blog{}

// AddRelationModel implements mapping.MultiRelationer interface.
func (b *Blog) AddRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 2: // Posts
		post, ok := model.(*Post)
		if !ok {
			return errors.Newf(mapping.ClassInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Posts'", model)
		}
		b.Posts = append(b.Posts, post)
	default:
		return errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%T' for the model 'Blog'", model)
	}
	return nil
}

// GetRelationModels implements mapping.MultiRelationer interface.
func (b *Blog) GetRelationModels(relation *mapping.StructField) (models []mapping.Model, err error) {
	switch relation.Index[0] {
	case 2: // Posts
		for _, model := range b.Posts {
			models = append(models, model)
		}
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, b)
	}
	return models, nil
}

// GetRelationModelAt implements mapping.MultiRelationer interface.
func (b *Blog) GetRelationModelAt(relation *mapping.StructField, index int) (models mapping.Model, err error) {
	switch relation.Index[0] {
	case 2: // Posts
		if index > len(b.Posts)-1 {
			return nil, errors.Newf(mapping.ClassInvalidRelationIndex, "index out of possible range. Model: 'Blog', Field Posts")
		}
		return b.Posts[index], nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, b)
	}
	return models, nil
}

// GetRelationLen implements mapping.MultiRelationer interface.
func (b *Blog) GetRelationLen(relation *mapping.StructField) (int, error) {
	switch relation.Index[0] {
	case 2: // Posts
		return len(b.Posts), nil
	default:
		return 0, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, b)
	}
}

// Compile time check if Post implements mapping.Model interface.
var _ mapping.Model = &Post{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'Post'.
func (p *Post) NeuronCollectionName() string {
	return "posts"
}

// IsPrimaryKeyZero implements mapping.Model interface method.
func (p *Post) IsPrimaryKeyZero() bool {
	return p.ID == 0
}

// GetPrimaryKeyValue implements mapping.Model interface method.
func (p *Post) GetPrimaryKeyValue() interface{} {
	return p.ID
}

// GetPrimaryKeyStringValue implements mapping.Model interface method.
func (p *Post) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatUint(p.ID, 10), nil
}

// GetPrimaryKeyAddress implements mapping.Model interface method.
func (p *Post) GetPrimaryKeyAddress() interface{} {
	return &p.ID
}

// GetPrimaryKeyHashableValue implements mapping.Model interface method.
func (p *Post) GetPrimaryKeyHashableValue() interface{} {
	return p.ID
}

// GetPrimaryKeyZeroValue implements mapping.Model interface method.
func (p *Post) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements mapping.Model interface method.
func (p *Post) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(uint64); ok {
		p.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int:
		p.ID = uint64(valueType)
	case int8:
		p.ID = uint64(valueType)
	case int16:
		p.ID = uint64(valueType)
	case int32:
		p.ID = uint64(valueType)
	case int64:
		p.ID = uint64(valueType)
	case uint:
		p.ID = uint64(valueType)
	case uint8:
		p.ID = uint64(valueType)
	case uint16:
		p.ID = uint64(valueType)
	case uint32:
		p.ID = uint64(valueType)
	case float32:
		p.ID = uint64(valueType)
	case float64:
		p.ID = uint64(valueType)
	default:
		return errors.Newf(mapping.ClassFieldValue, "provided invalid value: '%T' for the primary field for model: 'Post'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (p *Post) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseUint(value, 10, 64)
	if err != nil {
		return err
	}
	p.ID = tmp
	return nil
}

// Compile time check if Post implements mapping.Fielder interface.
var _ mapping.Fielder = &Post{}

// GetFieldsAddress gets the address of provided 'field'.
func (p *Post) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &p.ID, nil
	case 1: // BlogID
		return &p.BlogID, nil
	case 2: // Title
		return &p.Title, nil
	case 3: // Body
		return &p.Body, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: Post'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (p *Post) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // BlogID
		return 0, nil
	case 2: // Title
		return "", nil
	case 3: // Body
		return "", nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (p *Post) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return p.ID == 0, nil
	case 1: // BlogID
		return p.BlogID == 0, nil
	case 2: // Title
		return p.Title == "", nil
	case 3: // Body
		return p.Body == "", nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (p *Post) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		p.ID = 0
	case 1: // BlogID
		p.BlogID = 0
	case 2: // Title
		p.Title = ""
	case 3: // Body
		p.Body = ""
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (p *Post) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return p.ID, nil
	case 1: // BlogID
		return p.BlogID, nil
	case 2: // Title
		return p.Title, nil
	case 3: // Body
		return p.Body, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'Post'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (p *Post) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return p.ID, nil
	case 1: // BlogID
		return p.BlogID, nil
	case 2: // Title
		return p.Title, nil
	case 3: // Body
		return p.Body, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: Post'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (p *Post) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(uint64); ok {
			p.ID = v
			return nil
		}

		switch v := value.(type) {
		case int:
			p.ID = uint64(v)
		case int8:
			p.ID = uint64(v)
		case int16:
			p.ID = uint64(v)
		case int32:
			p.ID = uint64(v)
		case int64:
			p.ID = uint64(v)
		case uint:
			p.ID = uint64(v)
		case uint8:
			p.ID = uint64(v)
		case uint16:
			p.ID = uint64(v)
		case uint32:
			p.ID = uint64(v)
		case float32:
			p.ID = uint64(v)
		case float64:
			p.ID = uint64(v)
		default:
			return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // BlogID
		if v, ok := value.(int); ok {
			p.BlogID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			p.BlogID = int(v)
		case int16:
			p.BlogID = int(v)
		case int32:
			p.BlogID = int(v)
		case int64:
			p.BlogID = int(v)
		case uint:
			p.BlogID = int(v)
		case uint8:
			p.BlogID = int(v)
		case uint16:
			p.BlogID = int(v)
		case uint32:
			p.BlogID = int(v)
		case uint64:
			p.BlogID = int(v)
		case float32:
			p.BlogID = int(v)
		case float64:
			p.BlogID = int(v)
		default:
			return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 2: // Title
		if v, ok := value.(string); ok {
			p.Title = v
			return nil
		}

		// Check alternate types for the Title.
		if v, ok := value.([]byte); ok {
			p.Title = string(v)
			return nil
		}
		return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // Body
		if v, ok := value.(string); ok {
			p.Body = v
			return nil
		}

		// Check alternate types for the Body.
		if v, ok := value.([]byte); ok {
			p.Body = string(v)
			return nil
		}
		return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'Post'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (p *Post) ParseFieldsStringValue(field *mapping.StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseUint(value, 10, 64)
	case 1: // BlogID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	case 2: // Title
		return value, nil
	case 3: // Body
		return value, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: Post'", field.Name())
}

// Compile time check if Post implements mapping.SingleRelationer interface.
var _ mapping.SingleRelationer = &Post{}

// GetRelationModel implements mapping.SingleRelationer interface.
func (p *Post) GetRelationModel(relation *mapping.StructField) (mapping.Model, error) {
	switch relation.Index[0] {
	case 5: // LatestComment
		if p.LatestComment == nil {
			return nil, nil
		}
		return p.LatestComment, nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, p)
	}
}

// SetRelationModel implements mapping.SingleRelationer interface.
func (p *Post) SetRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 5: // LatestComment
		if model == nil {
			p.LatestComment = nil
			return nil
		} else if latestComment, ok := model.(*Comment); ok {
			p.LatestComment = latestComment
			return nil
		}
		return errors.Newf(mapping.ClassInvalidRelationValue, "provided invalid model value: '%T' for relation LatestComment", model)
	default:
		return errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, p)
	}
}

// Compile time check for the mapping.MultiRelationer interface implementation.
var _ mapping.MultiRelationer = &Post{}

// AddRelationModel implements mapping.MultiRelationer interface.
func (p *Post) AddRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 4: // Comments
		comment, ok := model.(*Comment)
		if !ok {
			return errors.Newf(mapping.ClassInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Comments'", model)
		}
		p.Comments = append(p.Comments, comment)
	default:
		return errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%T' for the model 'Post'", model)
	}
	return nil
}

// GetRelationModels implements mapping.MultiRelationer interface.
func (p *Post) GetRelationModels(relation *mapping.StructField) (models []mapping.Model, err error) {
	switch relation.Index[0] {
	case 4: // Comments
		for _, model := range p.Comments {
			models = append(models, model)
		}
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, p)
	}
	return models, nil
}

// GetRelationModelAt implements mapping.MultiRelationer interface.
func (p *Post) GetRelationModelAt(relation *mapping.StructField, index int) (models mapping.Model, err error) {
	switch relation.Index[0] {
	case 4: // Comments
		if index > len(p.Comments)-1 {
			return nil, errors.Newf(mapping.ClassInvalidRelationIndex, "index out of possible range. Model: 'Post', Field Comments")
		}
		return p.Comments[index], nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, p)
	}
	return models, nil
}

// GetRelationLen implements mapping.MultiRelationer interface.
func (p *Post) GetRelationLen(relation *mapping.StructField) (int, error) {
	switch relation.Index[0] {
	case 4: // Comments
		return len(p.Comments), nil
	default:
		return 0, errors.Newf(mapping.ClassInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, p)
	}
}

// Compile time check if ArrModel implements mapping.Model interface.
var _ mapping.Model = &ArrModel{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'ArrModel'.
func (a *ArrModel) NeuronCollectionName() string {
	return "arr_models"
}

// IsPrimaryKeyZero implements mapping.Model interface method.
func (a *ArrModel) IsPrimaryKeyZero() bool {
	return a.ID == 0
}

// GetPrimaryKeyValue implements mapping.Model interface method.
func (a *ArrModel) GetPrimaryKeyValue() interface{} {
	return a.ID
}

// GetPrimaryKeyStringValue implements mapping.Model interface method.
func (a *ArrModel) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(a.ID), 10), nil
}

// GetPrimaryKeyAddress implements mapping.Model interface method.
func (a *ArrModel) GetPrimaryKeyAddress() interface{} {
	return &a.ID
}

// GetPrimaryKeyHashableValue implements mapping.Model interface method.
func (a *ArrModel) GetPrimaryKeyHashableValue() interface{} {
	return a.ID
}

// GetPrimaryKeyZeroValue implements mapping.Model interface method.
func (a *ArrModel) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements mapping.Model interface method.
func (a *ArrModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		a.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		a.ID = int(valueType)
	case int16:
		a.ID = int(valueType)
	case int32:
		a.ID = int(valueType)
	case int64:
		a.ID = int(valueType)
	case uint:
		a.ID = int(valueType)
	case uint8:
		a.ID = int(valueType)
	case uint16:
		a.ID = int(valueType)
	case uint32:
		a.ID = int(valueType)
	case uint64:
		a.ID = int(valueType)
	case float32:
		a.ID = int(valueType)
	case float64:
		a.ID = int(valueType)
	default:
		return errors.Newf(mapping.ClassFieldValue, "provided invalid value: '%T' for the primary field for model: 'ArrModel'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (a *ArrModel) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	if err != nil {
		return err
	}
	a.ID = int(tmp)
	return nil
}

// Compile time check if ArrModel implements mapping.Fielder interface.
var _ mapping.Fielder = &ArrModel{}

// GetFieldsAddress gets the address of provided 'field'.
func (a *ArrModel) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &a.ID, nil
	case 1: // Arr
		return &a.Arr, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: ArrModel'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (a *ArrModel) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // Arr
		return [2]float64{}, nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (a *ArrModel) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return a.ID == 0, nil
	case 1: // Arr
		return a.Arr == [2]float64{}, nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (a *ArrModel) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		a.ID = 0
	case 1: // Arr
		a.Arr = [2]float64{}
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (a *ArrModel) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return a.ID, nil
	case 1: // Arr
		return a.Arr, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'ArrModel'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (a *ArrModel) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return a.ID, nil
	case 1: // Arr
		return a.Arr, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: ArrModel'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (a *ArrModel) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			a.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			a.ID = int(v)
		case int16:
			a.ID = int(v)
		case int32:
			a.ID = int(v)
		case int64:
			a.ID = int(v)
		case uint:
			a.ID = int(v)
		case uint8:
			a.ID = int(v)
		case uint16:
			a.ID = int(v)
		case uint32:
			a.ID = int(v)
		case uint64:
			a.ID = int(v)
		case float32:
			a.ID = int(v)
		case float64:
			a.ID = int(v)
		default:
			return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // Arr
		if v, ok := value.([2]float64); ok {
			a.Arr = v
			return nil
		}
		if generic, ok := value.([]interface{}); ok {
			if len(generic) > 2 {
				return errors.Newf(mapping.ClassFieldValue, "provided too many values for the field: 'Arr")
			}
			for i, item := range generic {
				if v, ok := item.(float64); ok {
					a.Arr[i] = v
					continue
				}
				switch v := item.(type) {
				case float32:
					a.Arr[i] = float64(v)
				case int:
					a.Arr[i] = float64(v)
				case uint:
					a.Arr[i] = float64(v)
				case int64:
					a.Arr[i] = float64(v)
				case uint64:
					a.Arr[i] = float64(v)
				default:
					return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
				}
			}
			return nil
		}
		return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'ArrModel'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (a *ArrModel) ParseFieldsStringValue(field *mapping.StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	case 1: // Arr
		return strconv.ParseFloat(value, 64)
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: ArrModel'", field.Name())
}

// Compile time check if ModelTime implements mapping.Model interface.
var _ mapping.Model = &ModelTime{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'ModelTime'.
func (m *ModelTime) NeuronCollectionName() string {
	return "model_times"
}

// IsPrimaryKeyZero implements mapping.Model interface method.
func (m *ModelTime) IsPrimaryKeyZero() bool {
	return m.ID == 0
}

// GetPrimaryKeyValue implements mapping.Model interface method.
func (m *ModelTime) GetPrimaryKeyValue() interface{} {
	return m.ID
}

// GetPrimaryKeyStringValue implements mapping.Model interface method.
func (m *ModelTime) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(m.ID), 10), nil
}

// GetPrimaryKeyAddress implements mapping.Model interface method.
func (m *ModelTime) GetPrimaryKeyAddress() interface{} {
	return &m.ID
}

// GetPrimaryKeyHashableValue implements mapping.Model interface method.
func (m *ModelTime) GetPrimaryKeyHashableValue() interface{} {
	return m.ID
}

// GetPrimaryKeyZeroValue implements mapping.Model interface method.
func (m *ModelTime) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements mapping.Model interface method.
func (m *ModelTime) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		m.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		m.ID = int(valueType)
	case int16:
		m.ID = int(valueType)
	case int32:
		m.ID = int(valueType)
	case int64:
		m.ID = int(valueType)
	case uint:
		m.ID = int(valueType)
	case uint8:
		m.ID = int(valueType)
	case uint16:
		m.ID = int(valueType)
	case uint32:
		m.ID = int(valueType)
	case uint64:
		m.ID = int(valueType)
	case float32:
		m.ID = int(valueType)
	case float64:
		m.ID = int(valueType)
	default:
		return errors.Newf(mapping.ClassFieldValue, "provided invalid value: '%T' for the primary field for model: 'ModelTime'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (m *ModelTime) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	if err != nil {
		return err
	}
	m.ID = int(tmp)
	return nil
}

// Compile time check if ModelTime implements mapping.Fielder interface.
var _ mapping.Fielder = &ModelTime{}

// GetFieldsAddress gets the address of provided 'field'.
func (m *ModelTime) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &m.ID, nil
	case 1: // Time
		return &m.Time, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: ModelTime'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (m *ModelTime) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // Time
		return time.Time{}, nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (m *ModelTime) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID == 0, nil
	case 1: // Time
		return m.Time == time.Time{}, nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (m *ModelTime) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		m.ID = 0
	case 1: // Time
		m.Time = time.Time{}
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (m *ModelTime) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID, nil
	case 1: // Time
		return m.Time, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'ModelTime'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (m *ModelTime) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID, nil
	case 1: // Time
		return m.Time, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: ModelTime'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (m *ModelTime) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			m.ID = v
			return nil
		}

		switch v := value.(type) {
		case int8:
			m.ID = int(v)
		case int16:
			m.ID = int(v)
		case int32:
			m.ID = int(v)
		case int64:
			m.ID = int(v)
		case uint:
			m.ID = int(v)
		case uint8:
			m.ID = int(v)
		case uint16:
			m.ID = int(v)
		case uint32:
			m.ID = int(v)
		case uint64:
			m.ID = int(v)
		case float32:
			m.ID = int(v)
		case float64:
			m.ID = int(v)
		default:
			return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // Time
		if v, ok := value.(time.Time); ok {
			m.Time = v
			return nil
		}

		return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'ModelTime'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (m *ModelTime) ParseFieldsStringValue(field *mapping.StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	case 1: // Time
		temp := m.Time
		if err := m.Time.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Newf(mapping.ClassFieldValue, "invalid field 'Time' value: '%v' to parse string. Err: %v", m.Time, err)
		}
		bt, err := m.Time.MarshalText()
		if err != nil {
			return "", errors.Newf(mapping.ClassFieldValue, "invalid field 'Time' value: '%v' to parse string. Err: %v", m.Time, err)
		}
		m.Time = temp
		return string(bt), nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: ModelTime'", field.Name())
}
