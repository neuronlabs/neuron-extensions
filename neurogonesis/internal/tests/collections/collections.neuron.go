// Code generated by neuron/generator. DO NOT EDIT.
// This file was generated at:
// Sat, 29 Aug 2020 13:43:45 +0200

package tests

import (
	"context"

	"github.com/neuronlabs/neuron-extensions/neurogonesis/internal/tests"
	"github.com/neuronlabs/neuron-extensions/neurogonesis/internal/tests/external"
	"github.com/neuronlabs/neuron/core"
	"github.com/neuronlabs/neuron/database"
	"github.com/neuronlabs/neuron/errors"
	"github.com/neuronlabs/neuron/mapping"
	"github.com/neuronlabs/neuron/query"
	"github.com/neuronlabs/neuron/query/filter"
)

// Neuron_Collections stores all generated collections.
var Neuron_Collections = []core.Initializer{
	NRN_CustomCars,
	NRN_Users,
}

// NRN_CustomCars is the collection used to query tests.Car model.
var NRN_CustomCars = &_CustomCars{}

type _CustomCars struct {
	Model *mapping.ModelStruct
}

// InitializeCollection implements core.Initializer interface.
func (c *_CustomCars) Initialize(_ctrl *core.Controller) error {
	mStruct, err := _ctrl.ModelStruct(&tests.Car{})
	if err != nil {
		return err
	}
	NRN_CustomCars = &_CustomCars{Model: mStruct}
	return nil
}

// ToModels converts the input slice of tests.Car into []mapping.Model
func (c *_CustomCars) ToModels(input ...*tests.Car) []mapping.Model {
	output := make([]mapping.Model, len(input))
	for i := range input {
		output[i] = input[i]
	}
	return output
}

// FromModels converts the input mapping.Model into []*tests.Car.
func (c *_CustomCars) FromModels(input ...mapping.Model) []*tests.Car {
	output := make([]*tests.Car, len(input))
	for i := range input {
		output[i] = input[i].(*tests.Car)
	}
	return output
}

// Query creates the query for the tests.Car.
func (c *_CustomCars) Query(db database.DB, models ...*tests.Car) *customCarsQueryBuilder {
	var queryModels []mapping.Model
	if len(models) > 0 {
		queryModels = make([]mapping.Model, len(models))
		for i, model := range models {
			queryModels[i] = model
		}
	}
	builder := db.Query(c.Model, queryModels...)
	return &customCarsQueryBuilder{builder: builder}
}

// QueryCtx creates the query for the tests.Car with provided 'ctx' context.
func (c *_CustomCars) QueryCtx(ctx context.Context, db database.DB, models ...*tests.Car) *customCarsQueryBuilder {
	var queryModels []mapping.Model
	if len(models) > 0 {
		queryModels = make([]mapping.Model, len(models))
		for i, model := range models {
			queryModels[i] = model
		}
	}
	builder := db.QueryCtx(ctx, c.Model, queryModels...)
	return &customCarsQueryBuilder{builder: builder}
}

// Insert inserts tests.Car into database.
func (c *_CustomCars) Insert(ctx context.Context, db database.DB, models ...*tests.Car) error {
	if len(models) == 0 {
		return errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Insert(ctx, c.Model, queryModels...)
}

// Update updates tests.Car models into database.
func (c *_CustomCars) Update(ctx context.Context, db database.DB, models ...*tests.Car) (int64, error) {
	if len(models) == 0 {
		return 0, errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Update(ctx, c.Model, queryModels...)
}

// Delete deletes tests.Car models in database.
func (c *_CustomCars) Delete(ctx context.Context, db database.DB, models ...*tests.Car) (int64, error) {
	if len(models) == 0 {
		return 0, errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Delete(ctx, c.Model, queryModels...)
}

// Refresh creates the query for the tests.Car with provided 'ctx' context.
func (c *_CustomCars) Refresh(ctx context.Context, db database.DB, models ...*tests.Car) error {
	var queryModels []mapping.Model
	if len(models) == 0 {
		return errors.Wrap(query.ErrNoModels, "nothing to refresh")
	}
	queryModels = make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Refresh(ctx, c.Model, queryModels...)
}

// customCarsQueryBuilder is the query builder used to create and execute
// queries for the tests.Carmodel.
type customCarsQueryBuilder struct {
	builder database.Builder
	err     error
}

// Scope returns given query scope.
func (c *customCarsQueryBuilder) Scope() *query.Scope {
	return c.builder.Scope()
}

// Err returns errors that occurred during query building process.
func (c *customCarsQueryBuilder) Err() error {
	if c.err != nil {
		return c.err
	}
	return c.builder.Err()
}

// Ctx returns the context of given query builder.
func (c *customCarsQueryBuilder) Ctx() context.Context {
	return c.builder.Ctx()
}

// Count returns the number of model instances for provided query.
func (c *customCarsQueryBuilder) Count() (int64, error) {
	if c.err != nil {
		return 0, c.err
	}
	return c.builder.Count()
}

// Insert new 'tests.Car' instance(s) into the store.
func (c *customCarsQueryBuilder) Insert() error {
	if c.err != nil {
		return c.err
	}
	return c.builder.Insert()
}

// Update updates given 'tests.Car' instances.
func (c *customCarsQueryBuilder) Update() (int64, error) {
	if c.err != nil {
		return 0, c.err
	}
	return c.builder.Update()
}

// Find returns all tests.Car models that matches to given query.
func (c *customCarsQueryBuilder) Find() ([]*tests.Car, error) {
	if c.err != nil {
		return nil, c.err
	}
	queryModels, err := c.builder.Find()
	if err != nil {
		return nil, err
	}
	models := make([]*tests.Car, len(queryModels))
	for i := range queryModels {
		models[i] = queryModels[i].(*tests.Car)
	}
	return models, nil
}

// Refresh refreshes input 'tests.Car' model fields. It might be combine with the included relations.
func (c *customCarsQueryBuilder) Refresh() error {
	if c.err != nil {
		return c.err
	}
	return c.builder.Refresh()
}

// Get returns single tests.Car model that matches given query.
// If the model is not found the function returns error of query.ErrQueryNoResult.
func (c *customCarsQueryBuilder) Get() (*tests.Car, error) {
	if c.err != nil {
		return nil, c.err
	}
	model, err := c.builder.Get()
	if err != nil {
		return nil, err
	}
	return model.(*tests.Car), nil
}

// Delete deletes tests.Car instances that matches given query.
func (c *customCarsQueryBuilder) Delete() (int64, error) {
	if c.err != nil {
		return 0, c.err
	}
	return c.builder.Delete()
}

// Filter adds the 'filter' to the given query.
func (c *customCarsQueryBuilder) Filter(filter filter.Filter) *customCarsQueryBuilder {
	if c.err != nil {
		return c
	}
	c.builder.Filter(filter)
	return c
}

// Where creates query with given 'filter' and 'values'.
func (c *customCarsQueryBuilder) Where(filter string, values ...interface{}) *customCarsQueryBuilder {
	if c.err != nil {
		return c
	}
	c.builder.Where(filter, values...)
	return c
}

// Limit sets the maximum number of objects returned by the Find process,
// Returns error if the given scope has already different type of pagination.
func (c *customCarsQueryBuilder) Limit(limit int64) *customCarsQueryBuilder {
	if c.err != nil {
		return c
	}
	c.builder.Limit(limit)
	return c
}

// Offset sets the query result's offset. It says to skip as many object's from the repository
// before beginning to return the result. 'Offset' 0 is the same as omitting the 'Offset' clause.
// Returns error if the given scope has already different type of pagination.
func (c *customCarsQueryBuilder) Offset(offset int64) *customCarsQueryBuilder {
	if c.err != nil {
		return c
	}
	c.builder.Offset(offset)
	return c
}

// Select adds the fields to the scope's fieldset.
// Allowed fields to select:
//  - ID / id
//  - ID / id
//  - Plates / plates
func (c *customCarsQueryBuilder) Select(fields ...string) *customCarsQueryBuilder {
	if c.err != nil {
		return c
	}
	var fieldSet []*mapping.StructField
	for _, field := range fields {
		structField, ok := NRN_CustomCars.Model.FieldByName(field)
		if !ok {
			c.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not valid for model: '_CustomCars'", field)
			return c
		}
		fieldSet = append(fieldSet, structField)
	}
	c.builder.Select(fieldSet...)
	return c
}

// OrderBy adds the sort fields into query scope. By default field is ordered ascending. In order to sort descending
// add '-' before the field name i.e. '-id'. The order of the fields relates to the significance of the sorting order.
// Allowed fields to sort:
//  - ID
//  - ID
//  - Plates
func (c *customCarsQueryBuilder) OrderBy(fields ...string) *customCarsQueryBuilder {
	if c.err != nil {
		return c
	}
	sortFields := make([]query.Sort, len(fields))
	for i, field := range fields {
		if len(field) == 0 {
			c.err = errors.Wrap(mapping.ErrInvalidModelField, "cannot set sorting order for an empty field for model: '_CustomCars'")
			return c
		}
		var order query.SortOrder
		if field[0] == '-' {
			order = query.DescendingOrder
			field = field[1:]
		}
		structField, ok := NRN_CustomCars.Model.FieldByName(field)
		if !ok {
			c.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not valid for model: '_CustomCars'", field)
			return c
		}
		sortFields[i] = query.SortField{StructField: structField, SortOrder: order}
	}
	c.builder.OrderBy(sortFields...)
	return c
}

// NRN_Users is the collection used to query tests.User model.
var NRN_Users = &_Users{}

type _Users struct {
	Model *mapping.ModelStruct
}

// InitializeCollection implements core.Initializer interface.
func (u *_Users) Initialize(_ctrl *core.Controller) error {
	mStruct, err := _ctrl.ModelStruct(&tests.User{})
	if err != nil {
		return err
	}
	NRN_Users = &_Users{Model: mStruct}
	return nil
}

// ToModels converts the input slice of tests.User into []mapping.Model
func (u *_Users) ToModels(input ...*tests.User) []mapping.Model {
	output := make([]mapping.Model, len(input))
	for i := range input {
		output[i] = input[i]
	}
	return output
}

// FromModels converts the input mapping.Model into []*tests.User.
func (u *_Users) FromModels(input ...mapping.Model) []*tests.User {
	output := make([]*tests.User, len(input))
	for i := range input {
		output[i] = input[i].(*tests.User)
	}
	return output
}

// Query creates the query for the tests.User.
func (u *_Users) Query(db database.DB, models ...*tests.User) *usersQueryBuilder {
	var queryModels []mapping.Model
	if len(models) > 0 {
		queryModels = make([]mapping.Model, len(models))
		for i, model := range models {
			queryModels[i] = model
		}
	}
	builder := db.Query(u.Model, queryModels...)
	return &usersQueryBuilder{builder: builder}
}

// QueryCtx creates the query for the tests.User with provided 'ctx' context.
func (u *_Users) QueryCtx(ctx context.Context, db database.DB, models ...*tests.User) *usersQueryBuilder {
	var queryModels []mapping.Model
	if len(models) > 0 {
		queryModels = make([]mapping.Model, len(models))
		for i, model := range models {
			queryModels[i] = model
		}
	}
	builder := db.QueryCtx(ctx, u.Model, queryModels...)
	return &usersQueryBuilder{builder: builder}
}

// Insert inserts tests.User into database.
func (u *_Users) Insert(ctx context.Context, db database.DB, models ...*tests.User) error {
	if len(models) == 0 {
		return errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Insert(ctx, u.Model, queryModels...)
}

// Update updates tests.User models into database.
func (u *_Users) Update(ctx context.Context, db database.DB, models ...*tests.User) (int64, error) {
	if len(models) == 0 {
		return 0, errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Update(ctx, u.Model, queryModels...)
}

// Delete deletes tests.User models in database.
func (u *_Users) Delete(ctx context.Context, db database.DB, models ...*tests.User) (int64, error) {
	if len(models) == 0 {
		return 0, errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Delete(ctx, u.Model, queryModels...)
}

// Refresh creates the query for the tests.User with provided 'ctx' context.
func (u *_Users) Refresh(ctx context.Context, db database.DB, models ...*tests.User) error {
	var queryModels []mapping.Model
	if len(models) == 0 {
		return errors.Wrap(query.ErrNoModels, "nothing to refresh")
	}
	queryModels = make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Refresh(ctx, u.Model, queryModels...)
}

// ClearFavoriteCarRelation clears the 'FavoriteCar' relationship for provided models. For relationships of type:
// BelongsTo, HasOne, HasMany if foreign key is not nullable than the function would return an error.
func (u *_Users) ClearFavoriteCarRelation(ctx context.Context, db database.DB, models ...*tests.User) (int64, error) {
	relation, err := u.Model.RelationByIndex(11)
	if err != nil {
		return 0, err
	}
	modelInterfaces := make([]mapping.Model, len(models))
	for i := range models {
		modelInterfaces[i] = models[i]
	}
	s := query.NewScope(u.Model, modelInterfaces...)
	relationClearer, ok := db.(database.QueryRelationClearer)
	if !ok {
		return 0, errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
	}
	return relationClearer.QueryClearRelations(ctx, s, relation)
}

// GetFavoriteCar gets the 'FavoriteCar' relationship for provided input 'model'.
func (u *_Users) GetFavoriteCar(ctx context.Context, db database.DB, model *tests.User, relationFieldset ...string) (*tests.Car, error) {
	if model == nil {
		return nil, errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return nil, errors.Wrap(mapping.ErrFieldValue, "model's: 'tests.User' primary key value has zero value")
	}
	relationField, err := u.Model.RelationByIndex(11)
	if err != nil {
		return nil, err
	}

	var fields []*mapping.StructField
	relationModel := relationField.Relationship().RelatedModelStruct()
	if len(relationFieldset) == 0 {
		fields = relationModel.Fields()
	} else {
		for _, field := range relationFieldset {
			sField, ok := relationModel.FieldByName(field)
			if !ok {
				return nil, errors.Wrapf(mapping.ErrInvalidModelField, "no field: '%s' found for the model: 'tests.Car'", field)
			}
			fields = append(fields, sField)
		}
	}

	relations, err := db.GetRelations(ctx, u.Model, []mapping.Model{model}, relationField, fields...)
	if err != nil {
		return nil, err
	}
	if len(relations) == 0 {
		return nil, nil
	}
	return relations[0].(*tests.Car), nil
}

// SetFavoriteCar sets the 'FavoriteCar' relationship for provided input 'models'.
func (u *_Users) SetFavoriteCar(ctx context.Context, db database.DB, model *tests.User, relation *tests.Car) error {
	if model == nil {
		return errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return errors.Wrap(mapping.ErrFieldValue, "model's: 'tests.User' primary key value has zero value")
	}
	relationField, err := u.Model.RelationByIndex(11)
	if err != nil {
		return err
	}
	q := query.NewScope(u.Model, model)
	if relation.IsPrimaryKeyZero() {
		return errors.Wrap(mapping.ErrFieldValue, "relation 'FavoriteCar' model has zero value primary field")
	}
	relationSetter, ok := db.(database.QueryRelationSetter)
	if !ok {
		return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationSetter interface: %T", db)
	}
	return relationSetter.QuerySetRelations(ctx, q, relationField, relation)
}

// AddCars adds the 'Cars' relationship for provided input 'models'.
func (u *_Users) AddCars(ctx context.Context, db database.DB, model *tests.User, relations ...*tests.Car) error {
	if model == nil {
		return errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	if len(relations) == 0 {
		return errors.Wrap(query.ErrNoModels, "no relation models provided")
	}
	relationField, err := u.Model.RelationByIndex(14)
	if err != nil {
		return err
	}
	relationModels := make([]mapping.Model, len(relations))
	for i := range relations {
		relationModels[i] = relations[i]
	}
	q := query.NewScope(u.Model, model)
	relationAdder, ok := db.(database.QueryRelationAdder)
	if !ok {
		return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
	}
	return relationAdder.QueryAddRelations(ctx, q, relationField, relationModels...)
}

// ClearCarsRelation clears the 'Cars' relationship for provided models. For relationships of type:
// BelongsTo, HasOne, HasMany if foreign key is not nullable than the function would return an error.
func (u *_Users) ClearCarsRelation(ctx context.Context, db database.DB, models ...*tests.User) (int64, error) {
	relation, err := u.Model.RelationByIndex(14)
	if err != nil {
		return 0, err
	}
	modelInterfaces := make([]mapping.Model, len(models))
	for i := range models {
		modelInterfaces[i] = models[i]
	}
	s := query.NewScope(u.Model, modelInterfaces...)
	relationClearer, ok := db.(database.QueryRelationClearer)
	if !ok {
		return 0, errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
	}
	return relationClearer.QueryClearRelations(ctx, s, relation)
}

// GetCars gets the 'Cars' relationship for provided input 'model'.
func (u *_Users) GetCars(ctx context.Context, db database.DB, model *tests.User, relationFieldset ...string) ([]*tests.Car, error) {
	if model == nil {
		return nil, errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return nil, errors.Wrap(mapping.ErrFieldValue, "model's: 'tests.User' primary key value has zero value")
	}
	relationField, err := u.Model.RelationByIndex(14)
	if err != nil {
		return nil, err
	}

	var fields []*mapping.StructField
	relationModel := relationField.Relationship().RelatedModelStruct()
	if len(relationFieldset) == 0 {
		fields = relationModel.Fields()
	} else {
		for _, field := range relationFieldset {
			sField, ok := relationModel.FieldByName(field)
			if !ok {
				return nil, errors.Wrapf(mapping.ErrInvalidModelField, "no field: '%s' found for the model: 'tests.Car'", field)
			}
			fields = append(fields, sField)
		}
	}

	relations, err := db.GetRelations(ctx, u.Model, []mapping.Model{model}, relationField, fields...)
	if err != nil {
		return nil, err
	}
	if len(relations) == 0 {
		return []*tests.Car{}, nil
	}
	result := make([]*tests.Car, len(relations))
	for i, relation := range relations {
		result[i] = relation.(*tests.Car)
	}
	return result, nil
}

// SetCars sets the 'Cars' relationship for provided input 'models'.
func (u *_Users) SetCars(ctx context.Context, db database.DB, model *tests.User, relations ...*tests.Car) error {
	if model == nil {
		return errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return errors.Wrap(mapping.ErrFieldValue, "model's: 'tests.User' primary key value has zero value")
	}
	relationField, err := u.Model.RelationByIndex(14)
	if err != nil {
		return err
	}
	q := query.NewScope(u.Model, model)
	if len(relations) == 0 {
		return errors.Wrap(query.ErrNoModels, "no relation models provided")
	}
	relationModels := make([]mapping.Model, len(relations))
	for i, relation := range relations {
		if relation.IsPrimaryKeyZero() {
			return errors.Wrap(mapping.ErrFieldValue, "one of relation 'Cars' model has zero value primary field")
		}
		relationModels[i] = relation
	}
	relationSetter, ok := db.(database.QueryRelationSetter)
	if !ok {
		return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationSetter interface: %T", db)
	}
	return relationSetter.QuerySetRelations(ctx, q, relationField, relationModels...)
}

// AddSons adds the 'Sons' relationship for provided input 'models'.
func (u *_Users) AddSons(ctx context.Context, db database.DB, model *tests.User, relations ...*tests.User) error {
	if model == nil {
		return errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	if len(relations) == 0 {
		return errors.Wrap(query.ErrNoModels, "no relation models provided")
	}
	relationField, err := u.Model.RelationByIndex(15)
	if err != nil {
		return err
	}
	relationModels := make([]mapping.Model, len(relations))
	for i := range relations {
		relationModels[i] = relations[i]
	}
	q := query.NewScope(u.Model, model)
	relationAdder, ok := db.(database.QueryRelationAdder)
	if !ok {
		return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
	}
	return relationAdder.QueryAddRelations(ctx, q, relationField, relationModels...)
}

// ClearSonsRelation clears the 'Sons' relationship for provided models. For relationships of type:
// BelongsTo, HasOne, HasMany if foreign key is not nullable than the function would return an error.
func (u *_Users) ClearSonsRelation(ctx context.Context, db database.DB, models ...*tests.User) (int64, error) {
	relation, err := u.Model.RelationByIndex(15)
	if err != nil {
		return 0, err
	}
	modelInterfaces := make([]mapping.Model, len(models))
	for i := range models {
		modelInterfaces[i] = models[i]
	}
	s := query.NewScope(u.Model, modelInterfaces...)
	relationClearer, ok := db.(database.QueryRelationClearer)
	if !ok {
		return 0, errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
	}
	return relationClearer.QueryClearRelations(ctx, s, relation)
}

// GetSons gets the 'Sons' relationship for provided input 'model'.
func (u *_Users) GetSons(ctx context.Context, db database.DB, model *tests.User, relationFieldset ...string) ([]*tests.User, error) {
	if model == nil {
		return nil, errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return nil, errors.Wrap(mapping.ErrFieldValue, "model's: 'tests.User' primary key value has zero value")
	}
	relationField, err := u.Model.RelationByIndex(15)
	if err != nil {
		return nil, err
	}

	var fields []*mapping.StructField
	relationModel := relationField.Relationship().RelatedModelStruct()
	if len(relationFieldset) == 0 {
		fields = relationModel.Fields()
	} else {
		for _, field := range relationFieldset {
			sField, ok := relationModel.FieldByName(field)
			if !ok {
				return nil, errors.Wrapf(mapping.ErrInvalidModelField, "no field: '%s' found for the model: 'tests.User'", field)
			}
			fields = append(fields, sField)
		}
	}

	relations, err := db.GetRelations(ctx, u.Model, []mapping.Model{model}, relationField, fields...)
	if err != nil {
		return nil, err
	}
	if len(relations) == 0 {
		return []*tests.User{}, nil
	}
	result := make([]*tests.User, len(relations))
	for i, relation := range relations {
		result[i] = relation.(*tests.User)
	}
	return result, nil
}

// SetSons sets the 'Sons' relationship for provided input 'models'.
func (u *_Users) SetSons(ctx context.Context, db database.DB, model *tests.User, relations ...*tests.User) error {
	if model == nil {
		return errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return errors.Wrap(mapping.ErrFieldValue, "model's: 'tests.User' primary key value has zero value")
	}
	relationField, err := u.Model.RelationByIndex(15)
	if err != nil {
		return err
	}
	q := query.NewScope(u.Model, model)
	if len(relations) == 0 {
		return errors.Wrap(query.ErrNoModels, "no relation models provided")
	}
	relationModels := make([]mapping.Model, len(relations))
	for i, relation := range relations {
		if relation.IsPrimaryKeyZero() {
			return errors.Wrap(mapping.ErrFieldValue, "one of relation 'Sons' model has zero value primary field")
		}
		relationModels[i] = relation
	}
	relationSetter, ok := db.(database.QueryRelationSetter)
	if !ok {
		return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationSetter interface: %T", db)
	}
	return relationSetter.QuerySetRelations(ctx, q, relationField, relationModels...)
}

// ClearSisterRelation clears the 'Sister' relationship for provided models. For relationships of type:
// BelongsTo, HasOne, HasMany if foreign key is not nullable than the function would return an error.
func (u *_Users) ClearSisterRelation(ctx context.Context, db database.DB, models ...*tests.User) (int64, error) {
	relation, err := u.Model.RelationByIndex(16)
	if err != nil {
		return 0, err
	}
	modelInterfaces := make([]mapping.Model, len(models))
	for i := range models {
		modelInterfaces[i] = models[i]
	}
	s := query.NewScope(u.Model, modelInterfaces...)
	relationClearer, ok := db.(database.QueryRelationClearer)
	if !ok {
		return 0, errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
	}
	return relationClearer.QueryClearRelations(ctx, s, relation)
}

// GetSister gets the 'Sister' relationship for provided input 'model'.
func (u *_Users) GetSister(ctx context.Context, db database.DB, model *tests.User, relationFieldset ...string) (*tests.User, error) {
	if model == nil {
		return nil, errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return nil, errors.Wrap(mapping.ErrFieldValue, "model's: 'tests.User' primary key value has zero value")
	}
	relationField, err := u.Model.RelationByIndex(16)
	if err != nil {
		return nil, err
	}

	var fields []*mapping.StructField
	relationModel := relationField.Relationship().RelatedModelStruct()
	if len(relationFieldset) == 0 {
		fields = relationModel.Fields()
	} else {
		for _, field := range relationFieldset {
			sField, ok := relationModel.FieldByName(field)
			if !ok {
				return nil, errors.Wrapf(mapping.ErrInvalidModelField, "no field: '%s' found for the model: 'tests.User'", field)
			}
			fields = append(fields, sField)
		}
	}

	relations, err := db.GetRelations(ctx, u.Model, []mapping.Model{model}, relationField, fields...)
	if err != nil {
		return nil, err
	}
	if len(relations) == 0 {
		return nil, nil
	}
	return relations[0].(*tests.User), nil
}

// SetSister sets the 'Sister' relationship for provided input 'models'.
func (u *_Users) SetSister(ctx context.Context, db database.DB, model *tests.User, relation *tests.User) error {
	if model == nil {
		return errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return errors.Wrap(mapping.ErrFieldValue, "model's: 'tests.User' primary key value has zero value")
	}
	relationField, err := u.Model.RelationByIndex(16)
	if err != nil {
		return err
	}
	q := query.NewScope(u.Model, model)
	if relation.IsPrimaryKeyZero() {
		return errors.Wrap(mapping.ErrFieldValue, "relation 'Sister' model has zero value primary field")
	}
	relationSetter, ok := db.(database.QueryRelationSetter)
	if !ok {
		return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationSetter interface: %T", db)
	}
	return relationSetter.QuerySetRelations(ctx, q, relationField, relation)
}

// ClearExternalRelation clears the 'External' relationship for provided models. For relationships of type:
// BelongsTo, HasOne, HasMany if foreign key is not nullable than the function would return an error.
func (u *_Users) ClearExternalRelation(ctx context.Context, db database.DB, models ...*tests.User) (int64, error) {
	relation, err := u.Model.RelationByIndex(10)
	if err != nil {
		return 0, err
	}
	modelInterfaces := make([]mapping.Model, len(models))
	for i := range models {
		modelInterfaces[i] = models[i]
	}
	s := query.NewScope(u.Model, modelInterfaces...)
	relationClearer, ok := db.(database.QueryRelationClearer)
	if !ok {
		return 0, errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
	}
	return relationClearer.QueryClearRelations(ctx, s, relation)
}

// GetExternal gets the 'External' relationship for provided input 'model'.
func (u *_Users) GetExternal(ctx context.Context, db database.DB, model *tests.User, relationFieldset ...string) (*external.Model, error) {
	if model == nil {
		return nil, errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return nil, errors.Wrap(mapping.ErrFieldValue, "model's: 'tests.User' primary key value has zero value")
	}
	relationField, err := u.Model.RelationByIndex(10)
	if err != nil {
		return nil, err
	}

	var fields []*mapping.StructField
	relationModel := relationField.Relationship().RelatedModelStruct()
	if len(relationFieldset) == 0 {
		fields = relationModel.Fields()
	} else {
		for _, field := range relationFieldset {
			sField, ok := relationModel.FieldByName(field)
			if !ok {
				return nil, errors.Wrapf(mapping.ErrInvalidModelField, "no field: '%s' found for the model: 'external.Model'", field)
			}
			fields = append(fields, sField)
		}
	}

	relations, err := db.GetRelations(ctx, u.Model, []mapping.Model{model}, relationField, fields...)
	if err != nil {
		return nil, err
	}
	if len(relations) == 0 {
		return nil, nil
	}
	return relations[0].(*external.Model), nil
}

// SetExternal sets the 'External' relationship for provided input 'models'.
func (u *_Users) SetExternal(ctx context.Context, db database.DB, model *tests.User, relation *external.Model) error {
	if model == nil {
		return errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return errors.Wrap(mapping.ErrFieldValue, "model's: 'tests.User' primary key value has zero value")
	}
	relationField, err := u.Model.RelationByIndex(10)
	if err != nil {
		return err
	}
	q := query.NewScope(u.Model, model)
	if relation.IsPrimaryKeyZero() {
		return errors.Wrap(mapping.ErrFieldValue, "relation 'External' model has zero value primary field")
	}
	relationSetter, ok := db.(database.QueryRelationSetter)
	if !ok {
		return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationSetter interface: %T", db)
	}
	return relationSetter.QuerySetRelations(ctx, q, relationField, relation)
}

// usersQueryBuilder is the query builder used to create and execute
// queries for the tests.Usermodel.
type usersQueryBuilder struct {
	builder database.Builder
	err     error
}

// Scope returns given query scope.
func (u *usersQueryBuilder) Scope() *query.Scope {
	return u.builder.Scope()
}

// Err returns errors that occurred during query building process.
func (u *usersQueryBuilder) Err() error {
	if u.err != nil {
		return u.err
	}
	return u.builder.Err()
}

// Ctx returns the context of given query builder.
func (u *usersQueryBuilder) Ctx() context.Context {
	return u.builder.Ctx()
}

// Count returns the number of model instances for provided query.
func (u *usersQueryBuilder) Count() (int64, error) {
	if u.err != nil {
		return 0, u.err
	}
	return u.builder.Count()
}

// Insert new 'tests.User' instance(s) into the store.
func (u *usersQueryBuilder) Insert() error {
	if u.err != nil {
		return u.err
	}
	return u.builder.Insert()
}

// Update updates given 'tests.User' instances.
func (u *usersQueryBuilder) Update() (int64, error) {
	if u.err != nil {
		return 0, u.err
	}
	return u.builder.Update()
}

// Find returns all tests.User models that matches to given query.
func (u *usersQueryBuilder) Find() ([]*tests.User, error) {
	if u.err != nil {
		return nil, u.err
	}
	queryModels, err := u.builder.Find()
	if err != nil {
		return nil, err
	}
	models := make([]*tests.User, len(queryModels))
	for i := range queryModels {
		models[i] = queryModels[i].(*tests.User)
	}
	return models, nil
}

// Refresh refreshes input 'tests.User' model fields. It might be combine with the included relations.
func (u *usersQueryBuilder) Refresh() error {
	if u.err != nil {
		return u.err
	}
	return u.builder.Refresh()
}

// Get returns single tests.User model that matches given query.
// If the model is not found the function returns error of query.ErrQueryNoResult.
func (u *usersQueryBuilder) Get() (*tests.User, error) {
	if u.err != nil {
		return nil, u.err
	}
	model, err := u.builder.Get()
	if err != nil {
		return nil, err
	}
	return model.(*tests.User), nil
}

// Delete deletes tests.User instances that matches given query.
func (u *usersQueryBuilder) Delete() (int64, error) {
	if u.err != nil {
		return 0, u.err
	}
	return u.builder.Delete()
}

// Filter adds the 'filter' to the given query.
func (u *usersQueryBuilder) Filter(filter filter.Filter) *usersQueryBuilder {
	if u.err != nil {
		return u
	}
	u.builder.Filter(filter)
	return u
}

// Where creates query with given 'filter' and 'values'.
func (u *usersQueryBuilder) Where(filter string, values ...interface{}) *usersQueryBuilder {
	if u.err != nil {
		return u
	}
	u.builder.Where(filter, values...)
	return u
}

// IncludeFavoriteCar includes given 'relation' in the _Users query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (u *usersQueryBuilder) IncludeFavoriteCar(favoriteCarFieldset ...string) *usersQueryBuilder {
	if u.err != nil {
		return u
	}
	relation, err := NRN_Users.Model.RelationByIndex(11)
	if err != nil {
		u.err = errors.Wrapf(mapping.ErrInternal, "Getting 'FavoriteCar' by index for model 'tests.User' failed: %v", err)
		return u
	}
	// check the fieldset for the relation.
	var relationFields []*mapping.StructField
	for _, field := range favoriteCarFieldset {
		structField, ok := relation.ModelStruct().FieldByName(field)
		if !ok {
			u.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not found for the 'tests.Car' model", field)
			return u
		}
		relationFields = append(relationFields, structField)
	}
	u.builder.Include(relation, relationFields...)
	return u
}

// IncludeCars includes given 'relation' in the _Users query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (u *usersQueryBuilder) IncludeCars(carsFieldset ...string) *usersQueryBuilder {
	if u.err != nil {
		return u
	}
	relation, err := NRN_Users.Model.RelationByIndex(14)
	if err != nil {
		u.err = errors.Wrapf(mapping.ErrInternal, "Getting 'Cars' by index for model 'tests.User' failed: %v", err)
		return u
	}
	// check the fieldset for the relation.
	var relationFields []*mapping.StructField
	for _, field := range carsFieldset {
		structField, ok := relation.ModelStruct().FieldByName(field)
		if !ok {
			u.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not found for the 'tests.Car' model", field)
			return u
		}
		relationFields = append(relationFields, structField)
	}
	u.builder.Include(relation, relationFields...)
	return u
}

// IncludeSons includes given 'relation' in the _Users query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (u *usersQueryBuilder) IncludeSons(sonsFieldset ...string) *usersQueryBuilder {
	if u.err != nil {
		return u
	}
	relation, err := NRN_Users.Model.RelationByIndex(15)
	if err != nil {
		u.err = errors.Wrapf(mapping.ErrInternal, "Getting 'Sons' by index for model 'tests.User' failed: %v", err)
		return u
	}
	// check the fieldset for the relation.
	var relationFields []*mapping.StructField
	for _, field := range sonsFieldset {
		structField, ok := relation.ModelStruct().FieldByName(field)
		if !ok {
			u.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not found for the 'tests.User' model", field)
			return u
		}
		relationFields = append(relationFields, structField)
	}
	u.builder.Include(relation, relationFields...)
	return u
}

// IncludeSister includes given 'relation' in the _Users query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (u *usersQueryBuilder) IncludeSister(sisterFieldset ...string) *usersQueryBuilder {
	if u.err != nil {
		return u
	}
	relation, err := NRN_Users.Model.RelationByIndex(16)
	if err != nil {
		u.err = errors.Wrapf(mapping.ErrInternal, "Getting 'Sister' by index for model 'tests.User' failed: %v", err)
		return u
	}
	// check the fieldset for the relation.
	var relationFields []*mapping.StructField
	for _, field := range sisterFieldset {
		structField, ok := relation.ModelStruct().FieldByName(field)
		if !ok {
			u.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not found for the 'tests.User' model", field)
			return u
		}
		relationFields = append(relationFields, structField)
	}
	u.builder.Include(relation, relationFields...)
	return u
}

// IncludeExternal includes given 'relation' in the _Users query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (u *usersQueryBuilder) IncludeExternal(externalFieldset ...string) *usersQueryBuilder {
	if u.err != nil {
		return u
	}
	relation, err := NRN_Users.Model.RelationByIndex(10)
	if err != nil {
		u.err = errors.Wrapf(mapping.ErrInternal, "Getting 'External' by index for model 'tests.User' failed: %v", err)
		return u
	}
	// check the fieldset for the relation.
	var relationFields []*mapping.StructField
	for _, field := range externalFieldset {
		structField, ok := relation.ModelStruct().FieldByName(field)
		if !ok {
			u.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not found for the 'external.Model' model", field)
			return u
		}
		relationFields = append(relationFields, structField)
	}
	u.builder.Include(relation, relationFields...)
	return u
}

// Limit sets the maximum number of objects returned by the Find process,
// Returns error if the given scope has already different type of pagination.
func (u *usersQueryBuilder) Limit(limit int64) *usersQueryBuilder {
	if u.err != nil {
		return u
	}
	u.builder.Limit(limit)
	return u
}

// Offset sets the query result's offset. It says to skip as many object's from the repository
// before beginning to return the result. 'Offset' 0 is the same as omitting the 'Offset' clause.
// Returns error if the given scope has already different type of pagination.
func (u *usersQueryBuilder) Offset(offset int64) *usersQueryBuilder {
	if u.err != nil {
		return u
	}
	u.builder.Offset(offset)
	return u
}

// Select adds the fields to the scope's fieldset.
// Allowed fields to select:
//  - ID / id
//  - ID / id
//  - CreatedAt / created_at
//  - DeletedAt / deleted_at
//  - Name / name
//  - Age / age
//  - IntArray / int_array
//  - Bytes / bytes
//  - PtrBytes / ptr_bytes
//  - Wrapped / wrapped
//  - PtrWrapped / ptr_wrapped
//  - FavoriteCarID / favorite_car_id
//  - SisterID / sister_id
func (u *usersQueryBuilder) Select(fields ...string) *usersQueryBuilder {
	if u.err != nil {
		return u
	}
	var fieldSet []*mapping.StructField
	for _, field := range fields {
		structField, ok := NRN_Users.Model.FieldByName(field)
		if !ok {
			u.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not valid for model: '_Users'", field)
			return u
		}
		fieldSet = append(fieldSet, structField)
	}
	u.builder.Select(fieldSet...)
	return u
}

// OrderBy adds the sort fields into query scope. By default field is ordered ascending. In order to sort descending
// add '-' before the field name i.e. '-id'. The order of the fields relates to the significance of the sorting order.
// Allowed fields to sort:
//  - ID
//  - ID
//  - CreatedAt
//  - DeletedAt
//  - Name
//  - Age
//  - IntArray
//  - Bytes
//  - PtrBytes
//  - Wrapped
//  - PtrWrapped
//  - FavoriteCarID
//  - SisterID
func (u *usersQueryBuilder) OrderBy(fields ...string) *usersQueryBuilder {
	if u.err != nil {
		return u
	}
	sortFields := make([]query.Sort, len(fields))
	for i, field := range fields {
		if len(field) == 0 {
			u.err = errors.Wrap(mapping.ErrInvalidModelField, "cannot set sorting order for an empty field for model: '_Users'")
			return u
		}
		var order query.SortOrder
		if field[0] == '-' {
			order = query.DescendingOrder
			field = field[1:]
		}
		structField, ok := NRN_Users.Model.FieldByName(field)
		if !ok {
			u.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not valid for model: '_Users'", field)
			return u
		}
		sortFields[i] = query.SortField{StructField: structField, SortOrder: order}
	}
	u.builder.OrderBy(sortFields...)
	return u
}

// AddFavoriteCar adds related model FavoriteCar and matches to given tests.User.
func (u *usersQueryBuilder) AddFavoriteCar(_favoriteCar *tests.Car) error {
	if u.err != nil {
		return u.err
	}
	relation, err := NRN_Users.Model.RelationByIndex(11)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'FavoriteCar' relation by index for model 'tests.User' failed: %v", err)
	}
	return u.builder.AddRelations(relation, _favoriteCar)
}

// AddCars adds related model Cars and matches to given tests.User.
func (u *usersQueryBuilder) AddCars(_cars ...*tests.Car) error {
	if u.err != nil {
		return u.err
	}
	relation, err := NRN_Users.Model.RelationByIndex(14)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'Cars' relation by index for model 'tests.User' failed: %v", err)
	}
	models := make([]mapping.Model, len(_cars))
	for i := range _cars {
		models[i] = _cars[i]
	}
	return u.builder.AddRelations(relation, models...)
}

// AddSons adds related model Sons and matches to given tests.User.
func (u *usersQueryBuilder) AddSons(_sons ...*tests.User) error {
	if u.err != nil {
		return u.err
	}
	relation, err := NRN_Users.Model.RelationByIndex(15)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'Sons' relation by index for model 'tests.User' failed: %v", err)
	}
	models := make([]mapping.Model, len(_sons))
	for i := range _sons {
		models[i] = _sons[i]
	}
	return u.builder.AddRelations(relation, models...)
}

// AddSister adds related model Sister and matches to given tests.User.
func (u *usersQueryBuilder) AddSister(_sister *tests.User) error {
	if u.err != nil {
		return u.err
	}
	relation, err := NRN_Users.Model.RelationByIndex(16)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'Sister' relation by index for model 'tests.User' failed: %v", err)
	}
	return u.builder.AddRelations(relation, _sister)
}

// AddExternal adds related model External and matches to given tests.User.
func (u *usersQueryBuilder) AddExternal(_external *external.Model) error {
	if u.err != nil {
		return u.err
	}
	relation, err := NRN_Users.Model.RelationByIndex(10)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'External' relation by index for model 'tests.User' failed: %v", err)
	}
	return u.builder.AddRelations(relation, _external)
}

// SetFavoriteCar sets related model FavoriteCar and matches to given tests.User.
func (u *usersQueryBuilder) SetFavoriteCar(_favoriteCar *tests.Car) error {
	if u.err != nil {
		return u.err
	}
	relation, err := NRN_Users.Model.RelationByIndex(11)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'FavoriteCar' relation by index for model 'tests.User' failed: %v", err)
	}
	return u.builder.SetRelations(relation, _favoriteCar)
}

// SetCars sets related model Cars and matches to given tests.User.
func (u *usersQueryBuilder) SetCars(_cars ...*tests.Car) error {
	if u.err != nil {
		return u.err
	}
	relation, err := NRN_Users.Model.RelationByIndex(14)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'Cars' relation by index for model 'tests.User' failed: %v", err)
	}
	models := make([]mapping.Model, len(_cars))
	for i := range _cars {
		models[i] = _cars[i]
	}
	return u.builder.SetRelations(relation, models...)
}

// SetSons sets related model Sons and matches to given tests.User.
func (u *usersQueryBuilder) SetSons(_sons ...*tests.User) error {
	if u.err != nil {
		return u.err
	}
	relation, err := NRN_Users.Model.RelationByIndex(15)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'Sons' relation by index for model 'tests.User' failed: %v", err)
	}
	models := make([]mapping.Model, len(_sons))
	for i := range _sons {
		models[i] = _sons[i]
	}
	return u.builder.SetRelations(relation, models...)
}

// SetSister sets related model Sister and matches to given tests.User.
func (u *usersQueryBuilder) SetSister(_sister *tests.User) error {
	if u.err != nil {
		return u.err
	}
	relation, err := NRN_Users.Model.RelationByIndex(16)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'Sister' relation by index for model 'tests.User' failed: %v", err)
	}
	return u.builder.SetRelations(relation, _sister)
}

// SetExternal sets related model External and matches to given tests.User.
func (u *usersQueryBuilder) SetExternal(_external *external.Model) error {
	if u.err != nil {
		return u.err
	}
	relation, err := NRN_Users.Model.RelationByIndex(10)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'External' relation by index for model 'tests.User' failed: %v", err)
	}
	return u.builder.SetRelations(relation, _external)
}

// RemoveFavoriteCar removes related model FavoriteCar and matches to given tests.User.
func (u *usersQueryBuilder) RemoveFavoriteCar() (int64, error) {
	if u.err != nil {
		return 0, u.err
	}
	relation, err := NRN_Users.Model.RelationByIndex(11)
	if err != nil {
		return 0, errors.Wrapf(mapping.ErrInternal, "getting 'FavoriteCar' relation by index for model 'tests.User' failed: %v", err)
	}
	return u.builder.RemoveRelations(relation)
}

// RemoveCars removes related model Cars and matches to given tests.User.
func (u *usersQueryBuilder) RemoveCars() (int64, error) {
	if u.err != nil {
		return 0, u.err
	}
	relation, err := NRN_Users.Model.RelationByIndex(14)
	if err != nil {
		return 0, errors.Wrapf(mapping.ErrInternal, "getting 'Cars' relation by index for model 'tests.User' failed: %v", err)
	}
	return u.builder.RemoveRelations(relation)
}

// RemoveSons removes related model Sons and matches to given tests.User.
func (u *usersQueryBuilder) RemoveSons() (int64, error) {
	if u.err != nil {
		return 0, u.err
	}
	relation, err := NRN_Users.Model.RelationByIndex(15)
	if err != nil {
		return 0, errors.Wrapf(mapping.ErrInternal, "getting 'Sons' relation by index for model 'tests.User' failed: %v", err)
	}
	return u.builder.RemoveRelations(relation)
}

// RemoveSister removes related model Sister and matches to given tests.User.
func (u *usersQueryBuilder) RemoveSister() (int64, error) {
	if u.err != nil {
		return 0, u.err
	}
	relation, err := NRN_Users.Model.RelationByIndex(16)
	if err != nil {
		return 0, errors.Wrapf(mapping.ErrInternal, "getting 'Sister' relation by index for model 'tests.User' failed: %v", err)
	}
	return u.builder.RemoveRelations(relation)
}

// RemoveExternal removes related model External and matches to given tests.User.
func (u *usersQueryBuilder) RemoveExternal() (int64, error) {
	if u.err != nil {
		return 0, u.err
	}
	relation, err := NRN_Users.Model.RelationByIndex(10)
	if err != nil {
		return 0, errors.Wrapf(mapping.ErrInternal, "getting 'External' relation by index for model 'tests.User' failed: %v", err)
	}
	return u.builder.RemoveRelations(relation)
}
