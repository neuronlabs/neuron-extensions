// Code generated by neurogonesis. DO NOT EDIT.
// This file was generated at:
// Tue, 01 Sep 2020 14:56:52 +0200

package usercollection

import (
    "context"
    "github.com/neuronlabs/neuron/database"
    "github.com/neuronlabs/neuron/errors"
    "github.com/neuronlabs/neuron/mapping"
    "github.com/neuronlabs/neuron/query"
    "github.com/neuronlabs/neuron/query/filter"
    "github.com/neuronlabs/neuron-extensions/neurogonesis/internal/tests"
    "github.com/neuronlabs/neuron-extensions/neurogonesis/internal/tests/external"
)

var _mStruct *mapping.ModelStruct

func modelStruct(_db database.DB) (*mapping.ModelStruct, error) {
    if _mStruct != nil {
        return _mStruct, nil
    }
    mStruct, err := _db.Controller().ModelStruct(&tests.User{})
    if err != nil {
        return nil, err
    }
    _mStruct = mStruct
    return mStruct, nil
}

// ToModels converts the input slice of tests.User into []mapping.Model
func ToModels(input ...*tests.User) ([]mapping.Model) {
    output := make([]mapping.Model, len(input))
    for i := range input {
        output[i] = input[i]
    }
    return output
}

// FromModels converts the input mapping.Model into []*tests.User.
func FromModels(input ...mapping.Model) ([]*tests.User) {
    output := make([]*tests.User, len(input))
    for i := range input {
        output[i] = input[i].(*tests.User)
    }
    return output
}

// Query creates the query for the tests.User.
func Query(db database.DB, models ...*tests.User) *_usersQueryBuilder {
    var queryModels []mapping.Model
    if len(models) > 0 {
        queryModels = make([]mapping.Model, len(models))
        for i, model := range models {
            queryModels[i] = model
        }
    }
    mStruct, err := modelStruct(db)
    builder := db.Query(mStruct, queryModels ...)
    return &_usersQueryBuilder{builder: builder, err: err}
}

// QueryCtx creates the query for the tests.User with provided 'ctx' context.
func QueryCtx(ctx context.Context, db database.DB, models ...*tests.User) *_usersQueryBuilder {
    var queryModels []mapping.Model
    if len(models) > 0 {
        queryModels = make([]mapping.Model, len(models))
        for i, model := range models {
            queryModels[i] = model
        }
    }
    mStruct, err := modelStruct(db)
    builder := db.QueryCtx(ctx, mStruct, queryModels ...)
    return &_usersQueryBuilder{builder: builder, err: err}
}

// Insert inserts tests.User into database.
func Insert(ctx context.Context, db database.DB, models ...*tests.User) error {
    if len(models) == 0 {
        return errors.Wrap(query.ErrNoModels, "nothing to insert")
    }
    mStruct, err := modelStruct(db)
    if err != nil {
        return err
    }
    queryModels := make([]mapping.Model, len(models))
    for i, model := range models {
        queryModels[i] = model
    }
    return db.Insert(ctx, mStruct, queryModels...)
}

// Update updates tests.User models into database.
func Update(ctx context.Context, db database.DB, models ...*tests.User) (int64, error) {
    if len(models) == 0 {
        return 0, errors.Wrap(query.ErrNoModels, "nothing to insert")
    }
    mStruct, err := modelStruct(db)
    if err != nil {
        return 0, err
    }
    queryModels := make([]mapping.Model, len(models))
    for i, model := range models {
        queryModels[i] = model
    }
    return db.Update(ctx, mStruct, queryModels...)
}

// Delete deletes tests.User models in database.
func Delete(ctx context.Context, db database.DB, models ...*tests.User) (int64,error) {
    if len(models) == 0 {
        return 0, errors.Wrap(query.ErrNoModels, "nothing to insert")
    }
    mStruct, err := modelStruct(db)
    if err != nil {
        return 0, err
    }
    queryModels := make([]mapping.Model, len(models))
    for i, model := range models {
        queryModels[i] = model
    }
    return db.Delete(ctx, mStruct, queryModels...)
}

// Refresh creates the query for the tests.User with provided 'ctx' context.
func Refresh(ctx context.Context, db database.DB, models ...*tests.User) error {
    var queryModels []mapping.Model
    if len(models) == 0 {
        return errors.Wrap(query.ErrNoModels, "nothing to refresh")
    }
    mStruct, err := modelStruct(db)
    if err != nil {
        return err
    }
    queryModels = make([]mapping.Model, len(models))
    for i, model := range models {
        queryModels[i] = model
    }
    return db.Refresh(ctx, mStruct, queryModels...)
}


// ClearFavoriteCarRelation clears the 'FavoriteCar' relationship for provided models. For relationships of type:
// BelongsTo, HasOne, HasMany if foreign key is not nullable than the function would return an error.
func ClearFavoriteCarRelation(ctx context.Context, db database.DB, models ...*tests.User) (int64, error) {
    mStruct, err := modelStruct(db)
    if err != nil {
        return 0, err
    }
    relation, err := mStruct.RelationByIndex(12)
    if err != nil {
        return 0, err
    }
    modelInterfaces := make([]mapping.Model, len(models))
    for i := range models {
        modelInterfaces[i] = models[i]
    }
    s := query.NewScope(mStruct, modelInterfaces...)
    relationClearer, ok := db.(database.QueryRelationClearer)
    if !ok {
        return 0, errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
    }
    return relationClearer.QueryClearRelations(ctx, s, relation)
}


// GetFavoriteCar gets the 'FavoriteCar' relationship for provided input 'model'.
func GetFavoriteCar(ctx context.Context, db database.DB, model *tests.User, relationFieldset ...string) (*tests.Car, error) {
    if model == nil {
        return nil, errors.Wrap(query.ErrNoModels, "provided nil model")
    }
    // Check if primary key has zero value.
    if model.IsPrimaryKeyZero() {
        return nil, errors.Wrap(mapping.ErrFieldValue, "model's: 'tests.User' primary key value has zero value")
    }
    mStruct, err := modelStruct(db)
    if err != nil {
        return nil, err
    }
    relationField, err := mStruct.RelationByIndex(12)
    if err != nil {
        return nil, err
    }

    var fields []*mapping.StructField
    relationModel := relationField.Relationship().RelatedModelStruct()
    if len(relationFieldset) == 0 {
        fields = relationModel.Fields()
    } else {
        for _, field := range relationFieldset {
            sField, ok := relationModel.FieldByName(field)
            if !ok {
                return nil, errors.Wrapf(mapping.ErrInvalidModelField, "no field: '%s' found for the model: 'tests.Car'", field)
            }
            fields = append(fields, sField)
        }
    }

    relations, err := db.GetRelations(ctx, mStruct, []mapping.Model{model}, relationField, fields...)
    if err != nil {
        return nil, err
    }
    if len(relations) == 0 {
        return nil, nil
    }
    return relations[0].(*tests.Car), nil
}


// SetFavoriteCar sets the 'FavoriteCar' relationship for provided input 'models'.
func SetFavoriteCar(ctx context.Context, db database.DB, model *tests.User, relation*tests.Car) error {
    if model == nil {
        return errors.Wrap(query.ErrNoModels, "provided nil model")
    }
    // Check if primary key has zero value.
    if model.IsPrimaryKeyZero() {
        return errors.Wrap(mapping.ErrFieldValue, "model's: 'tests.User' primary key value has zero value")
    }
    mStruct, err := modelStruct(db)
    if err != nil {
        return err
    }
    relationField, err := mStruct.RelationByIndex(12)
    if err != nil {
        return err
    }
    q := query.NewScope(mStruct, model)
    if relation.IsPrimaryKeyZero() {
        return errors.Wrap(mapping.ErrFieldValue, "relation 'FavoriteCar' model has zero value primary field")
    }
    relationSetter, ok := db.(database.QueryRelationSetter)
    if !ok {
        return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationSetter interface: %T", db)
    }
    return relationSetter.QuerySetRelations(ctx, q, relationField, relation)
}
// AddCars adds the 'Cars' relationship for provided input 'models'.
func AddCars(ctx context.Context, db database.DB, model *tests.User, relations ...*tests.Car) error {
    if model == nil {
        return errors.Wrap(query.ErrNoModels, "provided nil model")
    }
    if len(relations) == 0 {
        return errors.Wrap(query.ErrNoModels, "no relation models provided")
    }
    mStruct, err := modelStruct(db)
    if err != nil {
        return err
    }
    relationField, err := mStruct.RelationByIndex(15)
    if err != nil {
        return err
    }
    relationModels := make([]mapping.Model, len(relations))
    for i := range relations {
        relationModels[i] = relations[i]
    }
    q := query.NewScope(mStruct, model)
    relationAdder, ok := db.(database.QueryRelationAdder)
    if !ok {
        return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
    }
    return relationAdder.QueryAddRelations(ctx, q, relationField, relationModels...)
}
// ClearCarsRelation clears the 'Cars' relationship for provided models. For relationships of type:
// BelongsTo, HasOne, HasMany if foreign key is not nullable than the function would return an error.
func ClearCarsRelation(ctx context.Context, db database.DB, models ...*tests.User) (int64, error) {
    mStruct, err := modelStruct(db)
    if err != nil {
        return 0, err
    }
    relation, err := mStruct.RelationByIndex(15)
    if err != nil {
        return 0, err
    }
    modelInterfaces := make([]mapping.Model, len(models))
    for i := range models {
        modelInterfaces[i] = models[i]
    }
    s := query.NewScope(mStruct, modelInterfaces...)
    relationClearer, ok := db.(database.QueryRelationClearer)
    if !ok {
        return 0, errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
    }
    return relationClearer.QueryClearRelations(ctx, s, relation)
}


// GetCars gets the 'Cars' relationship for provided input 'model'.
func GetCars(ctx context.Context, db database.DB, model *tests.User, relationFieldset ...string) ([]*tests.Car, error) {
    if model == nil {
        return nil, errors.Wrap(query.ErrNoModels, "provided nil model")
    }
    // Check if primary key has zero value.
    if model.IsPrimaryKeyZero() {
        return nil, errors.Wrap(mapping.ErrFieldValue, "model's: 'tests.User' primary key value has zero value")
    }
    mStruct, err := modelStruct(db)
    if err != nil {
        return nil, err
    }
    relationField, err := mStruct.RelationByIndex(15)
    if err != nil {
        return nil, err
    }

    var fields []*mapping.StructField
    relationModel := relationField.Relationship().RelatedModelStruct()
    if len(relationFieldset) == 0 {
        fields = relationModel.Fields()
    } else {
        for _, field := range relationFieldset {
            sField, ok := relationModel.FieldByName(field)
            if !ok {
                return nil, errors.Wrapf(mapping.ErrInvalidModelField, "no field: '%s' found for the model: 'tests.Car'", field)
            }
            fields = append(fields, sField)
        }
    }

    relations, err := db.GetRelations(ctx, mStruct, []mapping.Model{model}, relationField, fields...)
    if err != nil {
        return nil, err
    }
    if len(relations) == 0 {
        return []*tests.Car{}, nil
    }
    result := make([]*tests.Car, len(relations))
    for i, relation := range relations {
        result[i] = relation.(*tests.Car)
    }
    return result, nil
}


// SetCars sets the 'Cars' relationship for provided input 'models'.
func SetCars(ctx context.Context, db database.DB, model *tests.User, relations ...*tests.Car) error {
    if model == nil {
        return errors.Wrap(query.ErrNoModels, "provided nil model")
    }
    // Check if primary key has zero value.
    if model.IsPrimaryKeyZero() {
        return errors.Wrap(mapping.ErrFieldValue, "model's: 'tests.User' primary key value has zero value")
    }
    mStruct, err := modelStruct(db)
    if err != nil {
        return err
    }
    relationField, err := mStruct.RelationByIndex(15)
    if err != nil {
        return err
    }
    q := query.NewScope(mStruct, model)
    if len(relations) == 0 {
        return errors.Wrap(query.ErrNoModels, "no relation models provided")
    }
    relationModels := make([]mapping.Model, len(relations))
    for i, relation := range relations {
        if relation.IsPrimaryKeyZero() {
            return errors.Wrap(mapping.ErrFieldValue, "one of relation 'Cars' model has zero value primary field")
        }
        relationModels[i] = relation
    }
    relationSetter, ok := db.(database.QueryRelationSetter)
    if !ok {
        return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationSetter interface: %T", db)
    }
    return relationSetter.QuerySetRelations(ctx, q, relationField, relationModels...)
}
// AddSons adds the 'Sons' relationship for provided input 'models'.
func AddSons(ctx context.Context, db database.DB, model *tests.User, relations ...*tests.User) error {
    if model == nil {
        return errors.Wrap(query.ErrNoModels, "provided nil model")
    }
    if len(relations) == 0 {
        return errors.Wrap(query.ErrNoModels, "no relation models provided")
    }
    mStruct, err := modelStruct(db)
    if err != nil {
        return err
    }
    relationField, err := mStruct.RelationByIndex(16)
    if err != nil {
        return err
    }
    relationModels := make([]mapping.Model, len(relations))
    for i := range relations {
        relationModels[i] = relations[i]
    }
    q := query.NewScope(mStruct, model)
    relationAdder, ok := db.(database.QueryRelationAdder)
    if !ok {
        return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
    }
    return relationAdder.QueryAddRelations(ctx, q, relationField, relationModels...)
}
// ClearSonsRelation clears the 'Sons' relationship for provided models. For relationships of type:
// BelongsTo, HasOne, HasMany if foreign key is not nullable than the function would return an error.
func ClearSonsRelation(ctx context.Context, db database.DB, models ...*tests.User) (int64, error) {
    mStruct, err := modelStruct(db)
    if err != nil {
        return 0, err
    }
    relation, err := mStruct.RelationByIndex(16)
    if err != nil {
        return 0, err
    }
    modelInterfaces := make([]mapping.Model, len(models))
    for i := range models {
        modelInterfaces[i] = models[i]
    }
    s := query.NewScope(mStruct, modelInterfaces...)
    relationClearer, ok := db.(database.QueryRelationClearer)
    if !ok {
        return 0, errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
    }
    return relationClearer.QueryClearRelations(ctx, s, relation)
}


// GetSons gets the 'Sons' relationship for provided input 'model'.
func GetSons(ctx context.Context, db database.DB, model *tests.User, relationFieldset ...string) ([]*tests.User, error) {
    if model == nil {
        return nil, errors.Wrap(query.ErrNoModels, "provided nil model")
    }
    // Check if primary key has zero value.
    if model.IsPrimaryKeyZero() {
        return nil, errors.Wrap(mapping.ErrFieldValue, "model's: 'tests.User' primary key value has zero value")
    }
    mStruct, err := modelStruct(db)
    if err != nil {
        return nil, err
    }
    relationField, err := mStruct.RelationByIndex(16)
    if err != nil {
        return nil, err
    }

    var fields []*mapping.StructField
    relationModel := relationField.Relationship().RelatedModelStruct()
    if len(relationFieldset) == 0 {
        fields = relationModel.Fields()
    } else {
        for _, field := range relationFieldset {
            sField, ok := relationModel.FieldByName(field)
            if !ok {
                return nil, errors.Wrapf(mapping.ErrInvalidModelField, "no field: '%s' found for the model: 'tests.User'", field)
            }
            fields = append(fields, sField)
        }
    }

    relations, err := db.GetRelations(ctx, mStruct, []mapping.Model{model}, relationField, fields...)
    if err != nil {
        return nil, err
    }
    if len(relations) == 0 {
        return []*tests.User{}, nil
    }
    result := make([]*tests.User, len(relations))
    for i, relation := range relations {
        result[i] = relation.(*tests.User)
    }
    return result, nil
}


// SetSons sets the 'Sons' relationship for provided input 'models'.
func SetSons(ctx context.Context, db database.DB, model *tests.User, relations ...*tests.User) error {
    if model == nil {
        return errors.Wrap(query.ErrNoModels, "provided nil model")
    }
    // Check if primary key has zero value.
    if model.IsPrimaryKeyZero() {
        return errors.Wrap(mapping.ErrFieldValue, "model's: 'tests.User' primary key value has zero value")
    }
    mStruct, err := modelStruct(db)
    if err != nil {
        return err
    }
    relationField, err := mStruct.RelationByIndex(16)
    if err != nil {
        return err
    }
    q := query.NewScope(mStruct, model)
    if len(relations) == 0 {
        return errors.Wrap(query.ErrNoModels, "no relation models provided")
    }
    relationModels := make([]mapping.Model, len(relations))
    for i, relation := range relations {
        if relation.IsPrimaryKeyZero() {
            return errors.Wrap(mapping.ErrFieldValue, "one of relation 'Sons' model has zero value primary field")
        }
        relationModels[i] = relation
    }
    relationSetter, ok := db.(database.QueryRelationSetter)
    if !ok {
        return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationSetter interface: %T", db)
    }
    return relationSetter.QuerySetRelations(ctx, q, relationField, relationModels...)
}
// ClearSisterRelation clears the 'Sister' relationship for provided models. For relationships of type:
// BelongsTo, HasOne, HasMany if foreign key is not nullable than the function would return an error.
func ClearSisterRelation(ctx context.Context, db database.DB, models ...*tests.User) (int64, error) {
    mStruct, err := modelStruct(db)
    if err != nil {
        return 0, err
    }
    relation, err := mStruct.RelationByIndex(18)
    if err != nil {
        return 0, err
    }
    modelInterfaces := make([]mapping.Model, len(models))
    for i := range models {
        modelInterfaces[i] = models[i]
    }
    s := query.NewScope(mStruct, modelInterfaces...)
    relationClearer, ok := db.(database.QueryRelationClearer)
    if !ok {
        return 0, errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
    }
    return relationClearer.QueryClearRelations(ctx, s, relation)
}


// GetSister gets the 'Sister' relationship for provided input 'model'.
func GetSister(ctx context.Context, db database.DB, model *tests.User, relationFieldset ...string) (*tests.User, error) {
    if model == nil {
        return nil, errors.Wrap(query.ErrNoModels, "provided nil model")
    }
    // Check if primary key has zero value.
    if model.IsPrimaryKeyZero() {
        return nil, errors.Wrap(mapping.ErrFieldValue, "model's: 'tests.User' primary key value has zero value")
    }
    mStruct, err := modelStruct(db)
    if err != nil {
        return nil, err
    }
    relationField, err := mStruct.RelationByIndex(18)
    if err != nil {
        return nil, err
    }

    var fields []*mapping.StructField
    relationModel := relationField.Relationship().RelatedModelStruct()
    if len(relationFieldset) == 0 {
        fields = relationModel.Fields()
    } else {
        for _, field := range relationFieldset {
            sField, ok := relationModel.FieldByName(field)
            if !ok {
                return nil, errors.Wrapf(mapping.ErrInvalidModelField, "no field: '%s' found for the model: 'tests.User'", field)
            }
            fields = append(fields, sField)
        }
    }

    relations, err := db.GetRelations(ctx, mStruct, []mapping.Model{model}, relationField, fields...)
    if err != nil {
        return nil, err
    }
    if len(relations) == 0 {
        return nil, nil
    }
    return relations[0].(*tests.User), nil
}


// SetSister sets the 'Sister' relationship for provided input 'models'.
func SetSister(ctx context.Context, db database.DB, model *tests.User, relation*tests.User) error {
    if model == nil {
        return errors.Wrap(query.ErrNoModels, "provided nil model")
    }
    // Check if primary key has zero value.
    if model.IsPrimaryKeyZero() {
        return errors.Wrap(mapping.ErrFieldValue, "model's: 'tests.User' primary key value has zero value")
    }
    mStruct, err := modelStruct(db)
    if err != nil {
        return err
    }
    relationField, err := mStruct.RelationByIndex(18)
    if err != nil {
        return err
    }
    q := query.NewScope(mStruct, model)
    if relation.IsPrimaryKeyZero() {
        return errors.Wrap(mapping.ErrFieldValue, "relation 'Sister' model has zero value primary field")
    }
    relationSetter, ok := db.(database.QueryRelationSetter)
    if !ok {
        return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationSetter interface: %T", db)
    }
    return relationSetter.QuerySetRelations(ctx, q, relationField, relation)
}
// ClearExternalRelation clears the 'External' relationship for provided models. For relationships of type:
// BelongsTo, HasOne, HasMany if foreign key is not nullable than the function would return an error.
func ClearExternalRelation(ctx context.Context, db database.DB, models ...*tests.User) (int64, error) {
    mStruct, err := modelStruct(db)
    if err != nil {
        return 0, err
    }
    relation, err := mStruct.RelationByIndex(10)
    if err != nil {
        return 0, err
    }
    modelInterfaces := make([]mapping.Model, len(models))
    for i := range models {
        modelInterfaces[i] = models[i]
    }
    s := query.NewScope(mStruct, modelInterfaces...)
    relationClearer, ok := db.(database.QueryRelationClearer)
    if !ok {
        return 0, errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
    }
    return relationClearer.QueryClearRelations(ctx, s, relation)
}


// GetExternal gets the 'External' relationship for provided input 'model'.
func GetExternal(ctx context.Context, db database.DB, model *tests.User, relationFieldset ...string) (*external.Model, error) {
    if model == nil {
        return nil, errors.Wrap(query.ErrNoModels, "provided nil model")
    }
    // Check if primary key has zero value.
    if model.IsPrimaryKeyZero() {
        return nil, errors.Wrap(mapping.ErrFieldValue, "model's: 'tests.User' primary key value has zero value")
    }
    mStruct, err := modelStruct(db)
    if err != nil {
        return nil, err
    }
    relationField, err := mStruct.RelationByIndex(10)
    if err != nil {
        return nil, err
    }

    var fields []*mapping.StructField
    relationModel := relationField.Relationship().RelatedModelStruct()
    if len(relationFieldset) == 0 {
        fields = relationModel.Fields()
    } else {
        for _, field := range relationFieldset {
            sField, ok := relationModel.FieldByName(field)
            if !ok {
                return nil, errors.Wrapf(mapping.ErrInvalidModelField, "no field: '%s' found for the model: 'external.Model'", field)
            }
            fields = append(fields, sField)
        }
    }

    relations, err := db.GetRelations(ctx, mStruct, []mapping.Model{model}, relationField, fields...)
    if err != nil {
        return nil, err
    }
    if len(relations) == 0 {
        return nil, nil
    }
    return relations[0].(*external.Model), nil
}


// SetExternal sets the 'External' relationship for provided input 'models'.
func SetExternal(ctx context.Context, db database.DB, model *tests.User, relation*external.Model) error {
    if model == nil {
        return errors.Wrap(query.ErrNoModels, "provided nil model")
    }
    // Check if primary key has zero value.
    if model.IsPrimaryKeyZero() {
        return errors.Wrap(mapping.ErrFieldValue, "model's: 'tests.User' primary key value has zero value")
    }
    mStruct, err := modelStruct(db)
    if err != nil {
        return err
    }
    relationField, err := mStruct.RelationByIndex(10)
    if err != nil {
        return err
    }
    q := query.NewScope(mStruct, model)
    if relation.IsPrimaryKeyZero() {
        return errors.Wrap(mapping.ErrFieldValue, "relation 'External' model has zero value primary field")
    }
    relationSetter, ok := db.(database.QueryRelationSetter)
    if !ok {
        return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationSetter interface: %T", db)
    }
    return relationSetter.QuerySetRelations(ctx, q, relationField, relation)
}


// _usersQueryBuilder is the query builder used to create and execute
// queries for the tests.Usermodel.
type _usersQueryBuilder struct {
    builder database.Builder
    err error
}

// Scope returns given query scope.
func (_u *_usersQueryBuilder) Scope() *query.Scope {
    return _u.builder.Scope()
}

// Err returns errors that occurred during query building process.
func (_u *_usersQueryBuilder) Err() error {
    if _u.err != nil {
        return _u.err
    }
    return _u.builder.Err()
}

// Ctx returns the context of given query builder.
func (_u *_usersQueryBuilder) Ctx() context.Context {
    return _u.builder.Ctx()
}

// Count returns the number of model instances for provided query.
func (_u *_usersQueryBuilder) Count() (int64, error) {
    if _u.err != nil {
        return 0, _u.err
    }
    return _u.builder.Count()
}

// Insert new 'tests.User' instance(s) into the store.
func (_u *_usersQueryBuilder) Insert() error {
    if _u.err != nil {
        return _u.err
    }
    return _u.builder.Insert()
}

// Update updates given 'tests.User' instances.
func (_u *_usersQueryBuilder) Update() (int64, error) {
    if _u.err != nil {
        return 0, _u.err
    }
    return _u.builder.Update()
}


// Find returns all tests.User models that matches to given query.
func (_u *_usersQueryBuilder) Find() ([]*tests.User, error) {
    if _u.err != nil {
        return nil, _u.err
    }
    queryModels, err := _u.builder.Find()
    if err != nil {
        return nil, err
    }
    models := make([]*tests.User, len(queryModels))
    for i := range queryModels {
        models[i] = queryModels[i].(*tests.User)
    }
    return models, nil
}

// Refresh refreshes input 'tests.User' model fields. It might be combine with the included relations.
func (_u *_usersQueryBuilder) Refresh() error {
    if _u.err != nil {
        return _u.err
    }
    return _u.builder.Refresh()
}

// Get returns single tests.User model that matches given query.
// If the model is not found the function returns error of query.ErrQueryNoResult.
func (_u *_usersQueryBuilder) Get() (*tests.User, error) {
    if _u.err != nil {
        return nil, _u.err
    }
    model, err := _u.builder.Get()
    if err != nil {
        return nil, err
    }
    return model.(*tests.User), nil
}

// Delete deletes tests.User instances that matches given query.
func (_u *_usersQueryBuilder) Delete() (int64, error) {
    if _u.err != nil {
        return 0, _u.err
    }
    return _u.builder.Delete()
}

// Filter adds the 'filter' to the given query.
func (_u *_usersQueryBuilder) Filter(filter filter.Filter) (*_usersQueryBuilder) {
    if _u.err != nil {
       return _u
    }
    _u.builder.Filter(filter)
    return _u
}

// Where creates query with given 'filter' and 'values'.
func (_u *_usersQueryBuilder) Where(filter string, values ...interface{}) (*_usersQueryBuilder) {
    if _u.err != nil {
        return _u
    }
    _u.builder.Where(filter, values...)
    return _u
}



// IncludeFavoriteCar includes given 'relation' in the NRN_Users query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (_u *_usersQueryBuilder) IncludeFavoriteCar(favoriteCarFieldset ...string) (*_usersQueryBuilder) {
    if _u.err != nil {
        return _u
    }
    relation, err := _u.builder.Scope().ModelStruct.RelationByIndex(12)
    if err != nil {
        _u.err =  errors.Wrapf(mapping.ErrInternal, "Getting 'FavoriteCar' by index for model 'tests.User' failed: %v", err)
        return _u
    }
    // check the fieldset for the relation.
    var relationFields []*mapping.StructField
    for _, field := range favoriteCarFieldset {
        structField, ok := relation.Relationship().RelatedModelStruct().FieldByName(field)
        if !ok {
            _u.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not found for the 'tests.Car' model", field)
            return _u
        }
        relationFields = append(relationFields, structField)
    }
    _u.builder.Include(relation, relationFields...)
    return _u
}

// IncludeCars includes given 'relation' in the NRN_Users query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (_u *_usersQueryBuilder) IncludeCars(carsFieldset ...string) (*_usersQueryBuilder) {
    if _u.err != nil {
        return _u
    }
    relation, err := _u.builder.Scope().ModelStruct.RelationByIndex(15)
    if err != nil {
        _u.err =  errors.Wrapf(mapping.ErrInternal, "Getting 'Cars' by index for model 'tests.User' failed: %v", err)
        return _u
    }
    // check the fieldset for the relation.
    var relationFields []*mapping.StructField
    for _, field := range carsFieldset {
        structField, ok := relation.Relationship().RelatedModelStruct().FieldByName(field)
        if !ok {
            _u.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not found for the 'tests.Car' model", field)
            return _u
        }
        relationFields = append(relationFields, structField)
    }
    _u.builder.Include(relation, relationFields...)
    return _u
}

// IncludeSons includes given 'relation' in the NRN_Users query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (_u *_usersQueryBuilder) IncludeSons(sonsFieldset ...string) (*_usersQueryBuilder) {
    if _u.err != nil {
        return _u
    }
    relation, err := _u.builder.Scope().ModelStruct.RelationByIndex(16)
    if err != nil {
        _u.err =  errors.Wrapf(mapping.ErrInternal, "Getting 'Sons' by index for model 'tests.User' failed: %v", err)
        return _u
    }
    // check the fieldset for the relation.
    var relationFields []*mapping.StructField
    for _, field := range sonsFieldset {
        structField, ok := relation.Relationship().RelatedModelStruct().FieldByName(field)
        if !ok {
            _u.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not found for the 'tests.User' model", field)
            return _u
        }
        relationFields = append(relationFields, structField)
    }
    _u.builder.Include(relation, relationFields...)
    return _u
}

// IncludeSister includes given 'relation' in the NRN_Users query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (_u *_usersQueryBuilder) IncludeSister(sisterFieldset ...string) (*_usersQueryBuilder) {
    if _u.err != nil {
        return _u
    }
    relation, err := _u.builder.Scope().ModelStruct.RelationByIndex(18)
    if err != nil {
        _u.err =  errors.Wrapf(mapping.ErrInternal, "Getting 'Sister' by index for model 'tests.User' failed: %v", err)
        return _u
    }
    // check the fieldset for the relation.
    var relationFields []*mapping.StructField
    for _, field := range sisterFieldset {
        structField, ok := relation.Relationship().RelatedModelStruct().FieldByName(field)
        if !ok {
            _u.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not found for the 'tests.User' model", field)
            return _u
        }
        relationFields = append(relationFields, structField)
    }
    _u.builder.Include(relation, relationFields...)
    return _u
}

// IncludeExternal includes given 'relation' in the NRN_Users query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (_u *_usersQueryBuilder) IncludeExternal(externalFieldset ...string) (*_usersQueryBuilder) {
    if _u.err != nil {
        return _u
    }
    relation, err := _u.builder.Scope().ModelStruct.RelationByIndex(10)
    if err != nil {
        _u.err =  errors.Wrapf(mapping.ErrInternal, "Getting 'External' by index for model 'tests.User' failed: %v", err)
        return _u
    }
    // check the fieldset for the relation.
    var relationFields []*mapping.StructField
    for _, field := range externalFieldset {
        structField, ok := relation.Relationship().RelatedModelStruct().FieldByName(field)
        if !ok {
            _u.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not found for the 'external.Model' model", field)
            return _u
        }
        relationFields = append(relationFields, structField)
    }
    _u.builder.Include(relation, relationFields...)
    return _u
}

// Limit sets the maximum number of objects returned by the Find process,
// Returns error if the given scope has already different type of pagination.
func (_u *_usersQueryBuilder) Limit(limit int64) (*_usersQueryBuilder) {
    if _u.err != nil {
        return _u
    }
    _u.builder.Limit(limit)
    return _u
}

// Offset sets the query result's offset. It says to skip as many object's from the repository
// before beginning to return the result. 'Offset' 0 is the same as omitting the 'Offset' clause.
// Returns error if the given scope has already different type of pagination.
func (_u *_usersQueryBuilder) Offset(offset int64) (*_usersQueryBuilder) {
    if _u.err != nil {
        return _u
    }
    _u.builder.Offset(offset)
    return _u
}

// Select adds the fields to the scope's fieldset.
// Allowed fields to select:
//  - ID / id
//  - ID / id
//  - CreatedAt / created_at
//  - DeletedAt / deleted_at
//  - Name / name
//  - Age / age
//  - IntArray / int_array
//  - Bytes / bytes
//  - PtrBytes / ptr_bytes
//  - Wrapped / wrapped
//  - PtrWrapped / ptr_wrapped
//  - ExternalID / external_id
//  - FavoriteCarID / favorite_car_id
//  - SisterID / sister_id
//  - ParentID / parent_id
func (_u *_usersQueryBuilder) Select(fields ...string) (*_usersQueryBuilder) {
    if _u.err != nil {
        return _u
    }
    var fieldSet []*mapping.StructField
    for _, field := range fields {
        structField, ok := _u.builder.Scope().ModelStruct.FieldByName(field)
        if !ok {
            _u.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not valid for model: 'NRN_Users'",field)
            return _u
        }
        fieldSet = append(fieldSet, structField)
    }
    _u.builder.Select(fieldSet...)
    return _u
}

// OrderBy adds the sort fields into query scope. By default field is ordered ascending. In order to sort descending
// add '-' before the field name i.e. '-id'. The order of the fields relates to the significance of the sorting order.
// Allowed fields to sort:
//  - ID
//  - CreatedAt
//  - DeletedAt
//  - Name
//  - Age
//  - IntArray
//  - Bytes
//  - PtrBytes
//  - Wrapped
//  - PtrWrapped
//  - ExternalID
//  - FavoriteCarID
//  - SisterID
//  - ParentID
func (_u *_usersQueryBuilder) OrderBy(fields ...string) (*_usersQueryBuilder) {
    if _u.err != nil {
        return _u
    }
    sortFields := make([]query.Sort, len(fields))
    for i, field := range fields {
        if len(field) == 0 {
            _u.err = errors.Wrap(mapping.ErrInvalidModelField, "cannot set sorting order for an empty field for model: 'NRN_Users'")
            return _u
        }
        var order query.SortOrder
        if field[0] == '-' {
            order = query.DescendingOrder
            field = field[1:]
        }
        structField, ok := _u.builder.Scope().ModelStruct.FieldByName(field)
        if !ok {
            _u.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not valid for model: 'NRN_Users'", field)
            return _u
        }
        sortFields[i] = query.SortField{StructField: structField, SortOrder: order}
    }
    _u.builder.OrderBy(sortFields...)
    return _u
}


// AddFavoriteCar adds related model FavoriteCar and matches to given tests.User.
func (_u *_usersQueryBuilder) AddFavoriteCar(_favoriteCar *tests.Car) error {
    if _u.err != nil {
        return _u.err
    }
    relation, err := _u.builder.Scope().ModelStruct.RelationByIndex(12)
    if err != nil {
        return errors.Wrapf(mapping.ErrInternal, "getting 'FavoriteCar' relation by index for model 'tests.User' failed: %v", err)
    }
    return _u.builder.AddRelations(relation, _favoriteCar)
}

// AddCars adds related model Cars and matches to given tests.User.
func (_u *_usersQueryBuilder) AddCars(_cars ...*tests.Car) error {
    if _u.err != nil {
        return _u.err
    }
    relation, err := _u.builder.Scope().ModelStruct.RelationByIndex(15)
    if err != nil {
        return errors.Wrapf(mapping.ErrInternal, "getting 'Cars' relation by index for model 'tests.User' failed: %v", err)
    }
    models := make([]mapping.Model, len(_cars))
    for i := range _cars {
        models[i] = _cars[i]
    }
    return _u.builder.AddRelations(relation, models...)
}

// AddSons adds related model Sons and matches to given tests.User.
func (_u *_usersQueryBuilder) AddSons(_sons ...*tests.User) error {
    if _u.err != nil {
        return _u.err
    }
    relation, err := _u.builder.Scope().ModelStruct.RelationByIndex(16)
    if err != nil {
        return errors.Wrapf(mapping.ErrInternal, "getting 'Sons' relation by index for model 'tests.User' failed: %v", err)
    }
    models := make([]mapping.Model, len(_sons))
    for i := range _sons {
        models[i] = _sons[i]
    }
    return _u.builder.AddRelations(relation, models...)
}

// AddSister adds related model Sister and matches to given tests.User.
func (_u *_usersQueryBuilder) AddSister(_sister *tests.User) error {
    if _u.err != nil {
        return _u.err
    }
    relation, err := _u.builder.Scope().ModelStruct.RelationByIndex(18)
    if err != nil {
        return errors.Wrapf(mapping.ErrInternal, "getting 'Sister' relation by index for model 'tests.User' failed: %v", err)
    }
    return _u.builder.AddRelations(relation, _sister)
}

// AddExternal adds related model External and matches to given tests.User.
func (_u *_usersQueryBuilder) AddExternal(_external *external.Model) error {
    if _u.err != nil {
        return _u.err
    }
    relation, err := _u.builder.Scope().ModelStruct.RelationByIndex(10)
    if err != nil {
        return errors.Wrapf(mapping.ErrInternal, "getting 'External' relation by index for model 'tests.User' failed: %v", err)
    }
    return _u.builder.AddRelations(relation, _external)
}


// SetFavoriteCar sets related model FavoriteCar and matches to given tests.User.
func (_u *_usersQueryBuilder) SetFavoriteCar(_favoriteCar *tests.Car) error {
    if _u.err != nil {
        return _u.err
    }
    relation, err := _u.builder.Scope().ModelStruct.RelationByIndex(12)
    if err != nil {
        return errors.Wrapf(mapping.ErrInternal, "getting 'FavoriteCar' relation by index for model 'tests.User' failed: %v", err)
    }
    return _u.builder.SetRelations(relation, _favoriteCar)
}

// SetCars sets related model Cars and matches to given tests.User.
func (_u *_usersQueryBuilder) SetCars(_cars ...*tests.Car) error {
    if _u.err != nil {
        return _u.err
    }
    relation, err := _u.builder.Scope().ModelStruct.RelationByIndex(15)
    if err != nil {
        return errors.Wrapf(mapping.ErrInternal, "getting 'Cars' relation by index for model 'tests.User' failed: %v", err)
    }
    models := make([]mapping.Model, len(_cars))
    for i := range _cars {
        models[i] = _cars[i]
    }
    return _u.builder.SetRelations(relation, models...)
}

// SetSons sets related model Sons and matches to given tests.User.
func (_u *_usersQueryBuilder) SetSons(_sons ...*tests.User) error {
    if _u.err != nil {
        return _u.err
    }
    relation, err := _u.builder.Scope().ModelStruct.RelationByIndex(16)
    if err != nil {
        return errors.Wrapf(mapping.ErrInternal, "getting 'Sons' relation by index for model 'tests.User' failed: %v", err)
    }
    models := make([]mapping.Model, len(_sons))
    for i := range _sons {
        models[i] = _sons[i]
    }
    return _u.builder.SetRelations(relation, models...)
}

// SetSister sets related model Sister and matches to given tests.User.
func (_u *_usersQueryBuilder) SetSister(_sister *tests.User) error {
    if _u.err != nil {
        return _u.err
    }
    relation, err := _u.builder.Scope().ModelStruct.RelationByIndex(18)
    if err != nil {
        return errors.Wrapf(mapping.ErrInternal, "getting 'Sister' relation by index for model 'tests.User' failed: %v", err)
    }
    return _u.builder.SetRelations(relation, _sister)
}

// SetExternal sets related model External and matches to given tests.User.
func (_u *_usersQueryBuilder) SetExternal(_external *external.Model) error {
    if _u.err != nil {
        return _u.err
    }
    relation, err := _u.builder.Scope().ModelStruct.RelationByIndex(10)
    if err != nil {
        return errors.Wrapf(mapping.ErrInternal, "getting 'External' relation by index for model 'tests.User' failed: %v", err)
    }
    return _u.builder.SetRelations(relation, _external)
}


// RemoveFavoriteCar removes related model FavoriteCar and matches to given tests.User.
func (_u *_usersQueryBuilder) RemoveFavoriteCar() (int64, error) {
    if _u.err != nil {
        return 0, _u.err
    }
    relation, err := _u.builder.Scope().ModelStruct.RelationByIndex(12)
    if err != nil {
        return 0, errors.Wrapf(mapping.ErrInternal, "getting 'FavoriteCar' relation by index for model 'tests.User' failed: %v", err)
    }
    return _u.builder.RemoveRelations(relation)
}

// RemoveCars removes related model Cars and matches to given tests.User.
func (_u *_usersQueryBuilder) RemoveCars() (int64, error) {
    if _u.err != nil {
        return 0, _u.err
    }
    relation, err := _u.builder.Scope().ModelStruct.RelationByIndex(15)
    if err != nil {
        return 0, errors.Wrapf(mapping.ErrInternal, "getting 'Cars' relation by index for model 'tests.User' failed: %v", err)
    }
    return _u.builder.RemoveRelations(relation)
}

// RemoveSons removes related model Sons and matches to given tests.User.
func (_u *_usersQueryBuilder) RemoveSons() (int64, error) {
    if _u.err != nil {
        return 0, _u.err
    }
    relation, err := _u.builder.Scope().ModelStruct.RelationByIndex(16)
    if err != nil {
        return 0, errors.Wrapf(mapping.ErrInternal, "getting 'Sons' relation by index for model 'tests.User' failed: %v", err)
    }
    return _u.builder.RemoveRelations(relation)
}

// RemoveSister removes related model Sister and matches to given tests.User.
func (_u *_usersQueryBuilder) RemoveSister() (int64, error) {
    if _u.err != nil {
        return 0, _u.err
    }
    relation, err := _u.builder.Scope().ModelStruct.RelationByIndex(18)
    if err != nil {
        return 0, errors.Wrapf(mapping.ErrInternal, "getting 'Sister' relation by index for model 'tests.User' failed: %v", err)
    }
    return _u.builder.RemoveRelations(relation)
}

// RemoveExternal removes related model External and matches to given tests.User.
func (_u *_usersQueryBuilder) RemoveExternal() (int64, error) {
    if _u.err != nil {
        return 0, _u.err
    }
    relation, err := _u.builder.Scope().ModelStruct.RelationByIndex(10)
    if err != nil {
        return 0, errors.Wrapf(mapping.ErrInternal, "getting 'External' relation by index for model 'tests.User' failed: %v", err)
    }
    return _u.builder.RemoveRelations(relation)
}