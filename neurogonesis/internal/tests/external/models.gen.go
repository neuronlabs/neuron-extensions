// Code generated by neurogonesis. DO NOT EDIT.
// This file was generated at:
// Thu, 03 Sep 2020 17:13:07 +0200

package external

import (
	"strconv"

	"github.com/neuronlabs/neuron/errors"
	"github.com/neuronlabs/neuron/mapping"
)

// Neuron_Models stores all generated models in this package.
var Neuron_Models = []mapping.Model{
	&Model{},
}

// Compile time check if Model implements mapping.Model interface.
var _ mapping.Model = &Model{}

// IsPrimaryKeyZero implements mapping.Model interface method.
func (m *Model) IsPrimaryKeyZero() bool {
	return m.ID == 0
}

// GetPrimaryKeyValue implements mapping.Model interface method.
func (m *Model) GetPrimaryKeyValue() interface{} {
	return m.ID
}

// GetPrimaryKeyStringValue implements mapping.Model interface method.
func (m *Model) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatInt(int64(m.ID), 10), nil
}

// GetPrimaryKeyAddress implements mapping.Model interface method.
func (m *Model) GetPrimaryKeyAddress() interface{} {
	return &m.ID
}

// GetPrimaryKeyHashableValue implements mapping.Model interface method.
func (m *Model) GetPrimaryKeyHashableValue() interface{} {
	return m.ID
}

// GetPrimaryKeyZeroValue implements mapping.Model interface method.
func (m *Model) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements mapping.Model interface method.
func (m *Model) SetPrimaryKeyValue(value interface{}) error {
	if _v, ok := value.(int); ok {
		m.ID = _v
		return nil
	}
	// Check alternate types for given field.
	switch _valueType := value.(type) {
	case int8:
		m.ID = int(_valueType)
	case int16:
		m.ID = int(_valueType)
	case int32:
		m.ID = int(_valueType)
	case int64:
		m.ID = int(_valueType)
	case uint:
		m.ID = int(_valueType)
	case uint8:
		m.ID = int(_valueType)
	case uint16:
		m.ID = int(_valueType)
	case uint32:
		m.ID = int(_valueType)
	case uint64:
		m.ID = int(_valueType)
	case float32:
		m.ID = int(_valueType)
	case float64:
		m.ID = int(_valueType)
	default:
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'Model'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (m *Model) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	if err != nil {
		return err
	}
	m.ID = int(tmp)
	return nil
}

// SetFrom implements FromSetter interface.
func (m *Model) SetFrom(model mapping.Model) error {
	if model == nil {
		return errors.Wrap(mapping.ErrNilModel, "provided nil model to set from")
	}
	from, ok := model.(*Model)
	if !ok {
		return errors.WrapDetf(mapping.ErrModelNotMatch, "provided model doesn't match the input: %T", model)
	}
	*m = *from
	return nil
}

// StructFieldValues gets the value for specified 'field'.
func (m *Model) StructFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID, nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: Model'", field.Name())
	}
}

// Compile time check if Model implements mapping.Fielder interface.
var _ mapping.Fielder = &Model{}

// GetFieldsAddress gets the address of provided 'field'.
func (m *Model) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &m.ID, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: Model'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (m *Model) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (m *Model) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID == 0, nil
	}
	return false, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (m *Model) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		m.ID = 0
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (m *Model) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: 'Model'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (m *Model) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return m.ID, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: Model'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (m *Model) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if _v, ok := value.(int); ok {
			m.ID = _v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			m.ID = 0
			return nil
		}

		switch _v := value.(type) {
		case int8:
			m.ID = int(_v)
		case int16:
			m.ID = int(_v)
		case int32:
			m.ID = int(_v)
		case int64:
			m.ID = int(_v)
		case uint:
			m.ID = int(_v)
		case uint8:
			m.ID = int(_v)
		case uint16:
			m.ID = int(_v)
		case uint32:
			m.ID = int(_v)
		case uint64:
			m.ID = int(_v)
		case float32:
			m.ID = int(_v)
		case float64:
			m.ID = int(_v)
		default:
			return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for the model: 'Model'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (m *Model) ParseFieldsStringValue(field *mapping.StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: Model'", field.Name())
}
