// Code generated by neurogonesis. DO NOT EDIT.
// This file was generated at:
// Thu, 03 Sep 2020 17:04:39 +0200

package cardb

import (
    "context"
    "github.com/neuronlabs/neuron/database"
    "github.com/neuronlabs/neuron/errors"
    "github.com/neuronlabs/neuron/mapping"
    "github.com/neuronlabs/neuron/query"
    "github.com/neuronlabs/neuron/query/filter"
    "github.com/neuronlabs/neuron-extensions/neurogonesis/internal/tests"
    "github.com/neuronlabs/neuron-extensions/neurogonesis/internal/tests/external"
)

var _mStruct *mapping.ModelStruct

func modelStruct(_db database.DB) (*mapping.ModelStruct, error) {
    if _mStruct != nil {
        return _mStruct, nil
    }
    mStruct, err := _db.ModelMap().ModelStruct(&tests.Car{})
    if err != nil {
        return nil, err
    }
    _mStruct = mStruct
    return mStruct, nil
}

// ToModels converts the input slice of tests.Car into []mapping.Model
func ToModels(input ...*tests.Car) ([]mapping.Model) {
    output := make([]mapping.Model, len(input))
    for i := range input {
        output[i] = input[i]
    }
    return output
}

// FromModels converts the input mapping.Model into []*tests.Car.
func FromModels(input ...mapping.Model) ([]*tests.Car) {
    output := make([]*tests.Car, len(input))
    for i := range input {
        output[i] = input[i].(*tests.Car)
    }
    return output
}

// Query creates the query for the tests.Car.
func Query(db database.DB, models ...*tests.Car) *_customCarsQueryBuilder {
    var queryModels []mapping.Model
    if len(models) > 0 {
        queryModels = make([]mapping.Model, len(models))
        for i, model := range models {
            queryModels[i] = model
        }
    }
    mStruct, err := modelStruct(db)
    builder := db.Query(mStruct, queryModels ...)
    return &_customCarsQueryBuilder{builder: builder, err: err}
}

// QueryCtx creates the query for the tests.Car with provided 'ctx' context.
func QueryCtx(ctx context.Context, db database.DB, models ...*tests.Car) *_customCarsQueryBuilder {
    var queryModels []mapping.Model
    if len(models) > 0 {
        queryModels = make([]mapping.Model, len(models))
        for i, model := range models {
            queryModels[i] = model
        }
    }
    mStruct, err := modelStruct(db)
    builder := db.QueryCtx(ctx, mStruct, queryModels ...)
    return &_customCarsQueryBuilder{builder: builder, err: err}
}

// Insert inserts tests.Car into database.
func Insert(ctx context.Context, db database.DB, models ...*tests.Car) error {
    if len(models) == 0 {
        return errors.Wrap(query.ErrNoModels, "nothing to insert")
    }
    mStruct, err := modelStruct(db)
    if err != nil {
        return err
    }
    queryModels := make([]mapping.Model, len(models))
    for i, model := range models {
        queryModels[i] = model
    }
    return db.Insert(ctx, mStruct, queryModels...)
}

// Update updates tests.Car models into database.
func Update(ctx context.Context, db database.DB, models ...*tests.Car) (int64, error) {
    if len(models) == 0 {
        return 0, errors.Wrap(query.ErrNoModels, "nothing to insert")
    }
    mStruct, err := modelStruct(db)
    if err != nil {
        return 0, err
    }
    queryModels := make([]mapping.Model, len(models))
    for i, model := range models {
        queryModels[i] = model
    }
    return db.Update(ctx, mStruct, queryModels...)
}

// Delete deletes tests.Car models in database.
func Delete(ctx context.Context, db database.DB, models ...*tests.Car) (int64,error) {
    if len(models) == 0 {
        return 0, errors.Wrap(query.ErrNoModels, "nothing to insert")
    }
    mStruct, err := modelStruct(db)
    if err != nil {
        return 0, err
    }
    queryModels := make([]mapping.Model, len(models))
    for i, model := range models {
        queryModels[i] = model
    }
    return db.Delete(ctx, mStruct, queryModels...)
}

// Refresh creates the query for the tests.Car with provided 'ctx' context.
func Refresh(ctx context.Context, db database.DB, models ...*tests.Car) error {
    var queryModels []mapping.Model
    if len(models) == 0 {
        return errors.Wrap(query.ErrNoModels, "nothing to refresh")
    }
    mStruct, err := modelStruct(db)
    if err != nil {
        return err
    }
    queryModels = make([]mapping.Model, len(models))
    for i, model := range models {
        queryModels[i] = model
    }
    return db.Refresh(ctx, mStruct, queryModels...)
}


// AddModels adds the 'Models' relationship for provided input 'models'.
func AddModels(ctx context.Context, db database.DB, model *tests.Car, relations ...*external.Model) error {
    if model == nil {
        return errors.Wrap(query.ErrNoModels, "provided nil model")
    }
    if len(relations) == 0 {
        return errors.Wrap(query.ErrNoModels, "no relation models provided")
    }
    mStruct, err := modelStruct(db)
    if err != nil {
        return err
    }
    relationField, err := mStruct.RelationByIndex(6)
    if err != nil {
        return err
    }
    relationModels := make([]mapping.Model, len(relations))
    for i := range relations {
        relationModels[i] = relations[i]
    }
    q := query.NewScope(mStruct, model)
    relationAdder, ok := db.(database.QueryRelationAdder)
    if !ok {
        return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
    }
    return relationAdder.QueryAddRelations(ctx, q, relationField, relationModels...)
}
// ClearModelsRelation clears the 'Models' relationship for provided models. For relationships of type:
// BelongsTo, HasOne, HasMany if foreign key is not nullable than the function would return an error.
func ClearModelsRelation(ctx context.Context, db database.DB, models ...*tests.Car) (int64, error) {
    mStruct, err := modelStruct(db)
    if err != nil {
        return 0, err
    }
    relation, err := mStruct.RelationByIndex(6)
    if err != nil {
        return 0, err
    }
    modelInterfaces := make([]mapping.Model, len(models))
    for i := range models {
        modelInterfaces[i] = models[i]
    }
    s := query.NewScope(mStruct, modelInterfaces...)
    relationClearer, ok := db.(database.QueryRelationClearer)
    if !ok {
        return 0, errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
    }
    return relationClearer.QueryClearRelations(ctx, s, relation)
}


// GetModels gets the 'Models' relationship for provided input 'model'.
func GetModels(ctx context.Context, db database.DB, model *tests.Car, relationFieldset ...string) ([]*external.Model, error) {
    if model == nil {
        return nil, errors.Wrap(query.ErrNoModels, "provided nil model")
    }
    // Check if primary key has zero value.
    if model.IsPrimaryKeyZero() {
        return nil, errors.Wrap(mapping.ErrFieldValue, "model's: 'tests.Car' primary key value has zero value")
    }
    mStruct, err := modelStruct(db)
    if err != nil {
        return nil, err
    }
    relationField, err := mStruct.RelationByIndex(6)
    if err != nil {
        return nil, err
    }

    var fields []*mapping.StructField
    relationModel := relationField.Relationship().RelatedModelStruct()
    if len(relationFieldset) == 0 {
        fields = relationModel.Fields()
    } else {
        for _, field := range relationFieldset {
            sField, ok := relationModel.FieldByName(field)
            if !ok {
                return nil, errors.Wrapf(mapping.ErrInvalidModelField, "no field: '%s' found for the model: 'external.Model'", field)
            }
            fields = append(fields, sField)
        }
    }

    relations, err := db.GetRelations(ctx, mStruct, []mapping.Model{model}, relationField, fields...)
    if err != nil {
        return nil, err
    }
    if len(relations) == 0 {
        return []*external.Model{}, nil
    }
    result := make([]*external.Model, len(relations))
    for i, relation := range relations {
        result[i] = relation.(*external.Model)
    }
    return result, nil
}


// SetModels sets the 'Models' relationship for provided input 'models'.
func SetModels(ctx context.Context, db database.DB, model *tests.Car, relations ...*external.Model) error {
    if model == nil {
        return errors.Wrap(query.ErrNoModels, "provided nil model")
    }
    // Check if primary key has zero value.
    if model.IsPrimaryKeyZero() {
        return errors.Wrap(mapping.ErrFieldValue, "model's: 'tests.Car' primary key value has zero value")
    }
    mStruct, err := modelStruct(db)
    if err != nil {
        return err
    }
    relationField, err := mStruct.RelationByIndex(6)
    if err != nil {
        return err
    }
    q := query.NewScope(mStruct, model)
    if len(relations) == 0 {
        return errors.Wrap(query.ErrNoModels, "no relation models provided")
    }
    relationModels := make([]mapping.Model, len(relations))
    for i, relation := range relations {
        if relation.IsPrimaryKeyZero() {
            return errors.Wrap(mapping.ErrFieldValue, "one of relation 'Models' model has zero value primary field")
        }
        relationModels[i] = relation
    }
    relationSetter, ok := db.(database.QueryRelationSetter)
    if !ok {
        return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationSetter interface: %T", db)
    }
    return relationSetter.QuerySetRelations(ctx, q, relationField, relationModels...)
}
// AddNonPointerModels adds the 'NonPointerModels' relationship for provided input 'models'.
func AddNonPointerModels(ctx context.Context, db database.DB, model *tests.Car, relations ...*external.Model) error {
    if model == nil {
        return errors.Wrap(query.ErrNoModels, "provided nil model")
    }
    if len(relations) == 0 {
        return errors.Wrap(query.ErrNoModels, "no relation models provided")
    }
    mStruct, err := modelStruct(db)
    if err != nil {
        return err
    }
    relationField, err := mStruct.RelationByIndex(7)
    if err != nil {
        return err
    }
    relationModels := make([]mapping.Model, len(relations))
    for i := range relations {
        relationModels[i] = relations[i]
    }
    q := query.NewScope(mStruct, model)
    relationAdder, ok := db.(database.QueryRelationAdder)
    if !ok {
        return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
    }
    return relationAdder.QueryAddRelations(ctx, q, relationField, relationModels...)
}
// ClearNonPointerModelsRelation clears the 'NonPointerModels' relationship for provided models. For relationships of type:
// BelongsTo, HasOne, HasMany if foreign key is not nullable than the function would return an error.
func ClearNonPointerModelsRelation(ctx context.Context, db database.DB, models ...*tests.Car) (int64, error) {
    mStruct, err := modelStruct(db)
    if err != nil {
        return 0, err
    }
    relation, err := mStruct.RelationByIndex(7)
    if err != nil {
        return 0, err
    }
    modelInterfaces := make([]mapping.Model, len(models))
    for i := range models {
        modelInterfaces[i] = models[i]
    }
    s := query.NewScope(mStruct, modelInterfaces...)
    relationClearer, ok := db.(database.QueryRelationClearer)
    if !ok {
        return 0, errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
    }
    return relationClearer.QueryClearRelations(ctx, s, relation)
}


// GetNonPointerModels gets the 'NonPointerModels' relationship for provided input 'model'.
func GetNonPointerModels(ctx context.Context, db database.DB, model *tests.Car, relationFieldset ...string) ([]*external.Model, error) {
    if model == nil {
        return nil, errors.Wrap(query.ErrNoModels, "provided nil model")
    }
    // Check if primary key has zero value.
    if model.IsPrimaryKeyZero() {
        return nil, errors.Wrap(mapping.ErrFieldValue, "model's: 'tests.Car' primary key value has zero value")
    }
    mStruct, err := modelStruct(db)
    if err != nil {
        return nil, err
    }
    relationField, err := mStruct.RelationByIndex(7)
    if err != nil {
        return nil, err
    }

    var fields []*mapping.StructField
    relationModel := relationField.Relationship().RelatedModelStruct()
    if len(relationFieldset) == 0 {
        fields = relationModel.Fields()
    } else {
        for _, field := range relationFieldset {
            sField, ok := relationModel.FieldByName(field)
            if !ok {
                return nil, errors.Wrapf(mapping.ErrInvalidModelField, "no field: '%s' found for the model: 'external.Model'", field)
            }
            fields = append(fields, sField)
        }
    }

    relations, err := db.GetRelations(ctx, mStruct, []mapping.Model{model}, relationField, fields...)
    if err != nil {
        return nil, err
    }
    if len(relations) == 0 {
        return []*external.Model{}, nil
    }
    result := make([]*external.Model, len(relations))
    for i, relation := range relations {
        result[i] = relation.(*external.Model)
    }
    return result, nil
}


// SetNonPointerModels sets the 'NonPointerModels' relationship for provided input 'models'.
func SetNonPointerModels(ctx context.Context, db database.DB, model *tests.Car, relations ...*external.Model) error {
    if model == nil {
        return errors.Wrap(query.ErrNoModels, "provided nil model")
    }
    // Check if primary key has zero value.
    if model.IsPrimaryKeyZero() {
        return errors.Wrap(mapping.ErrFieldValue, "model's: 'tests.Car' primary key value has zero value")
    }
    mStruct, err := modelStruct(db)
    if err != nil {
        return err
    }
    relationField, err := mStruct.RelationByIndex(7)
    if err != nil {
        return err
    }
    q := query.NewScope(mStruct, model)
    if len(relations) == 0 {
        return errors.Wrap(query.ErrNoModels, "no relation models provided")
    }
    relationModels := make([]mapping.Model, len(relations))
    for i, relation := range relations {
        if relation.IsPrimaryKeyZero() {
            return errors.Wrap(mapping.ErrFieldValue, "one of relation 'NonPointerModels' model has zero value primary field")
        }
        relationModels[i] = relation
    }
    relationSetter, ok := db.(database.QueryRelationSetter)
    if !ok {
        return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationSetter interface: %T", db)
    }
    return relationSetter.QuerySetRelations(ctx, q, relationField, relationModels...)
}


// _customCarsQueryBuilder is the query builder used to create and execute
// queries for the tests.Carmodel.
type _customCarsQueryBuilder struct {
    builder database.Builder
    err error
}

// Scope returns given query scope.
func (_c *_customCarsQueryBuilder) Scope() *query.Scope {
    return _c.builder.Scope()
}

// Err returns errors that occurred during query building process.
func (_c *_customCarsQueryBuilder) Err() error {
    if _c.err != nil {
        return _c.err
    }
    return _c.builder.Err()
}

// Ctx returns the context of given query builder.
func (_c *_customCarsQueryBuilder) Ctx() context.Context {
    return _c.builder.Ctx()
}

// Count returns the number of model instances for provided query.
func (_c *_customCarsQueryBuilder) Count() (int64, error) {
    if _c.err != nil {
        return 0, _c.err
    }
    return _c.builder.Count()
}

// Insert new 'tests.Car' instance(s) into the store.
func (_c *_customCarsQueryBuilder) Insert() error {
    if _c.err != nil {
        return _c.err
    }
    return _c.builder.Insert()
}

// Update updates given 'tests.Car' instances.
func (_c *_customCarsQueryBuilder) Update() (int64, error) {
    if _c.err != nil {
        return 0, _c.err
    }
    return _c.builder.Update()
}


// Find returns all tests.Car models that matches to given query.
func (_c *_customCarsQueryBuilder) Find() ([]*tests.Car, error) {
    if _c.err != nil {
        return nil, _c.err
    }
    queryModels, err := _c.builder.Find()
    if err != nil {
        return nil, err
    }
    models := make([]*tests.Car, len(queryModels))
    for i := range queryModels {
        models[i] = queryModels[i].(*tests.Car)
    }
    return models, nil
}

// Refresh refreshes input 'tests.Car' model fields. It might be combine with the included relations.
func (_c *_customCarsQueryBuilder) Refresh() error {
    if _c.err != nil {
        return _c.err
    }
    return _c.builder.Refresh()
}

// Get returns single tests.Car model that matches given query.
// If the model is not found the function returns error of query.ErrQueryNoResult.
func (_c *_customCarsQueryBuilder) Get() (*tests.Car, error) {
    if _c.err != nil {
        return nil, _c.err
    }
    model, err := _c.builder.Get()
    if err != nil {
        return nil, err
    }
    return model.(*tests.Car), nil
}

// Delete deletes tests.Car instances that matches given query.
func (_c *_customCarsQueryBuilder) Delete() (int64, error) {
    if _c.err != nil {
        return 0, _c.err
    }
    return _c.builder.Delete()
}

// Filter adds the 'filter' to the given query.
func (_c *_customCarsQueryBuilder) Filter(filter filter.Filter) (*_customCarsQueryBuilder) {
    if _c.err != nil {
       return _c
    }
    _c.builder.Filter(filter)
    return _c
}

// Where creates query with given 'filter' and 'values'.
func (_c *_customCarsQueryBuilder) Where(filter string, values ...interface{}) (*_customCarsQueryBuilder) {
    if _c.err != nil {
        return _c
    }
    _c.builder.Where(filter, values...)
    return _c
}



// IncludeModels includes given 'relation' in the NRN_CustomCars query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (_c *_customCarsQueryBuilder) IncludeModels(modelsFieldset ...string) (*_customCarsQueryBuilder) {
    if _c.err != nil {
        return _c
    }
    relation, err := _c.builder.Scope().ModelStruct.RelationByIndex(6)
    if err != nil {
        _c.err =  errors.Wrapf(mapping.ErrInternal, "Getting 'Models' by index for model 'tests.Car' failed: %v", err)
        return _c
    }
    // check the fieldset for the relation.
    var relationFields []*mapping.StructField
    for _, field := range modelsFieldset {
        structField, ok := relation.Relationship().RelatedModelStruct().FieldByName(field)
        if !ok {
            _c.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not found for the 'external.Model' model", field)
            return _c
        }
        relationFields = append(relationFields, structField)
    }
    _c.builder.Include(relation, relationFields...)
    return _c
}

// IncludeNonPointerModels includes given 'relation' in the NRN_CustomCars query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (_c *_customCarsQueryBuilder) IncludeNonPointerModels(nonPointerModelsFieldset ...string) (*_customCarsQueryBuilder) {
    if _c.err != nil {
        return _c
    }
    relation, err := _c.builder.Scope().ModelStruct.RelationByIndex(7)
    if err != nil {
        _c.err =  errors.Wrapf(mapping.ErrInternal, "Getting 'NonPointerModels' by index for model 'tests.Car' failed: %v", err)
        return _c
    }
    // check the fieldset for the relation.
    var relationFields []*mapping.StructField
    for _, field := range nonPointerModelsFieldset {
        structField, ok := relation.Relationship().RelatedModelStruct().FieldByName(field)
        if !ok {
            _c.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not found for the 'external.Model' model", field)
            return _c
        }
        relationFields = append(relationFields, structField)
    }
    _c.builder.Include(relation, relationFields...)
    return _c
}

// Limit sets the maximum number of objects returned by the Find process,
// Returns error if the given scope has already different type of pagination.
func (_c *_customCarsQueryBuilder) Limit(limit int64) (*_customCarsQueryBuilder) {
    if _c.err != nil {
        return _c
    }
    _c.builder.Limit(limit)
    return _c
}

// Offset sets the query result's offset. It says to skip as many object's from the repository
// before beginning to return the result. 'Offset' 0 is the same as omitting the 'Offset' clause.
// Returns error if the given scope has already different type of pagination.
func (_c *_customCarsQueryBuilder) Offset(offset int64) (*_customCarsQueryBuilder) {
    if _c.err != nil {
        return _c
    }
    _c.builder.Offset(offset)
    return _c
}

// Select adds the fields to the scope's fieldset.
// Allowed fields to select:
//  - ID / id
//  - ID / id
//  - UserID / user_id
//  - Plates / plates
//  - Directory / directory
//  - EnumField / enum_field
//  - UintEnumField / uint_enum_field
func (_c *_customCarsQueryBuilder) Select(fields ...string) (*_customCarsQueryBuilder) {
    if _c.err != nil {
        return _c
    }
    var fieldSet []*mapping.StructField
    for _, field := range fields {
        structField, ok := _c.builder.Scope().ModelStruct.FieldByName(field)
        if !ok {
            _c.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not valid for model: 'NRN_CustomCars'",field)
            return _c
        }
        fieldSet = append(fieldSet, structField)
    }
    _c.builder.Select(fieldSet...)
    return _c
}

// OrderBy adds the sort fields into query scope. By default field is ordered ascending. In order to sort descending
// add '-' before the field name i.e. '-id'. The order of the fields relates to the significance of the sorting order.
// Allowed fields to sort:
//  - ID
//  - UserID
//  - Plates
//  - Directory
//  - EnumField
//  - UintEnumField
func (_c *_customCarsQueryBuilder) OrderBy(fields ...string) (*_customCarsQueryBuilder) {
    if _c.err != nil {
        return _c
    }
    sortFields := make([]query.Sort, len(fields))
    for i, field := range fields {
        if len(field) == 0 {
            _c.err = errors.Wrap(mapping.ErrInvalidModelField, "cannot set sorting order for an empty field for model: 'NRN_CustomCars'")
            return _c
        }
        var order query.SortOrder
        if field[0] == '-' {
            order = query.DescendingOrder
            field = field[1:]
        }
        structField, ok := _c.builder.Scope().ModelStruct.FieldByName(field)
        if !ok {
            _c.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not valid for model: 'NRN_CustomCars'", field)
            return _c
        }
        sortFields[i] = query.SortField{StructField: structField, SortOrder: order}
    }
    _c.builder.OrderBy(sortFields...)
    return _c
}


// AddModels adds related model Models and matches to given tests.Car.
func (_c *_customCarsQueryBuilder) AddModels(_models ...*external.Model) error {
    if _c.err != nil {
        return _c.err
    }
    relation, err := _c.builder.Scope().ModelStruct.RelationByIndex(6)
    if err != nil {
        return errors.Wrapf(mapping.ErrInternal, "getting 'Models' relation by index for model 'tests.Car' failed: %v", err)
    }
    models := make([]mapping.Model, len(_models))
    for i := range _models {
        models[i] = _models[i]
    }
    return _c.builder.AddRelations(relation, models...)
}

// AddNonPointerModels adds related model NonPointerModels and matches to given tests.Car.
func (_c *_customCarsQueryBuilder) AddNonPointerModels(_nonPointerModels ...*external.Model) error {
    if _c.err != nil {
        return _c.err
    }
    relation, err := _c.builder.Scope().ModelStruct.RelationByIndex(7)
    if err != nil {
        return errors.Wrapf(mapping.ErrInternal, "getting 'NonPointerModels' relation by index for model 'tests.Car' failed: %v", err)
    }
    models := make([]mapping.Model, len(_nonPointerModels))
    for i := range _nonPointerModels {
        models[i] = _nonPointerModels[i]
    }
    return _c.builder.AddRelations(relation, models...)
}


// SetModels sets related model Models and matches to given tests.Car.
func (_c *_customCarsQueryBuilder) SetModels(_models ...*external.Model) error {
    if _c.err != nil {
        return _c.err
    }
    relation, err := _c.builder.Scope().ModelStruct.RelationByIndex(6)
    if err != nil {
        return errors.Wrapf(mapping.ErrInternal, "getting 'Models' relation by index for model 'tests.Car' failed: %v", err)
    }
    models := make([]mapping.Model, len(_models))
    for i := range _models {
        models[i] = _models[i]
    }
    return _c.builder.SetRelations(relation, models...)
}

// SetNonPointerModels sets related model NonPointerModels and matches to given tests.Car.
func (_c *_customCarsQueryBuilder) SetNonPointerModels(_nonPointerModels ...*external.Model) error {
    if _c.err != nil {
        return _c.err
    }
    relation, err := _c.builder.Scope().ModelStruct.RelationByIndex(7)
    if err != nil {
        return errors.Wrapf(mapping.ErrInternal, "getting 'NonPointerModels' relation by index for model 'tests.Car' failed: %v", err)
    }
    models := make([]mapping.Model, len(_nonPointerModels))
    for i := range _nonPointerModels {
        models[i] = _nonPointerModels[i]
    }
    return _c.builder.SetRelations(relation, models...)
}


// RemoveModels removes related model Models and matches to given tests.Car.
func (_c *_customCarsQueryBuilder) RemoveModels() (int64, error) {
    if _c.err != nil {
        return 0, _c.err
    }
    relation, err := _c.builder.Scope().ModelStruct.RelationByIndex(6)
    if err != nil {
        return 0, errors.Wrapf(mapping.ErrInternal, "getting 'Models' relation by index for model 'tests.Car' failed: %v", err)
    }
    return _c.builder.RemoveRelations(relation)
}

// RemoveNonPointerModels removes related model NonPointerModels and matches to given tests.Car.
func (_c *_customCarsQueryBuilder) RemoveNonPointerModels() (int64, error) {
    if _c.err != nil {
        return 0, _c.err
    }
    relation, err := _c.builder.Scope().ModelStruct.RelationByIndex(7)
    if err != nil {
        return 0, errors.Wrapf(mapping.ErrInternal, "getting 'NonPointerModels' relation by index for model 'tests.Car' failed: %v", err)
    }
    return _c.builder.RemoveRelations(relation)
}