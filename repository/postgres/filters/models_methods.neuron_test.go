// Code generated by neuron/generator. DO NOT EDIT.
// This file was generated at:
// Tue, 19 May 2020 17:09:54 +0200

package filters

import (
	"github.com/neuronlabs/neuron/errors"
	"github.com/neuronlabs/neuron/mapping"
)

// Compile time check if QueryModel implements mapping.Model interface.
var _ mapping.Model = &QueryModel{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'QueryModel'.
func (q *QueryModel) NeuronCollectionName() string {
	return "query_models"
}

// IsPrimaryKeyZero implements query.Model interface method.
func (q *QueryModel) IsPrimaryKeyZero() bool {
	return q.ID == 0
}

// GetPrimaryKeyValue implements query.Model interface method.
func (q *QueryModel) GetPrimaryKeyValue() interface{} {
	return q.ID
}

// GetPrimaryKeyAddress implements query.Model interface method.
func (q *QueryModel) GetPrimaryKeyAddress() interface{} {
	return &q.ID
}

// GetPrimaryKeyHashableValue implements query.Model interface method.
func (q *QueryModel) GetPrimaryKeyHashableValue() interface{} {
	return q.ID
}

// GetPrimaryKeyZeroValue implements query.Model interface method.
func (q *QueryModel) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements query.Model interface method.
func (q *QueryModel) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(int); ok {
		q.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int8:
		q.ID = int(valueType)
	case int16:
		q.ID = int(valueType)
	case int32:
		q.ID = int(valueType)
	case int64:
		q.ID = int(valueType)
	case uint:
		q.ID = int(valueType)
	case uint8:
		q.ID = int(valueType)
	case uint16:
		q.ID = int(valueType)
	case uint32:
		q.ID = int(valueType)
	case uint64:
		q.ID = int(valueType)
	case float32:
		q.ID = int(valueType)
	case float64:
		q.ID = int(valueType)
	default:
		return errors.Newf(mapping.ClassFieldValue, "provided invalid value: '%T' for the primary field for model: 'QueryModel'", value)
	}
	return nil
}

// Compile time check if QueryModel implements mapping.Fielder interface.
var _ mapping.Fielder = &QueryModel{}

// GetFieldsAddress gets the address of provided 'field'.
func (q *QueryModel) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &q.ID, nil
	case 1: // StringAttr
		return &q.StringAttr, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: QueryModel'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (q *QueryModel) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // StringAttr
		return "", nil
	default:
		return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (q *QueryModel) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return q.ID == 0, nil
	case 1: // StringAttr
		return q.StringAttr == "", nil
	}
	return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (q *QueryModel) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		q.ID = 0
	case 1: // StringAttr
		q.StringAttr = ""
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (q *QueryModel) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return q.ID, nil
	case 1: // StringAttr
		return q.StringAttr, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: 'QueryModel'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (q *QueryModel) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return q.ID, nil
	case 1: // StringAttr
		return q.StringAttr, nil
	}
	return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: QueryModel'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (q *QueryModel) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(int); ok {
			q.ID = v
			return nil
		}
		switch v := value.(type) {
		case int8:
			q.ID = int(v)
		case int16:
			q.ID = int(v)
		case int32:
			q.ID = int(v)
		case int64:
			q.ID = int(v)
		case uint:
			q.ID = int(v)
		case uint8:
			q.ID = int(v)
		case uint16:
			q.ID = int(v)
		case uint32:
			q.ID = int(v)
		case uint64:
			q.ID = int(v)
		case float32:
			q.ID = int(v)
		case float64:
			q.ID = int(v)
		default:
			return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // StringAttr
		if v, ok := value.(string); ok {
			q.StringAttr = v
			return nil
		}
		// Check alternate types for the StringAttr.
		if v, ok := value.([]byte); ok {
			q.StringAttr = string(v)
			return nil
		}
		return errors.Newf(mapping.ClassFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: 'QueryModel'", field.Name())
	}
}
