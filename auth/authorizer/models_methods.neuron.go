// Code generated by neuron/generator. DO NOT EDIT.
// This file was generated at:
// Fri, 28 Aug 2020 20:26:47 +0200

package authorizer

import (
	"strconv"
	"time"

	"github.com/google/uuid"
	"github.com/neuronlabs/neuron/errors"
	"github.com/neuronlabs/neuron/mapping"
	"github.com/neuronlabs/neuron/query"
)

// Neuron_Models stores all generated models in this package.
var Neuron_Models = []mapping.Model{
	&AccountRoles{},
	&AuthorizeScope{},
	&Role{},
	&RoleScopes{},
}

// Compile time check if AccountRoles implements mapping.Model interface.
var _ mapping.Model = &AccountRoles{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'AccountRoles'.
func (a *AccountRoles) NeuronCollectionName() string {
	return "account_roles"
}

// IsPrimaryKeyZero implements mapping.Model interface method.
func (a *AccountRoles) IsPrimaryKeyZero() bool {
	return a.ID == uuid.UUID([16]byte{})
}

// GetPrimaryKeyValue implements mapping.Model interface method.
func (a *AccountRoles) GetPrimaryKeyValue() interface{} {
	return a.ID
}

// GetPrimaryKeyStringValue implements mapping.Model interface method.
func (a *AccountRoles) GetPrimaryKeyStringValue() (string, error) {
	id, err := a.ID.MarshalText()
	if err != nil {
		return "", errors.Wrapf(mapping.ErrFieldValue, "invalid primary field value: %v to parse string. Err: %v", a.ID, err)
	}
	return string(id), nil
}

// GetPrimaryKeyAddress implements mapping.Model interface method.
func (a *AccountRoles) GetPrimaryKeyAddress() interface{} {
	return &a.ID
}

// GetPrimaryKeyHashableValue implements mapping.Model interface method.
func (a *AccountRoles) GetPrimaryKeyHashableValue() interface{} {
	return a.ID
}

// GetPrimaryKeyZeroValue implements mapping.Model interface method.
func (a *AccountRoles) GetPrimaryKeyZeroValue() interface{} {
	return uuid.UUID([16]byte{})
}

// SetPrimaryKey implements mapping.Model interface method.
func (a *AccountRoles) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(uuid.UUID); ok {
		a.ID = v
		return nil
	} else if v, ok := value.([16]byte); ok {
		a.ID = uuid.UUID(v)
	}
	return errors.Wrapf(mapping.ErrFieldValue, "provided invalid value: '%T' for the primary field for model: '%T'",
		value, a)
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (a *AccountRoles) SetPrimaryKeyStringValue(value string) error {
	if err := a.ID.UnmarshalText([]byte(value)); err != nil {
		return errors.Wrapf(mapping.ErrFieldValue, "invalid primary field value: %v to parse string. Err: %v", a.ID, err)
	}
	return nil
}

// SetFrom implements FromSetter interface.
func (a *AccountRoles) SetFrom(model mapping.Model) error {
	if model == nil {
		return errors.Wrap(query.ErrInvalidInput, "provided nil model to set from")
	}
	from, ok := model.(*AccountRoles)
	if !ok {
		return errors.WrapDetf(mapping.ErrModelNotMatch, "provided model doesn't match the input: %T", model)
	}
	*a = *from
	return nil
}

// Compile time check if AccountRoles implements mapping.Fielder interface.
var _ mapping.Fielder = &AccountRoles{}

// GetFieldsAddress gets the address of provided 'field'.
func (a *AccountRoles) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &a.ID, nil
	case 1: // CreatedAt
		return &a.CreatedAt, nil
	case 3: // RoleID
		return &a.RoleID, nil
	case 4: // AccountID
		return &a.AccountID, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: AccountRoles'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (a *AccountRoles) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return uuid.UUID([16]byte{}), nil
	case 1: // CreatedAt
		return time.Time{}, nil
	case 3: // RoleID
		return 0, nil
	case 4: // AccountID
		return "", nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (a *AccountRoles) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return a.ID == uuid.UUID([16]byte{}), nil
	case 1: // CreatedAt
		return a.CreatedAt == time.Time{}, nil
	case 3: // RoleID
		return a.RoleID == 0, nil
	case 4: // AccountID
		return a.AccountID == "", nil
	}
	return false, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (a *AccountRoles) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		a.ID = uuid.UUID([16]byte{})
	case 1: // CreatedAt
		a.CreatedAt = time.Time{}
	case 3: // RoleID
		a.RoleID = 0
	case 4: // AccountID
		a.AccountID = ""
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (a *AccountRoles) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return a.ID, nil
	case 1: // CreatedAt
		return a.CreatedAt, nil
	case 3: // RoleID
		return a.RoleID, nil
	case 4: // AccountID
		return a.AccountID, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: 'AccountRoles'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (a *AccountRoles) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return a.ID, nil
	case 1: // CreatedAt
		return a.CreatedAt, nil
	case 3: // RoleID
		return a.RoleID, nil
	case 4: // AccountID
		return a.AccountID, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: AccountRoles'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (a *AccountRoles) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(uuid.UUID); ok {
			a.ID = v
			return nil
		}
		if generic, ok := value.([]interface{}); ok {
			if len(generic) > 16 {
				return errors.Wrapf(mapping.ErrFieldValue, "provided too many values for the field: 'ID")
			}
			for i, item := range generic {
				if v, ok := item.(byte); ok {
					a.ID[i] = v
					continue
				}

			}
			return nil
		}
		// Checked wrapped types.
		if v, ok := value.([16]byte); ok {
			a.ID = uuid.UUID(v)
			return nil
		}
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 1: // CreatedAt
		if v, ok := value.(time.Time); ok {
			a.CreatedAt = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			a.CreatedAt = time.Time{}
			return nil
		}

		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // RoleID
		if v, ok := value.(uint); ok {
			a.RoleID = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			a.RoleID = 0
			return nil
		}

		switch v := value.(type) {
		case int:
			a.RoleID = uint(v)
		case int8:
			a.RoleID = uint(v)
		case int16:
			a.RoleID = uint(v)
		case int32:
			a.RoleID = uint(v)
		case int64:
			a.RoleID = uint(v)
		case uint8:
			a.RoleID = uint(v)
		case uint16:
			a.RoleID = uint(v)
		case uint32:
			a.RoleID = uint(v)
		case uint64:
			a.RoleID = uint(v)
		case float32:
			a.RoleID = uint(v)
		case float64:
			a.RoleID = uint(v)
		default:
			return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 4: // AccountID
		if v, ok := value.(string); ok {
			a.AccountID = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			a.AccountID = ""
			return nil
		}

		// Check alternate types for the AccountID.
		if v, ok := value.([]byte); ok {
			a.AccountID = string(v)
			return nil
		}
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for the model: 'AccountRoles'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (a *AccountRoles) ParseFieldsStringValue(field *mapping.StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		temp := a.ID
		if err := a.ID.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'ID' value: '%v' to parse string. Err: %v", a.ID, err)
		}
		bt, err := a.ID.MarshalText()
		if err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'ID' value: '%v' to parse string. Err: %v", a.ID, err)
		}
		a.ID = temp
		return string(bt), nil
	case 1: // CreatedAt
		temp := a.CreatedAt
		if err := a.CreatedAt.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'CreatedAt' value: '%v' to parse string. Err: %v", a.CreatedAt, err)
		}
		bt, err := a.CreatedAt.MarshalText()
		if err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'CreatedAt' value: '%v' to parse string. Err: %v", a.CreatedAt, err)
		}
		a.CreatedAt = temp
		return string(bt), nil
	case 3: // RoleID
		return strconv.ParseUint(value, 10, mapping.IntegerBitSize)
	case 4: // AccountID
		return value, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: AccountRoles'", field.Name())
}

// Compile time check if AccountRoles implements mapping.SingleRelationer interface.
var _ mapping.SingleRelationer = &AccountRoles{}

// GetRelationModel implements mapping.SingleRelationer interface.
func (a *AccountRoles) GetRelationModel(relation *mapping.StructField) (mapping.Model, error) {
	switch relation.Index[0] {
	case 2: // Role
		if a.Role == nil {
			return nil, nil
		}
		return a.Role, nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, a)
	}
}

// SetRelationModel implements mapping.SingleRelationer interface.
func (a *AccountRoles) SetRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 2: // Role
		if model == nil {
			a.Role = nil
			return nil
		} else if role, ok := model.(*Role); ok {
			a.Role = role
			return nil
		}
		return errors.Wrapf(mapping.ErrInvalidRelationValue, "provided invalid model value: '%T' for relation Role", model)
	default:
		return errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, a)
	}
}

// Compile time check if AuthorizeScope implements mapping.Model interface.
var _ mapping.Model = &AuthorizeScope{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'AuthorizeScope'.
func (a *AuthorizeScope) NeuronCollectionName() string {
	return "authorize_scopes"
}

// IsPrimaryKeyZero implements mapping.Model interface method.
func (a *AuthorizeScope) IsPrimaryKeyZero() bool {
	return a.ID == 0
}

// GetPrimaryKeyValue implements mapping.Model interface method.
func (a *AuthorizeScope) GetPrimaryKeyValue() interface{} {
	return a.ID
}

// GetPrimaryKeyStringValue implements mapping.Model interface method.
func (a *AuthorizeScope) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatUint(uint64(a.ID), 10), nil
}

// GetPrimaryKeyAddress implements mapping.Model interface method.
func (a *AuthorizeScope) GetPrimaryKeyAddress() interface{} {
	return &a.ID
}

// GetPrimaryKeyHashableValue implements mapping.Model interface method.
func (a *AuthorizeScope) GetPrimaryKeyHashableValue() interface{} {
	return a.ID
}

// GetPrimaryKeyZeroValue implements mapping.Model interface method.
func (a *AuthorizeScope) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements mapping.Model interface method.
func (a *AuthorizeScope) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(uint); ok {
		a.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int:
		a.ID = uint(valueType)
	case int8:
		a.ID = uint(valueType)
	case int16:
		a.ID = uint(valueType)
	case int32:
		a.ID = uint(valueType)
	case int64:
		a.ID = uint(valueType)
	case uint8:
		a.ID = uint(valueType)
	case uint16:
		a.ID = uint(valueType)
	case uint32:
		a.ID = uint(valueType)
	case uint64:
		a.ID = uint(valueType)
	case float32:
		a.ID = uint(valueType)
	case float64:
		a.ID = uint(valueType)
	default:
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'AuthorizeScope'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (a *AuthorizeScope) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseUint(value, 10, mapping.IntegerBitSize)
	if err != nil {
		return err
	}
	a.ID = uint(tmp)
	return nil
}

// SetFrom implements FromSetter interface.
func (a *AuthorizeScope) SetFrom(model mapping.Model) error {
	if model == nil {
		return errors.Wrap(query.ErrInvalidInput, "provided nil model to set from")
	}
	from, ok := model.(*AuthorizeScope)
	if !ok {
		return errors.WrapDetf(mapping.ErrModelNotMatch, "provided model doesn't match the input: %T", model)
	}
	*a = *from
	return nil
}

// Compile time check if AuthorizeScope implements mapping.Fielder interface.
var _ mapping.Fielder = &AuthorizeScope{}

// GetFieldsAddress gets the address of provided 'field'.
func (a *AuthorizeScope) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &a.ID, nil
	case 1: // CreatedAt
		return &a.CreatedAt, nil
	case 2: // DeletedAt
		return &a.DeletedAt, nil
	case 3: // Name
		return &a.Name, nil
	case 4: // Description
		return &a.Description, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: AuthorizeScope'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (a *AuthorizeScope) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // CreatedAt
		return time.Time{}, nil
	case 2: // DeletedAt
		return nil, nil
	case 3: // Name
		return "", nil
	case 4: // Description
		return "", nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (a *AuthorizeScope) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return a.ID == 0, nil
	case 1: // CreatedAt
		return a.CreatedAt == time.Time{}, nil
	case 2: // DeletedAt
		return a.DeletedAt == nil, nil
	case 3: // Name
		return a.Name == "", nil
	case 4: // Description
		return a.Description == "", nil
	}
	return false, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (a *AuthorizeScope) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		a.ID = 0
	case 1: // CreatedAt
		a.CreatedAt = time.Time{}
	case 2: // DeletedAt
		a.DeletedAt = nil
	case 3: // Name
		a.Name = ""
	case 4: // Description
		a.Description = ""
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (a *AuthorizeScope) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return a.ID, nil
	case 1: // CreatedAt
		return a.CreatedAt, nil
	case 2: // DeletedAt
		if a.DeletedAt == nil {
			return nil, nil
		}
		return *a.DeletedAt, nil
	case 3: // Name
		return a.Name, nil
	case 4: // Description
		return a.Description, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: 'AuthorizeScope'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (a *AuthorizeScope) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return a.ID, nil
	case 1: // CreatedAt
		return a.CreatedAt, nil
	case 2: // DeletedAt
		return a.DeletedAt, nil
	case 3: // Name
		return a.Name, nil
	case 4: // Description
		return a.Description, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: AuthorizeScope'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (a *AuthorizeScope) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(uint); ok {
			a.ID = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			a.ID = 0
			return nil
		}

		switch v := value.(type) {
		case int:
			a.ID = uint(v)
		case int8:
			a.ID = uint(v)
		case int16:
			a.ID = uint(v)
		case int32:
			a.ID = uint(v)
		case int64:
			a.ID = uint(v)
		case uint8:
			a.ID = uint(v)
		case uint16:
			a.ID = uint(v)
		case uint32:
			a.ID = uint(v)
		case uint64:
			a.ID = uint(v)
		case float32:
			a.ID = uint(v)
		case float64:
			a.ID = uint(v)
		default:
			return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // CreatedAt
		if v, ok := value.(time.Time); ok {
			a.CreatedAt = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			a.CreatedAt = time.Time{}
			return nil
		}

		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // DeletedAt
		if value == nil {
			a.DeletedAt = nil
			return nil
		}
		if v, ok := value.(*time.Time); ok {
			a.DeletedAt = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(time.Time); ok {
			a.DeletedAt = &v
			return nil
		}

		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // Name
		if v, ok := value.(string); ok {
			a.Name = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			a.Name = ""
			return nil
		}

		// Check alternate types for the Name.
		if v, ok := value.([]byte); ok {
			a.Name = string(v)
			return nil
		}
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 4: // Description
		if v, ok := value.(string); ok {
			a.Description = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			a.Description = ""
			return nil
		}

		// Check alternate types for the Description.
		if v, ok := value.([]byte); ok {
			a.Description = string(v)
			return nil
		}
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for the model: 'AuthorizeScope'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (a *AuthorizeScope) ParseFieldsStringValue(field *mapping.StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseUint(value, 10, mapping.IntegerBitSize)
	case 1: // CreatedAt
		temp := a.CreatedAt
		if err := a.CreatedAt.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'CreatedAt' value: '%v' to parse string. Err: %v", a.CreatedAt, err)
		}
		bt, err := a.CreatedAt.MarshalText()
		if err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'CreatedAt' value: '%v' to parse string. Err: %v", a.CreatedAt, err)
		}
		a.CreatedAt = temp
		return string(bt), nil
	case 2: // DeletedAt
		var base time.Time
		temp := &base
		if err := temp.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'DeletedAt' value: '%v' to parse string. Err: %v", a.DeletedAt, err)
		}
		bt, err := temp.MarshalText()
		if err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'DeletedAt' value: '%v' to parse string. Err: %v", a.DeletedAt, err)
		}

		return string(bt), nil
	case 3: // Name
		return value, nil
	case 4: // Description
		return value, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: AuthorizeScope'", field.Name())
}

// Compile time check for the mapping.MultiRelationer interface implementation.
var _ mapping.MultiRelationer = &AuthorizeScope{}

// AddRelationModel implements mapping.MultiRelationer interface.
func (a *AuthorizeScope) AddRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 5: // Roles
		role, ok := model.(*Role)
		if !ok {
			return errors.Wrapf(mapping.ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Roles'", model)
		}
		a.Roles = append(a.Roles, role)
	default:
		return errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%T' for the model 'AuthorizeScope'", model)
	}
	return nil
}

// GetRelationModels implements mapping.MultiRelationer interface.
func (a *AuthorizeScope) GetRelationModels(relation *mapping.StructField) (models []mapping.Model, err error) {
	switch relation.Index[0] {
	case 5: // Roles
		for _, model := range a.Roles {
			models = append(models, model)
		}
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, a)
	}
	return models, nil
}

// GetRelationModelAt implements mapping.MultiRelationer interface.
func (a *AuthorizeScope) GetRelationModelAt(relation *mapping.StructField, index int) (models mapping.Model, err error) {
	switch relation.Index[0] {
	case 5: // Roles
		if index > len(a.Roles)-1 {
			return nil, errors.Wrapf(mapping.ErrInvalidRelationIndex, "index out of possible range. Model: 'AuthorizeScope', Field Roles")
		}
		return a.Roles[index], nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, a)
	}
	return models, nil
}

// GetRelationLen implements mapping.MultiRelationer interface.
func (a *AuthorizeScope) GetRelationLen(relation *mapping.StructField) (int, error) {
	switch relation.Index[0] {
	case 5: // Roles
		return len(a.Roles), nil
	default:
		return 0, errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, a)
	}
}

// SetRelationModels implements mapping.MultiRelationer interface.
func (a *AuthorizeScope) SetRelationModels(relation *mapping.StructField, models ...mapping.Model) error {
	switch relation.Index[0] {
	case 5: // Roles
		temp := make([]*Role, len(models))
		for i, model := range models {
			role, ok := model.(*Role)
			if !ok {
				return errors.Wrapf(mapping.ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Roles'", model)
			}
			temp[i] = role
		}
		a.Roles = temp
	default:
		return errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for the model 'AuthorizeScope'", relation.String())
	}
	return nil
}

// Compile time check if Role implements mapping.Model interface.
var _ mapping.Model = &Role{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'Role'.
func (r *Role) NeuronCollectionName() string {
	return "roles"
}

// IsPrimaryKeyZero implements mapping.Model interface method.
func (r *Role) IsPrimaryKeyZero() bool {
	return r.ID == 0
}

// GetPrimaryKeyValue implements mapping.Model interface method.
func (r *Role) GetPrimaryKeyValue() interface{} {
	return r.ID
}

// GetPrimaryKeyStringValue implements mapping.Model interface method.
func (r *Role) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatUint(uint64(r.ID), 10), nil
}

// GetPrimaryKeyAddress implements mapping.Model interface method.
func (r *Role) GetPrimaryKeyAddress() interface{} {
	return &r.ID
}

// GetPrimaryKeyHashableValue implements mapping.Model interface method.
func (r *Role) GetPrimaryKeyHashableValue() interface{} {
	return r.ID
}

// GetPrimaryKeyZeroValue implements mapping.Model interface method.
func (r *Role) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements mapping.Model interface method.
func (r *Role) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(uint); ok {
		r.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int:
		r.ID = uint(valueType)
	case int8:
		r.ID = uint(valueType)
	case int16:
		r.ID = uint(valueType)
	case int32:
		r.ID = uint(valueType)
	case int64:
		r.ID = uint(valueType)
	case uint8:
		r.ID = uint(valueType)
	case uint16:
		r.ID = uint(valueType)
	case uint32:
		r.ID = uint(valueType)
	case uint64:
		r.ID = uint(valueType)
	case float32:
		r.ID = uint(valueType)
	case float64:
		r.ID = uint(valueType)
	default:
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'Role'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (r *Role) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseUint(value, 10, mapping.IntegerBitSize)
	if err != nil {
		return err
	}
	r.ID = uint(tmp)
	return nil
}

// SetFrom implements FromSetter interface.
func (r *Role) SetFrom(model mapping.Model) error {
	if model == nil {
		return errors.Wrap(query.ErrInvalidInput, "provided nil model to set from")
	}
	from, ok := model.(*Role)
	if !ok {
		return errors.WrapDetf(mapping.ErrModelNotMatch, "provided model doesn't match the input: %T", model)
	}
	*r = *from
	return nil
}

// Compile time check if Role implements mapping.Fielder interface.
var _ mapping.Fielder = &Role{}

// GetFieldsAddress gets the address of provided 'field'.
func (r *Role) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &r.ID, nil
	case 1: // CreatedAt
		return &r.CreatedAt, nil
	case 2: // UpdatedAt
		return &r.UpdatedAt, nil
	case 3: // DeletedAt
		return &r.DeletedAt, nil
	case 4: // Hierarchy
		return &r.Hierarchy, nil
	case 5: // Name
		return &r.Name, nil
	case 6: // Description
		return &r.Description, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: Role'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (r *Role) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // CreatedAt
		return time.Time{}, nil
	case 2: // UpdatedAt
		return nil, nil
	case 3: // DeletedAt
		return nil, nil
	case 4: // Hierarchy
		return 0, nil
	case 5: // Name
		return "", nil
	case 6: // Description
		return "", nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (r *Role) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return r.ID == 0, nil
	case 1: // CreatedAt
		return r.CreatedAt == time.Time{}, nil
	case 2: // UpdatedAt
		return r.UpdatedAt == nil, nil
	case 3: // DeletedAt
		return r.DeletedAt == nil, nil
	case 4: // Hierarchy
		return r.Hierarchy == 0, nil
	case 5: // Name
		return r.Name == "", nil
	case 6: // Description
		return r.Description == "", nil
	}
	return false, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (r *Role) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		r.ID = 0
	case 1: // CreatedAt
		r.CreatedAt = time.Time{}
	case 2: // UpdatedAt
		r.UpdatedAt = nil
	case 3: // DeletedAt
		r.DeletedAt = nil
	case 4: // Hierarchy
		r.Hierarchy = 0
	case 5: // Name
		r.Name = ""
	case 6: // Description
		r.Description = ""
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (r *Role) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return r.ID, nil
	case 1: // CreatedAt
		return r.CreatedAt, nil
	case 2: // UpdatedAt
		if r.UpdatedAt == nil {
			return nil, nil
		}
		return *r.UpdatedAt, nil
	case 3: // DeletedAt
		if r.DeletedAt == nil {
			return nil, nil
		}
		return *r.DeletedAt, nil
	case 4: // Hierarchy
		return r.Hierarchy, nil
	case 5: // Name
		return r.Name, nil
	case 6: // Description
		return r.Description, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: 'Role'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (r *Role) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return r.ID, nil
	case 1: // CreatedAt
		return r.CreatedAt, nil
	case 2: // UpdatedAt
		return r.UpdatedAt, nil
	case 3: // DeletedAt
		return r.DeletedAt, nil
	case 4: // Hierarchy
		return r.Hierarchy, nil
	case 5: // Name
		return r.Name, nil
	case 6: // Description
		return r.Description, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: Role'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (r *Role) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(uint); ok {
			r.ID = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			r.ID = 0
			return nil
		}

		switch v := value.(type) {
		case int:
			r.ID = uint(v)
		case int8:
			r.ID = uint(v)
		case int16:
			r.ID = uint(v)
		case int32:
			r.ID = uint(v)
		case int64:
			r.ID = uint(v)
		case uint8:
			r.ID = uint(v)
		case uint16:
			r.ID = uint(v)
		case uint32:
			r.ID = uint(v)
		case uint64:
			r.ID = uint(v)
		case float32:
			r.ID = uint(v)
		case float64:
			r.ID = uint(v)
		default:
			return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // CreatedAt
		if v, ok := value.(time.Time); ok {
			r.CreatedAt = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			r.CreatedAt = time.Time{}
			return nil
		}

		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // UpdatedAt
		if value == nil {
			r.UpdatedAt = nil
			return nil
		}
		if v, ok := value.(*time.Time); ok {
			r.UpdatedAt = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(time.Time); ok {
			r.UpdatedAt = &v
			return nil
		}

		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 3: // DeletedAt
		if value == nil {
			r.DeletedAt = nil
			return nil
		}
		if v, ok := value.(*time.Time); ok {
			r.DeletedAt = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(time.Time); ok {
			r.DeletedAt = &v
			return nil
		}

		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 4: // Hierarchy
		if v, ok := value.(int); ok {
			r.Hierarchy = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			r.Hierarchy = 0
			return nil
		}

		switch v := value.(type) {
		case int8:
			r.Hierarchy = int(v)
		case int16:
			r.Hierarchy = int(v)
		case int32:
			r.Hierarchy = int(v)
		case int64:
			r.Hierarchy = int(v)
		case uint:
			r.Hierarchy = int(v)
		case uint8:
			r.Hierarchy = int(v)
		case uint16:
			r.Hierarchy = int(v)
		case uint32:
			r.Hierarchy = int(v)
		case uint64:
			r.Hierarchy = int(v)
		case float32:
			r.Hierarchy = int(v)
		case float64:
			r.Hierarchy = int(v)
		default:
			return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 5: // Name
		if v, ok := value.(string); ok {
			r.Name = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			r.Name = ""
			return nil
		}

		// Check alternate types for the Name.
		if v, ok := value.([]byte); ok {
			r.Name = string(v)
			return nil
		}
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 6: // Description
		if v, ok := value.(string); ok {
			r.Description = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			r.Description = ""
			return nil
		}

		// Check alternate types for the Description.
		if v, ok := value.([]byte); ok {
			r.Description = string(v)
			return nil
		}
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for the model: 'Role'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (r *Role) ParseFieldsStringValue(field *mapping.StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseUint(value, 10, mapping.IntegerBitSize)
	case 1: // CreatedAt
		temp := r.CreatedAt
		if err := r.CreatedAt.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'CreatedAt' value: '%v' to parse string. Err: %v", r.CreatedAt, err)
		}
		bt, err := r.CreatedAt.MarshalText()
		if err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'CreatedAt' value: '%v' to parse string. Err: %v", r.CreatedAt, err)
		}
		r.CreatedAt = temp
		return string(bt), nil
	case 2: // UpdatedAt
		var base time.Time
		temp := &base
		if err := temp.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'UpdatedAt' value: '%v' to parse string. Err: %v", r.UpdatedAt, err)
		}
		bt, err := temp.MarshalText()
		if err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'UpdatedAt' value: '%v' to parse string. Err: %v", r.UpdatedAt, err)
		}

		return string(bt), nil
	case 3: // DeletedAt
		var base time.Time
		temp := &base
		if err := temp.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'DeletedAt' value: '%v' to parse string. Err: %v", r.DeletedAt, err)
		}
		bt, err := temp.MarshalText()
		if err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'DeletedAt' value: '%v' to parse string. Err: %v", r.DeletedAt, err)
		}

		return string(bt), nil
	case 4: // Hierarchy
		return strconv.ParseInt(value, 10, mapping.IntegerBitSize)
	case 5: // Name
		return value, nil
	case 6: // Description
		return value, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: Role'", field.Name())
}

// Compile time check for the mapping.MultiRelationer interface implementation.
var _ mapping.MultiRelationer = &Role{}

// AddRelationModel implements mapping.MultiRelationer interface.
func (r *Role) AddRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 7: // Accounts
		accountRoles, ok := model.(*AccountRoles)
		if !ok {
			return errors.Wrapf(mapping.ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Accounts'", model)
		}
		r.Accounts = append(r.Accounts, accountRoles)
	case 8: // Scopes
		authorizeScope, ok := model.(*AuthorizeScope)
		if !ok {
			return errors.Wrapf(mapping.ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Scopes'", model)
		}
		r.Scopes = append(r.Scopes, authorizeScope)
	default:
		return errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%T' for the model 'Role'", model)
	}
	return nil
}

// GetRelationModels implements mapping.MultiRelationer interface.
func (r *Role) GetRelationModels(relation *mapping.StructField) (models []mapping.Model, err error) {
	switch relation.Index[0] {
	case 7: // Accounts
		for _, model := range r.Accounts {
			models = append(models, model)
		}
	case 8: // Scopes
		for _, model := range r.Scopes {
			models = append(models, model)
		}
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, r)
	}
	return models, nil
}

// GetRelationModelAt implements mapping.MultiRelationer interface.
func (r *Role) GetRelationModelAt(relation *mapping.StructField, index int) (models mapping.Model, err error) {
	switch relation.Index[0] {
	case 7: // Accounts
		if index > len(r.Accounts)-1 {
			return nil, errors.Wrapf(mapping.ErrInvalidRelationIndex, "index out of possible range. Model: 'Role', Field Accounts")
		}
		return r.Accounts[index], nil
	case 8: // Scopes
		if index > len(r.Scopes)-1 {
			return nil, errors.Wrapf(mapping.ErrInvalidRelationIndex, "index out of possible range. Model: 'Role', Field Scopes")
		}
		return r.Scopes[index], nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, r)
	}
	return models, nil
}

// GetRelationLen implements mapping.MultiRelationer interface.
func (r *Role) GetRelationLen(relation *mapping.StructField) (int, error) {
	switch relation.Index[0] {
	case 7: // Accounts
		return len(r.Accounts), nil
	case 8: // Scopes
		return len(r.Scopes), nil
	default:
		return 0, errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, r)
	}
}

// SetRelationModels implements mapping.MultiRelationer interface.
func (r *Role) SetRelationModels(relation *mapping.StructField, models ...mapping.Model) error {
	switch relation.Index[0] {
	case 7: // Accounts
		temp := make([]*AccountRoles, len(models))
		for i, model := range models {
			accountRoles, ok := model.(*AccountRoles)
			if !ok {
				return errors.Wrapf(mapping.ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Accounts'", model)
			}
			temp[i] = accountRoles
		}
		r.Accounts = temp
	case 8: // Scopes
		temp := make([]*AuthorizeScope, len(models))
		for i, model := range models {
			authorizeScope, ok := model.(*AuthorizeScope)
			if !ok {
				return errors.Wrapf(mapping.ErrInvalidRelationValue, "provided invalid value type: '%T'  for the field: 'Scopes'", model)
			}
			temp[i] = authorizeScope
		}
		r.Scopes = temp
	default:
		return errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for the model 'Role'", relation.String())
	}
	return nil
}

// Compile time check if RoleScopes implements mapping.Model interface.
var _ mapping.Model = &RoleScopes{}

// NeuronCollectionName implements mapping.Model interface method.
// Returns the name of the collection for the 'RoleScopes'.
func (r *RoleScopes) NeuronCollectionName() string {
	return "role_scopes"
}

// IsPrimaryKeyZero implements mapping.Model interface method.
func (r *RoleScopes) IsPrimaryKeyZero() bool {
	return r.ID == 0
}

// GetPrimaryKeyValue implements mapping.Model interface method.
func (r *RoleScopes) GetPrimaryKeyValue() interface{} {
	return r.ID
}

// GetPrimaryKeyStringValue implements mapping.Model interface method.
func (r *RoleScopes) GetPrimaryKeyStringValue() (string, error) {
	return strconv.FormatUint(r.ID, 10), nil
}

// GetPrimaryKeyAddress implements mapping.Model interface method.
func (r *RoleScopes) GetPrimaryKeyAddress() interface{} {
	return &r.ID
}

// GetPrimaryKeyHashableValue implements mapping.Model interface method.
func (r *RoleScopes) GetPrimaryKeyHashableValue() interface{} {
	return r.ID
}

// GetPrimaryKeyZeroValue implements mapping.Model interface method.
func (r *RoleScopes) GetPrimaryKeyZeroValue() interface{} {
	return 0
}

// SetPrimaryKey implements mapping.Model interface method.
func (r *RoleScopes) SetPrimaryKeyValue(value interface{}) error {
	if v, ok := value.(uint64); ok {
		r.ID = v
		return nil
	}
	// Check alternate types for given field.
	switch valueType := value.(type) {
	case int:
		r.ID = uint64(valueType)
	case int8:
		r.ID = uint64(valueType)
	case int16:
		r.ID = uint64(valueType)
	case int32:
		r.ID = uint64(valueType)
	case int64:
		r.ID = uint64(valueType)
	case uint:
		r.ID = uint64(valueType)
	case uint8:
		r.ID = uint64(valueType)
	case uint16:
		r.ID = uint64(valueType)
	case uint32:
		r.ID = uint64(valueType)
	case float32:
		r.ID = uint64(valueType)
	case float64:
		r.ID = uint64(valueType)
	default:
		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid value: '%T' for the primary field for model: 'RoleScopes'", value)
	}
	return nil
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (r *RoleScopes) SetPrimaryKeyStringValue(value string) error {
	tmp, err := strconv.ParseUint(value, 10, 64)
	if err != nil {
		return err
	}
	r.ID = tmp
	return nil
}

// SetFrom implements FromSetter interface.
func (r *RoleScopes) SetFrom(model mapping.Model) error {
	if model == nil {
		return errors.Wrap(query.ErrInvalidInput, "provided nil model to set from")
	}
	from, ok := model.(*RoleScopes)
	if !ok {
		return errors.WrapDetf(mapping.ErrModelNotMatch, "provided model doesn't match the input: %T", model)
	}
	*r = *from
	return nil
}

// Compile time check if RoleScopes implements mapping.Fielder interface.
var _ mapping.Fielder = &RoleScopes{}

// GetFieldsAddress gets the address of provided 'field'.
func (r *RoleScopes) GetFieldsAddress(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return &r.ID, nil
	case 1: // CreatedAt
		return &r.CreatedAt, nil
	case 2: // DeletedAt
		return &r.DeletedAt, nil
	case 4: // ScopeID
		return &r.ScopeID, nil
	case 6: // RoleID
		return &r.RoleID, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: RoleScopes'", field.Name())
}

// GetFieldZeroValue implements mapping.Fielder interface.s
func (r *RoleScopes) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return 0, nil
	case 1: // CreatedAt
		return time.Time{}, nil
	case 2: // DeletedAt
		return nil, nil
	case 4: // ScopeID
		return 0, nil
	case 6: // RoleID
		return 0, nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
}

// IsFieldZero implements mapping.Fielder interface.
func (r *RoleScopes) IsFieldZero(field *mapping.StructField) (bool, error) {
	switch field.Index[0] {
	case 0: // ID
		return r.ID == 0, nil
	case 1: // CreatedAt
		return r.CreatedAt == time.Time{}, nil
	case 2: // DeletedAt
		return r.DeletedAt == nil, nil
	case 4: // ScopeID
		return r.ScopeID == 0, nil
	case 6: // RoleID
		return r.RoleID == 0, nil
	}
	return false, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func (r *RoleScopes) SetFieldZeroValue(field *mapping.StructField) error {
	switch field.Index[0] {
	case 0: // ID
		r.ID = 0
	case 1: // CreatedAt
		r.CreatedAt = time.Time{}
	case 2: // DeletedAt
		r.DeletedAt = nil
	case 4: // ScopeID
		r.ScopeID = 0
	case 6: // RoleID
		r.RoleID = 0
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field name: '%s'", field.Name())
	}
	return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func (r *RoleScopes) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return r.ID, nil
	case 1: // CreatedAt
		return r.CreatedAt, nil
	case 2: // DeletedAt
		if r.DeletedAt == nil {
			return nil, nil
		}
		return *r.DeletedAt, nil
	case 4: // ScopeID
		return r.ScopeID, nil
	case 6: // RoleID
		return r.RoleID, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: 'RoleScopes'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func (r *RoleScopes) GetFieldValue(field *mapping.StructField) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return r.ID, nil
	case 1: // CreatedAt
		return r.CreatedAt, nil
	case 2: // DeletedAt
		return r.DeletedAt, nil
	case 4: // ScopeID
		return r.ScopeID, nil
	case 6: // RoleID
		return r.RoleID, nil
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: RoleScopes'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func (r *RoleScopes) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
	switch field.Index[0] {
	case 0: // ID
		if v, ok := value.(uint64); ok {
			r.ID = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			r.ID = 0
			return nil
		}

		switch v := value.(type) {
		case int:
			r.ID = uint64(v)
		case int8:
			r.ID = uint64(v)
		case int16:
			r.ID = uint64(v)
		case int32:
			r.ID = uint64(v)
		case int64:
			r.ID = uint64(v)
		case uint:
			r.ID = uint64(v)
		case uint8:
			r.ID = uint64(v)
		case uint16:
			r.ID = uint64(v)
		case uint32:
			r.ID = uint64(v)
		case float32:
			r.ID = uint64(v)
		case float64:
			r.ID = uint64(v)
		default:
			return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 1: // CreatedAt
		if v, ok := value.(time.Time); ok {
			r.CreatedAt = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			r.CreatedAt = time.Time{}
			return nil
		}

		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 2: // DeletedAt
		if value == nil {
			r.DeletedAt = nil
			return nil
		}
		if v, ok := value.(*time.Time); ok {
			r.DeletedAt = v
			return nil
		}
		// Check if it is non-pointer value.
		if v, ok := value.(time.Time); ok {
			r.DeletedAt = &v
			return nil
		}

		return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
	case 4: // ScopeID
		if v, ok := value.(uint); ok {
			r.ScopeID = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			r.ScopeID = 0
			return nil
		}

		switch v := value.(type) {
		case int:
			r.ScopeID = uint(v)
		case int8:
			r.ScopeID = uint(v)
		case int16:
			r.ScopeID = uint(v)
		case int32:
			r.ScopeID = uint(v)
		case int64:
			r.ScopeID = uint(v)
		case uint8:
			r.ScopeID = uint(v)
		case uint16:
			r.ScopeID = uint(v)
		case uint32:
			r.ScopeID = uint(v)
		case uint64:
			r.ScopeID = uint(v)
		case float32:
			r.ScopeID = uint(v)
		case float64:
			r.ScopeID = uint(v)
		default:
			return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	case 6: // RoleID
		if v, ok := value.(uint); ok {
			r.RoleID = v
			return nil
		}
		if field.DatabaseNotNull() && value == nil {
			r.RoleID = 0
			return nil
		}

		switch v := value.(type) {
		case int:
			r.RoleID = uint(v)
		case int8:
			r.RoleID = uint(v)
		case int16:
			r.RoleID = uint(v)
		case int32:
			r.RoleID = uint(v)
		case int64:
			r.RoleID = uint(v)
		case uint8:
			r.RoleID = uint(v)
		case uint16:
			r.RoleID = uint(v)
		case uint32:
			r.RoleID = uint(v)
		case uint64:
			r.RoleID = uint(v)
		case float32:
			r.RoleID = uint(v)
		case float64:
			r.RoleID = uint(v)
		default:
			return errors.Wrapf(mapping.ErrFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
		}
		return nil
	default:
		return errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for the model: 'RoleScopes'", field.Name())
	}
}

// SetPrimaryKeyStringValue implements mapping.Model interface method.
func (r *RoleScopes) ParseFieldsStringValue(field *mapping.StructField, value string) (interface{}, error) {
	switch field.Index[0] {
	case 0: // ID
		return strconv.ParseUint(value, 10, 64)
	case 1: // CreatedAt
		temp := r.CreatedAt
		if err := r.CreatedAt.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'CreatedAt' value: '%v' to parse string. Err: %v", r.CreatedAt, err)
		}
		bt, err := r.CreatedAt.MarshalText()
		if err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'CreatedAt' value: '%v' to parse string. Err: %v", r.CreatedAt, err)
		}
		r.CreatedAt = temp
		return string(bt), nil
	case 2: // DeletedAt
		var base time.Time
		temp := &base
		if err := temp.UnmarshalText([]byte(value)); err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'DeletedAt' value: '%v' to parse string. Err: %v", r.DeletedAt, err)
		}
		bt, err := temp.MarshalText()
		if err != nil {
			return "", errors.Wrapf(mapping.ErrFieldValue, "invalid field 'DeletedAt' value: '%v' to parse string. Err: %v", r.DeletedAt, err)
		}

		return string(bt), nil
	case 4: // ScopeID
		return strconv.ParseUint(value, 10, mapping.IntegerBitSize)
	case 6: // RoleID
		return strconv.ParseUint(value, 10, mapping.IntegerBitSize)
	}
	return nil, errors.Wrapf(mapping.ErrInvalidModelField, "provided invalid field: '%s' for given model: RoleScopes'", field.Name())
}

// Compile time check if RoleScopes implements mapping.SingleRelationer interface.
var _ mapping.SingleRelationer = &RoleScopes{}

// GetRelationModel implements mapping.SingleRelationer interface.
func (r *RoleScopes) GetRelationModel(relation *mapping.StructField) (mapping.Model, error) {
	switch relation.Index[0] {
	case 3: // Scope
		if r.Scope == nil {
			return nil, nil
		}
		return r.Scope, nil
	case 5: // Role
		if r.Role == nil {
			return nil, nil
		}
		return r.Role, nil
	default:
		return nil, errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, r)
	}
}

// SetRelationModel implements mapping.SingleRelationer interface.
func (r *RoleScopes) SetRelationModel(relation *mapping.StructField, model mapping.Model) error {
	switch relation.Index[0] {
	case 3: // Scope
		if model == nil {
			r.Scope = nil
			return nil
		} else if scope, ok := model.(*AuthorizeScope); ok {
			r.Scope = scope
			return nil
		}
		return errors.Wrapf(mapping.ErrInvalidRelationValue, "provided invalid model value: '%T' for relation Scope", model)
	case 5: // Role
		if model == nil {
			r.Role = nil
			return nil
		} else if role, ok := model.(*Role); ok {
			r.Role = role
			return nil
		}
		return errors.Wrapf(mapping.ErrInvalidRelationValue, "provided invalid model value: '%T' for relation Role", model)
	default:
		return errors.Wrapf(mapping.ErrInvalidRelationField, "provided invalid relation: '%s' for model: '%T'", relation, r)
	}
}
