// Code generated by neuron/generator. DO NOT EDIT.
// This file was generated at:
// Fri, 28 Aug 2020 20:26:48 +0200

package authorizer

import (
	"context"

	"github.com/neuronlabs/neuron/core"
	"github.com/neuronlabs/neuron/database"
	"github.com/neuronlabs/neuron/errors"
	"github.com/neuronlabs/neuron/mapping"
	"github.com/neuronlabs/neuron/query"
	"github.com/neuronlabs/neuron/query/filter"
)

// Neuron_Collections stores all generated collections.
var Neuron_Collections = []core.Initializer{
	NRN_AccountRoles,
	NRN_AuthorizeScopes,
	NRN_Roles,
	NRN_RoleScopes,
}

// NRN_AccountRoles is the collection used to query AccountRoles model.
var NRN_AccountRoles = &_AccountRoles{}

type _AccountRoles struct {
	Model *mapping.ModelStruct
}

// InitializeCollection implements core.Initializer interface.
func (a *_AccountRoles) Initialize(_ctrl *core.Controller) error {
	mStruct, err := _ctrl.ModelStruct(&AccountRoles{})
	if err != nil {
		return err
	}
	NRN_AccountRoles = &_AccountRoles{Model: mStruct}
	return nil
}

// ToModels converts the input slice of AccountRoles into []mapping.Model
func (a *_AccountRoles) ToModels(input ...*AccountRoles) []mapping.Model {
	output := make([]mapping.Model, len(input))
	for i := range input {
		output[i] = input[i]
	}
	return output
}

// FromModels converts the input mapping.Model into []*AccountRoles.
func (a *_AccountRoles) FromModels(input ...mapping.Model) []*AccountRoles {
	output := make([]*AccountRoles, len(input))
	for i := range input {
		output[i] = input[i].(*AccountRoles)
	}
	return output
}

// Query creates the query for the AccountRoles.
func (a *_AccountRoles) Query(db database.DB, models ...*AccountRoles) *accountRolesQueryBuilder {
	var queryModels []mapping.Model
	if len(models) > 0 {
		queryModels = make([]mapping.Model, len(models))
		for i, model := range models {
			queryModels[i] = model
		}
	}
	builder := db.Query(a.Model, queryModels...)
	return &accountRolesQueryBuilder{builder: builder}
}

// QueryCtx creates the query for the AccountRoles with provided 'ctx' context.
func (a *_AccountRoles) QueryCtx(ctx context.Context, db database.DB, models ...*AccountRoles) *accountRolesQueryBuilder {
	var queryModels []mapping.Model
	if len(models) > 0 {
		queryModels = make([]mapping.Model, len(models))
		for i, model := range models {
			queryModels[i] = model
		}
	}
	builder := db.QueryCtx(ctx, a.Model, queryModels...)
	return &accountRolesQueryBuilder{builder: builder}
}

// Insert inserts AccountRoles into database.
func (a *_AccountRoles) Insert(ctx context.Context, db database.DB, models ...*AccountRoles) error {
	if len(models) == 0 {
		return errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Insert(ctx, a.Model, queryModels...)
}

// Update updates AccountRoles models into database.
func (a *_AccountRoles) Update(ctx context.Context, db database.DB, models ...*AccountRoles) (int64, error) {
	if len(models) == 0 {
		return 0, errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Update(ctx, a.Model, queryModels...)
}

// Delete deletes AccountRoles models in database.
func (a *_AccountRoles) Delete(ctx context.Context, db database.DB, models ...*AccountRoles) (int64, error) {
	if len(models) == 0 {
		return 0, errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Delete(ctx, a.Model, queryModels...)
}

// Refresh creates the query for the AccountRoles with provided 'ctx' context.
func (a *_AccountRoles) Refresh(ctx context.Context, db database.DB, models ...*AccountRoles) error {
	var queryModels []mapping.Model
	if len(models) == 0 {
		return errors.Wrap(query.ErrNoModels, "nothing to refresh")
	}
	queryModels = make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Refresh(ctx, a.Model, queryModels...)
}

// ClearRoleRelation clears the 'Role' relationship for provided models. For relationships of type:
// BelongsTo, HasOne, HasMany if foreign key is not nullable than the function would return an error.
func (a *_AccountRoles) ClearRoleRelation(ctx context.Context, db database.DB, models ...*AccountRoles) (int64, error) {
	relation, err := a.Model.RelationByIndex(2)
	if err != nil {
		return 0, err
	}
	modelInterfaces := make([]mapping.Model, len(models))
	for i := range models {
		modelInterfaces[i] = models[i]
	}
	s := query.NewScope(a.Model, modelInterfaces...)
	relationClearer, ok := db.(database.QueryRelationClearer)
	if !ok {
		return 0, errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
	}
	return relationClearer.QueryClearRelations(ctx, s, relation)
}

// GetRole gets the 'Role' relationship for provided input 'model'.
func (a *_AccountRoles) GetRole(ctx context.Context, db database.DB, model *AccountRoles, relationFieldset ...string) (*Role, error) {
	if model == nil {
		return nil, errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return nil, errors.Wrap(mapping.ErrFieldValue, "model's: 'AccountRoles' primary key value has zero value")
	}
	relationField, err := a.Model.RelationByIndex(2)
	if err != nil {
		return nil, err
	}

	var fields []*mapping.StructField
	relationModel := relationField.Relationship().RelatedModelStruct()
	if len(relationFieldset) == 0 {
		fields = relationModel.Fields()
	} else {
		for _, field := range relationFieldset {
			sField, ok := relationModel.FieldByName(field)
			if !ok {
				return nil, errors.Wrapf(mapping.ErrInvalidModelField, "no field: '%s' found for the model: 'Role'", field)
			}
			fields = append(fields, sField)
		}
	}

	relations, err := db.GetRelations(ctx, a.Model, []mapping.Model{model}, relationField, fields...)
	if err != nil {
		return nil, err
	}
	if len(relations) == 0 {
		return nil, nil
	}
	return relations[0].(*Role), nil
}

// SetRole sets the 'Role' relationship for provided input 'models'.
func (a *_AccountRoles) SetRole(ctx context.Context, db database.DB, model *AccountRoles, relation *Role) error {
	if model == nil {
		return errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return errors.Wrap(mapping.ErrFieldValue, "model's: 'AccountRoles' primary key value has zero value")
	}
	relationField, err := a.Model.RelationByIndex(2)
	if err != nil {
		return err
	}
	q := query.NewScope(a.Model, model)
	if relation.IsPrimaryKeyZero() {
		return errors.Wrap(mapping.ErrFieldValue, "relation 'Role' model has zero value primary field")
	}
	relationSetter, ok := db.(database.QueryRelationSetter)
	if !ok {
		return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationSetter interface: %T", db)
	}
	return relationSetter.QuerySetRelations(ctx, q, relationField, relation)
}

// accountRolesQueryBuilder is the query builder used to create and execute
// queries for the AccountRolesmodel.
type accountRolesQueryBuilder struct {
	builder database.Builder
	err     error
}

// Scope returns given query scope.
func (a *accountRolesQueryBuilder) Scope() *query.Scope {
	return a.builder.Scope()
}

// Err returns errors that occurred during query building process.
func (a *accountRolesQueryBuilder) Err() error {
	if a.err != nil {
		return a.err
	}
	return a.builder.Err()
}

// Ctx returns the context of given query builder.
func (a *accountRolesQueryBuilder) Ctx() context.Context {
	return a.builder.Ctx()
}

// Count returns the number of model instances for provided query.
func (a *accountRolesQueryBuilder) Count() (int64, error) {
	if a.err != nil {
		return 0, a.err
	}
	return a.builder.Count()
}

// Insert new 'AccountRoles' instance(s) into the store.
func (a *accountRolesQueryBuilder) Insert() error {
	if a.err != nil {
		return a.err
	}
	return a.builder.Insert()
}

// Update updates given 'AccountRoles' instances.
func (a *accountRolesQueryBuilder) Update() (int64, error) {
	if a.err != nil {
		return 0, a.err
	}
	return a.builder.Update()
}

// Find returns all AccountRoles models that matches to given query.
func (a *accountRolesQueryBuilder) Find() ([]*AccountRoles, error) {
	if a.err != nil {
		return nil, a.err
	}
	queryModels, err := a.builder.Find()
	if err != nil {
		return nil, err
	}
	models := make([]*AccountRoles, len(queryModels))
	for i := range queryModels {
		models[i] = queryModels[i].(*AccountRoles)
	}
	return models, nil
}

// Refresh refreshes input 'AccountRoles' model fields. It might be combine with the included relations.
func (a *accountRolesQueryBuilder) Refresh() error {
	if a.err != nil {
		return a.err
	}
	return a.builder.Refresh()
}

// Get returns single AccountRoles model that matches given query.
// If the model is not found the function returns error of query.ErrQueryNoResult.
func (a *accountRolesQueryBuilder) Get() (*AccountRoles, error) {
	if a.err != nil {
		return nil, a.err
	}
	model, err := a.builder.Get()
	if err != nil {
		return nil, err
	}
	return model.(*AccountRoles), nil
}

// Delete deletes AccountRoles instances that matches given query.
func (a *accountRolesQueryBuilder) Delete() (int64, error) {
	if a.err != nil {
		return 0, a.err
	}
	return a.builder.Delete()
}

// Filter adds the 'filter' to the given query.
func (a *accountRolesQueryBuilder) Filter(filter filter.Filter) *accountRolesQueryBuilder {
	if a.err != nil {
		return a
	}
	a.builder.Filter(filter)
	return a
}

// Where creates query with given 'filter' and 'values'.
func (a *accountRolesQueryBuilder) Where(filter string, values ...interface{}) *accountRolesQueryBuilder {
	if a.err != nil {
		return a
	}
	a.builder.Where(filter, values...)
	return a
}

// IncludeRole includes given 'relation' in the _AccountRoles query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (a *accountRolesQueryBuilder) IncludeRole(roleFieldset ...string) *accountRolesQueryBuilder {
	if a.err != nil {
		return a
	}
	relation, err := NRN_AccountRoles.Model.RelationByIndex(2)
	if err != nil {
		a.err = errors.Wrapf(mapping.ErrInternal, "Getting 'Role' by index for model 'AccountRoles' failed: %v", err)
		return a
	}
	// check the fieldset for the relation.
	var relationFields []*mapping.StructField
	for _, field := range roleFieldset {
		structField, ok := relation.ModelStruct().FieldByName(field)
		if !ok {
			a.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not found for the 'Role' model", field)
			return a
		}
		relationFields = append(relationFields, structField)
	}
	a.builder.Include(relation, relationFields...)
	return a
}

// Limit sets the maximum number of objects returned by the Find process,
// Returns error if the given scope has already different type of pagination.
func (a *accountRolesQueryBuilder) Limit(limit int64) *accountRolesQueryBuilder {
	if a.err != nil {
		return a
	}
	a.builder.Limit(limit)
	return a
}

// Offset sets the query result's offset. It says to skip as many object's from the repository
// before beginning to return the result. 'Offset' 0 is the same as omitting the 'Offset' clause.
// Returns error if the given scope has already different type of pagination.
func (a *accountRolesQueryBuilder) Offset(offset int64) *accountRolesQueryBuilder {
	if a.err != nil {
		return a
	}
	a.builder.Offset(offset)
	return a
}

// Select adds the fields to the scope's fieldset.
// Allowed fields to select:
//  - ID / id
//  - ID / id
//  - CreatedAt / created_at
//  - RoleID / role_id
//  - AccountID / account_id
func (a *accountRolesQueryBuilder) Select(fields ...string) *accountRolesQueryBuilder {
	if a.err != nil {
		return a
	}
	var fieldSet []*mapping.StructField
	for _, field := range fields {
		structField, ok := NRN_AccountRoles.Model.FieldByName(field)
		if !ok {
			a.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not valid for model: '_AccountRoles'", field)
			return a
		}
		fieldSet = append(fieldSet, structField)
	}
	a.builder.Select(fieldSet...)
	return a
}

// OrderBy adds the sort fields into query scope. By default field is ordered ascending. In order to sort descending
// add '-' before the field name i.e. '-id'. The order of the fields relates to the significance of the sorting order.
// Allowed fields to sort:
//  - ID
//  - ID
//  - CreatedAt
//  - RoleID
//  - AccountID
func (a *accountRolesQueryBuilder) OrderBy(fields ...string) *accountRolesQueryBuilder {
	if a.err != nil {
		return a
	}
	sortFields := make([]query.Sort, len(fields))
	for i, field := range fields {
		if len(field) == 0 {
			a.err = errors.Wrap(mapping.ErrInvalidModelField, "cannot set sorting order for an empty field for model: '_AccountRoles'")
			return a
		}
		var order query.SortOrder
		if field[0] == '-' {
			order = query.DescendingOrder
			field = field[1:]
		}
		structField, ok := NRN_AccountRoles.Model.FieldByName(field)
		if !ok {
			a.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not valid for model: '_AccountRoles'", field)
			return a
		}
		sortFields[i] = query.SortField{StructField: structField, SortOrder: order}
	}
	a.builder.OrderBy(sortFields...)
	return a
}

// AddRole adds related model Role and matches to given AccountRoles.
func (a *accountRolesQueryBuilder) AddRole(_role *Role) error {
	if a.err != nil {
		return a.err
	}
	relation, err := NRN_AccountRoles.Model.RelationByIndex(2)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'Role' relation by index for model 'AccountRoles' failed: %v", err)
	}
	return a.builder.AddRelations(relation, _role)
}

// SetRole sets related model Role and matches to given AccountRoles.
func (a *accountRolesQueryBuilder) SetRole(_role *Role) error {
	if a.err != nil {
		return a.err
	}
	relation, err := NRN_AccountRoles.Model.RelationByIndex(2)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'Role' relation by index for model 'AccountRoles' failed: %v", err)
	}
	return a.builder.SetRelations(relation, _role)
}

// RemoveRole removes related model Role and matches to given AccountRoles.
func (a *accountRolesQueryBuilder) RemoveRole() (int64, error) {
	if a.err != nil {
		return 0, a.err
	}
	relation, err := NRN_AccountRoles.Model.RelationByIndex(2)
	if err != nil {
		return 0, errors.Wrapf(mapping.ErrInternal, "getting 'Role' relation by index for model 'AccountRoles' failed: %v", err)
	}
	return a.builder.RemoveRelations(relation)
}

// NRN_AuthorizeScopes is the collection used to query AuthorizeScope model.
var NRN_AuthorizeScopes = &_AuthorizeScopes{}

type _AuthorizeScopes struct {
	Model *mapping.ModelStruct
}

// InitializeCollection implements core.Initializer interface.
func (a *_AuthorizeScopes) Initialize(_ctrl *core.Controller) error {
	mStruct, err := _ctrl.ModelStruct(&AuthorizeScope{})
	if err != nil {
		return err
	}
	NRN_AuthorizeScopes = &_AuthorizeScopes{Model: mStruct}
	return nil
}

// ToModels converts the input slice of AuthorizeScope into []mapping.Model
func (a *_AuthorizeScopes) ToModels(input ...*AuthorizeScope) []mapping.Model {
	output := make([]mapping.Model, len(input))
	for i := range input {
		output[i] = input[i]
	}
	return output
}

// FromModels converts the input mapping.Model into []*AuthorizeScope.
func (a *_AuthorizeScopes) FromModels(input ...mapping.Model) []*AuthorizeScope {
	output := make([]*AuthorizeScope, len(input))
	for i := range input {
		output[i] = input[i].(*AuthorizeScope)
	}
	return output
}

// Query creates the query for the AuthorizeScope.
func (a *_AuthorizeScopes) Query(db database.DB, models ...*AuthorizeScope) *authorizeScopesQueryBuilder {
	var queryModels []mapping.Model
	if len(models) > 0 {
		queryModels = make([]mapping.Model, len(models))
		for i, model := range models {
			queryModels[i] = model
		}
	}
	builder := db.Query(a.Model, queryModels...)
	return &authorizeScopesQueryBuilder{builder: builder}
}

// QueryCtx creates the query for the AuthorizeScope with provided 'ctx' context.
func (a *_AuthorizeScopes) QueryCtx(ctx context.Context, db database.DB, models ...*AuthorizeScope) *authorizeScopesQueryBuilder {
	var queryModels []mapping.Model
	if len(models) > 0 {
		queryModels = make([]mapping.Model, len(models))
		for i, model := range models {
			queryModels[i] = model
		}
	}
	builder := db.QueryCtx(ctx, a.Model, queryModels...)
	return &authorizeScopesQueryBuilder{builder: builder}
}

// Insert inserts AuthorizeScope into database.
func (a *_AuthorizeScopes) Insert(ctx context.Context, db database.DB, models ...*AuthorizeScope) error {
	if len(models) == 0 {
		return errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Insert(ctx, a.Model, queryModels...)
}

// Update updates AuthorizeScope models into database.
func (a *_AuthorizeScopes) Update(ctx context.Context, db database.DB, models ...*AuthorizeScope) (int64, error) {
	if len(models) == 0 {
		return 0, errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Update(ctx, a.Model, queryModels...)
}

// Delete deletes AuthorizeScope models in database.
func (a *_AuthorizeScopes) Delete(ctx context.Context, db database.DB, models ...*AuthorizeScope) (int64, error) {
	if len(models) == 0 {
		return 0, errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Delete(ctx, a.Model, queryModels...)
}

// Refresh creates the query for the AuthorizeScope with provided 'ctx' context.
func (a *_AuthorizeScopes) Refresh(ctx context.Context, db database.DB, models ...*AuthorizeScope) error {
	var queryModels []mapping.Model
	if len(models) == 0 {
		return errors.Wrap(query.ErrNoModels, "nothing to refresh")
	}
	queryModels = make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Refresh(ctx, a.Model, queryModels...)
}

// AddRoles adds the 'Roles' relationship for provided input 'models'.
func (a *_AuthorizeScopes) AddRoles(ctx context.Context, db database.DB, model *AuthorizeScope, relations ...*Role) error {
	if model == nil {
		return errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	if len(relations) == 0 {
		return errors.Wrap(query.ErrNoModels, "no relation models provided")
	}
	relationField, err := a.Model.RelationByIndex(5)
	if err != nil {
		return err
	}
	relationModels := make([]mapping.Model, len(relations))
	for i := range relations {
		relationModels[i] = relations[i]
	}
	q := query.NewScope(a.Model, model)
	relationAdder, ok := db.(database.QueryRelationAdder)
	if !ok {
		return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
	}
	return relationAdder.QueryAddRelations(ctx, q, relationField, relationModels...)
}

// ClearRolesRelation clears the 'Roles' relationship for provided models. For relationships of type:
// BelongsTo, HasOne, HasMany if foreign key is not nullable than the function would return an error.
func (a *_AuthorizeScopes) ClearRolesRelation(ctx context.Context, db database.DB, models ...*AuthorizeScope) (int64, error) {
	relation, err := a.Model.RelationByIndex(5)
	if err != nil {
		return 0, err
	}
	modelInterfaces := make([]mapping.Model, len(models))
	for i := range models {
		modelInterfaces[i] = models[i]
	}
	s := query.NewScope(a.Model, modelInterfaces...)
	relationClearer, ok := db.(database.QueryRelationClearer)
	if !ok {
		return 0, errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
	}
	return relationClearer.QueryClearRelations(ctx, s, relation)
}

// GetRoles gets the 'Roles' relationship for provided input 'model'.
func (a *_AuthorizeScopes) GetRoles(ctx context.Context, db database.DB, model *AuthorizeScope, relationFieldset ...string) ([]*Role, error) {
	if model == nil {
		return nil, errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return nil, errors.Wrap(mapping.ErrFieldValue, "model's: 'AuthorizeScope' primary key value has zero value")
	}
	relationField, err := a.Model.RelationByIndex(5)
	if err != nil {
		return nil, err
	}

	var fields []*mapping.StructField
	relationModel := relationField.Relationship().RelatedModelStruct()
	if len(relationFieldset) == 0 {
		fields = relationModel.Fields()
	} else {
		for _, field := range relationFieldset {
			sField, ok := relationModel.FieldByName(field)
			if !ok {
				return nil, errors.Wrapf(mapping.ErrInvalidModelField, "no field: '%s' found for the model: 'Role'", field)
			}
			fields = append(fields, sField)
		}
	}

	relations, err := db.GetRelations(ctx, a.Model, []mapping.Model{model}, relationField, fields...)
	if err != nil {
		return nil, err
	}
	if len(relations) == 0 {
		return []*Role{}, nil
	}
	result := make([]*Role, len(relations))
	for i, relation := range relations {
		result[i] = relation.(*Role)
	}
	return result, nil
}

// SetRoles sets the 'Roles' relationship for provided input 'models'.
func (a *_AuthorizeScopes) SetRoles(ctx context.Context, db database.DB, model *AuthorizeScope, relations ...*Role) error {
	if model == nil {
		return errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return errors.Wrap(mapping.ErrFieldValue, "model's: 'AuthorizeScope' primary key value has zero value")
	}
	relationField, err := a.Model.RelationByIndex(5)
	if err != nil {
		return err
	}
	q := query.NewScope(a.Model, model)
	if len(relations) == 0 {
		return errors.Wrap(query.ErrNoModels, "no relation models provided")
	}
	relationModels := make([]mapping.Model, len(relations))
	for i, relation := range relations {
		if relation.IsPrimaryKeyZero() {
			return errors.Wrap(mapping.ErrFieldValue, "one of relation 'Roles' model has zero value primary field")
		}
		relationModels[i] = relation
	}
	relationSetter, ok := db.(database.QueryRelationSetter)
	if !ok {
		return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationSetter interface: %T", db)
	}
	return relationSetter.QuerySetRelations(ctx, q, relationField, relationModels...)
}

// authorizeScopesQueryBuilder is the query builder used to create and execute
// queries for the AuthorizeScopemodel.
type authorizeScopesQueryBuilder struct {
	builder database.Builder
	err     error
}

// Scope returns given query scope.
func (a *authorizeScopesQueryBuilder) Scope() *query.Scope {
	return a.builder.Scope()
}

// Err returns errors that occurred during query building process.
func (a *authorizeScopesQueryBuilder) Err() error {
	if a.err != nil {
		return a.err
	}
	return a.builder.Err()
}

// Ctx returns the context of given query builder.
func (a *authorizeScopesQueryBuilder) Ctx() context.Context {
	return a.builder.Ctx()
}

// Count returns the number of model instances for provided query.
func (a *authorizeScopesQueryBuilder) Count() (int64, error) {
	if a.err != nil {
		return 0, a.err
	}
	return a.builder.Count()
}

// Insert new 'AuthorizeScope' instance(s) into the store.
func (a *authorizeScopesQueryBuilder) Insert() error {
	if a.err != nil {
		return a.err
	}
	return a.builder.Insert()
}

// Update updates given 'AuthorizeScope' instances.
func (a *authorizeScopesQueryBuilder) Update() (int64, error) {
	if a.err != nil {
		return 0, a.err
	}
	return a.builder.Update()
}

// Find returns all AuthorizeScope models that matches to given query.
func (a *authorizeScopesQueryBuilder) Find() ([]*AuthorizeScope, error) {
	if a.err != nil {
		return nil, a.err
	}
	queryModels, err := a.builder.Find()
	if err != nil {
		return nil, err
	}
	models := make([]*AuthorizeScope, len(queryModels))
	for i := range queryModels {
		models[i] = queryModels[i].(*AuthorizeScope)
	}
	return models, nil
}

// Refresh refreshes input 'AuthorizeScope' model fields. It might be combine with the included relations.
func (a *authorizeScopesQueryBuilder) Refresh() error {
	if a.err != nil {
		return a.err
	}
	return a.builder.Refresh()
}

// Get returns single AuthorizeScope model that matches given query.
// If the model is not found the function returns error of query.ErrQueryNoResult.
func (a *authorizeScopesQueryBuilder) Get() (*AuthorizeScope, error) {
	if a.err != nil {
		return nil, a.err
	}
	model, err := a.builder.Get()
	if err != nil {
		return nil, err
	}
	return model.(*AuthorizeScope), nil
}

// Delete deletes AuthorizeScope instances that matches given query.
func (a *authorizeScopesQueryBuilder) Delete() (int64, error) {
	if a.err != nil {
		return 0, a.err
	}
	return a.builder.Delete()
}

// Filter adds the 'filter' to the given query.
func (a *authorizeScopesQueryBuilder) Filter(filter filter.Filter) *authorizeScopesQueryBuilder {
	if a.err != nil {
		return a
	}
	a.builder.Filter(filter)
	return a
}

// Where creates query with given 'filter' and 'values'.
func (a *authorizeScopesQueryBuilder) Where(filter string, values ...interface{}) *authorizeScopesQueryBuilder {
	if a.err != nil {
		return a
	}
	a.builder.Where(filter, values...)
	return a
}

// IncludeRoles includes given 'relation' in the _AuthorizeScopes query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (a *authorizeScopesQueryBuilder) IncludeRoles(rolesFieldset ...string) *authorizeScopesQueryBuilder {
	if a.err != nil {
		return a
	}
	relation, err := NRN_AuthorizeScopes.Model.RelationByIndex(5)
	if err != nil {
		a.err = errors.Wrapf(mapping.ErrInternal, "Getting 'Roles' by index for model 'AuthorizeScope' failed: %v", err)
		return a
	}
	// check the fieldset for the relation.
	var relationFields []*mapping.StructField
	for _, field := range rolesFieldset {
		structField, ok := relation.ModelStruct().FieldByName(field)
		if !ok {
			a.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not found for the 'Role' model", field)
			return a
		}
		relationFields = append(relationFields, structField)
	}
	a.builder.Include(relation, relationFields...)
	return a
}

// Limit sets the maximum number of objects returned by the Find process,
// Returns error if the given scope has already different type of pagination.
func (a *authorizeScopesQueryBuilder) Limit(limit int64) *authorizeScopesQueryBuilder {
	if a.err != nil {
		return a
	}
	a.builder.Limit(limit)
	return a
}

// Offset sets the query result's offset. It says to skip as many object's from the repository
// before beginning to return the result. 'Offset' 0 is the same as omitting the 'Offset' clause.
// Returns error if the given scope has already different type of pagination.
func (a *authorizeScopesQueryBuilder) Offset(offset int64) *authorizeScopesQueryBuilder {
	if a.err != nil {
		return a
	}
	a.builder.Offset(offset)
	return a
}

// Select adds the fields to the scope's fieldset.
// Allowed fields to select:
//  - ID / id
//  - ID / id
//  - CreatedAt / created_at
//  - DeletedAt / deleted_at
//  - Name / name
//  - Description / description
func (a *authorizeScopesQueryBuilder) Select(fields ...string) *authorizeScopesQueryBuilder {
	if a.err != nil {
		return a
	}
	var fieldSet []*mapping.StructField
	for _, field := range fields {
		structField, ok := NRN_AuthorizeScopes.Model.FieldByName(field)
		if !ok {
			a.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not valid for model: '_AuthorizeScopes'", field)
			return a
		}
		fieldSet = append(fieldSet, structField)
	}
	a.builder.Select(fieldSet...)
	return a
}

// OrderBy adds the sort fields into query scope. By default field is ordered ascending. In order to sort descending
// add '-' before the field name i.e. '-id'. The order of the fields relates to the significance of the sorting order.
// Allowed fields to sort:
//  - ID
//  - ID
//  - CreatedAt
//  - DeletedAt
//  - Name
//  - Description
func (a *authorizeScopesQueryBuilder) OrderBy(fields ...string) *authorizeScopesQueryBuilder {
	if a.err != nil {
		return a
	}
	sortFields := make([]query.Sort, len(fields))
	for i, field := range fields {
		if len(field) == 0 {
			a.err = errors.Wrap(mapping.ErrInvalidModelField, "cannot set sorting order for an empty field for model: '_AuthorizeScopes'")
			return a
		}
		var order query.SortOrder
		if field[0] == '-' {
			order = query.DescendingOrder
			field = field[1:]
		}
		structField, ok := NRN_AuthorizeScopes.Model.FieldByName(field)
		if !ok {
			a.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not valid for model: '_AuthorizeScopes'", field)
			return a
		}
		sortFields[i] = query.SortField{StructField: structField, SortOrder: order}
	}
	a.builder.OrderBy(sortFields...)
	return a
}

// AddRoles adds related model Roles and matches to given AuthorizeScope.
func (a *authorizeScopesQueryBuilder) AddRoles(_roles ...*Role) error {
	if a.err != nil {
		return a.err
	}
	relation, err := NRN_AuthorizeScopes.Model.RelationByIndex(5)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'Roles' relation by index for model 'AuthorizeScope' failed: %v", err)
	}
	models := make([]mapping.Model, len(_roles))
	for i := range _roles {
		models[i] = _roles[i]
	}
	return a.builder.AddRelations(relation, models...)
}

// SetRoles sets related model Roles and matches to given AuthorizeScope.
func (a *authorizeScopesQueryBuilder) SetRoles(_roles ...*Role) error {
	if a.err != nil {
		return a.err
	}
	relation, err := NRN_AuthorizeScopes.Model.RelationByIndex(5)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'Roles' relation by index for model 'AuthorizeScope' failed: %v", err)
	}
	models := make([]mapping.Model, len(_roles))
	for i := range _roles {
		models[i] = _roles[i]
	}
	return a.builder.SetRelations(relation, models...)
}

// RemoveRoles removes related model Roles and matches to given AuthorizeScope.
func (a *authorizeScopesQueryBuilder) RemoveRoles() (int64, error) {
	if a.err != nil {
		return 0, a.err
	}
	relation, err := NRN_AuthorizeScopes.Model.RelationByIndex(5)
	if err != nil {
		return 0, errors.Wrapf(mapping.ErrInternal, "getting 'Roles' relation by index for model 'AuthorizeScope' failed: %v", err)
	}
	return a.builder.RemoveRelations(relation)
}

// NRN_Roles is the collection used to query Role model.
var NRN_Roles = &_Roles{}

type _Roles struct {
	Model *mapping.ModelStruct
}

// InitializeCollection implements core.Initializer interface.
func (r *_Roles) Initialize(_ctrl *core.Controller) error {
	mStruct, err := _ctrl.ModelStruct(&Role{})
	if err != nil {
		return err
	}
	NRN_Roles = &_Roles{Model: mStruct}
	return nil
}

// ToModels converts the input slice of Role into []mapping.Model
func (r *_Roles) ToModels(input ...*Role) []mapping.Model {
	output := make([]mapping.Model, len(input))
	for i := range input {
		output[i] = input[i]
	}
	return output
}

// FromModels converts the input mapping.Model into []*Role.
func (r *_Roles) FromModels(input ...mapping.Model) []*Role {
	output := make([]*Role, len(input))
	for i := range input {
		output[i] = input[i].(*Role)
	}
	return output
}

// Query creates the query for the Role.
func (r *_Roles) Query(db database.DB, models ...*Role) *rolesQueryBuilder {
	var queryModels []mapping.Model
	if len(models) > 0 {
		queryModels = make([]mapping.Model, len(models))
		for i, model := range models {
			queryModels[i] = model
		}
	}
	builder := db.Query(r.Model, queryModels...)
	return &rolesQueryBuilder{builder: builder}
}

// QueryCtx creates the query for the Role with provided 'ctx' context.
func (r *_Roles) QueryCtx(ctx context.Context, db database.DB, models ...*Role) *rolesQueryBuilder {
	var queryModels []mapping.Model
	if len(models) > 0 {
		queryModels = make([]mapping.Model, len(models))
		for i, model := range models {
			queryModels[i] = model
		}
	}
	builder := db.QueryCtx(ctx, r.Model, queryModels...)
	return &rolesQueryBuilder{builder: builder}
}

// Insert inserts Role into database.
func (r *_Roles) Insert(ctx context.Context, db database.DB, models ...*Role) error {
	if len(models) == 0 {
		return errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Insert(ctx, r.Model, queryModels...)
}

// Update updates Role models into database.
func (r *_Roles) Update(ctx context.Context, db database.DB, models ...*Role) (int64, error) {
	if len(models) == 0 {
		return 0, errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Update(ctx, r.Model, queryModels...)
}

// Delete deletes Role models in database.
func (r *_Roles) Delete(ctx context.Context, db database.DB, models ...*Role) (int64, error) {
	if len(models) == 0 {
		return 0, errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Delete(ctx, r.Model, queryModels...)
}

// Refresh creates the query for the Role with provided 'ctx' context.
func (r *_Roles) Refresh(ctx context.Context, db database.DB, models ...*Role) error {
	var queryModels []mapping.Model
	if len(models) == 0 {
		return errors.Wrap(query.ErrNoModels, "nothing to refresh")
	}
	queryModels = make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Refresh(ctx, r.Model, queryModels...)
}

// AddAccounts adds the 'Accounts' relationship for provided input 'models'.
func (r *_Roles) AddAccounts(ctx context.Context, db database.DB, model *Role, relations ...*AccountRoles) error {
	if model == nil {
		return errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	if len(relations) == 0 {
		return errors.Wrap(query.ErrNoModels, "no relation models provided")
	}
	relationField, err := r.Model.RelationByIndex(7)
	if err != nil {
		return err
	}
	relationModels := make([]mapping.Model, len(relations))
	for i := range relations {
		relationModels[i] = relations[i]
	}
	q := query.NewScope(r.Model, model)
	relationAdder, ok := db.(database.QueryRelationAdder)
	if !ok {
		return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
	}
	return relationAdder.QueryAddRelations(ctx, q, relationField, relationModels...)
}

// ClearAccountsRelation clears the 'Accounts' relationship for provided models. For relationships of type:
// BelongsTo, HasOne, HasMany if foreign key is not nullable than the function would return an error.
func (r *_Roles) ClearAccountsRelation(ctx context.Context, db database.DB, models ...*Role) (int64, error) {
	relation, err := r.Model.RelationByIndex(7)
	if err != nil {
		return 0, err
	}
	modelInterfaces := make([]mapping.Model, len(models))
	for i := range models {
		modelInterfaces[i] = models[i]
	}
	s := query.NewScope(r.Model, modelInterfaces...)
	relationClearer, ok := db.(database.QueryRelationClearer)
	if !ok {
		return 0, errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
	}
	return relationClearer.QueryClearRelations(ctx, s, relation)
}

// GetAccounts gets the 'Accounts' relationship for provided input 'model'.
func (r *_Roles) GetAccounts(ctx context.Context, db database.DB, model *Role, relationFieldset ...string) ([]*AccountRoles, error) {
	if model == nil {
		return nil, errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return nil, errors.Wrap(mapping.ErrFieldValue, "model's: 'Role' primary key value has zero value")
	}
	relationField, err := r.Model.RelationByIndex(7)
	if err != nil {
		return nil, err
	}

	var fields []*mapping.StructField
	relationModel := relationField.Relationship().RelatedModelStruct()
	if len(relationFieldset) == 0 {
		fields = relationModel.Fields()
	} else {
		for _, field := range relationFieldset {
			sField, ok := relationModel.FieldByName(field)
			if !ok {
				return nil, errors.Wrapf(mapping.ErrInvalidModelField, "no field: '%s' found for the model: 'AccountRoles'", field)
			}
			fields = append(fields, sField)
		}
	}

	relations, err := db.GetRelations(ctx, r.Model, []mapping.Model{model}, relationField, fields...)
	if err != nil {
		return nil, err
	}
	if len(relations) == 0 {
		return []*AccountRoles{}, nil
	}
	result := make([]*AccountRoles, len(relations))
	for i, relation := range relations {
		result[i] = relation.(*AccountRoles)
	}
	return result, nil
}

// SetAccounts sets the 'Accounts' relationship for provided input 'models'.
func (r *_Roles) SetAccounts(ctx context.Context, db database.DB, model *Role, relations ...*AccountRoles) error {
	if model == nil {
		return errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return errors.Wrap(mapping.ErrFieldValue, "model's: 'Role' primary key value has zero value")
	}
	relationField, err := r.Model.RelationByIndex(7)
	if err != nil {
		return err
	}
	q := query.NewScope(r.Model, model)
	if len(relations) == 0 {
		return errors.Wrap(query.ErrNoModels, "no relation models provided")
	}
	relationModels := make([]mapping.Model, len(relations))
	for i, relation := range relations {
		if relation.IsPrimaryKeyZero() {
			return errors.Wrap(mapping.ErrFieldValue, "one of relation 'Accounts' model has zero value primary field")
		}
		relationModels[i] = relation
	}
	relationSetter, ok := db.(database.QueryRelationSetter)
	if !ok {
		return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationSetter interface: %T", db)
	}
	return relationSetter.QuerySetRelations(ctx, q, relationField, relationModels...)
}

// AddScopes adds the 'Scopes' relationship for provided input 'models'.
func (r *_Roles) AddScopes(ctx context.Context, db database.DB, model *Role, relations ...*AuthorizeScope) error {
	if model == nil {
		return errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	if len(relations) == 0 {
		return errors.Wrap(query.ErrNoModels, "no relation models provided")
	}
	relationField, err := r.Model.RelationByIndex(8)
	if err != nil {
		return err
	}
	relationModels := make([]mapping.Model, len(relations))
	for i := range relations {
		relationModels[i] = relations[i]
	}
	q := query.NewScope(r.Model, model)
	relationAdder, ok := db.(database.QueryRelationAdder)
	if !ok {
		return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
	}
	return relationAdder.QueryAddRelations(ctx, q, relationField, relationModels...)
}

// ClearScopesRelation clears the 'Scopes' relationship for provided models. For relationships of type:
// BelongsTo, HasOne, HasMany if foreign key is not nullable than the function would return an error.
func (r *_Roles) ClearScopesRelation(ctx context.Context, db database.DB, models ...*Role) (int64, error) {
	relation, err := r.Model.RelationByIndex(8)
	if err != nil {
		return 0, err
	}
	modelInterfaces := make([]mapping.Model, len(models))
	for i := range models {
		modelInterfaces[i] = models[i]
	}
	s := query.NewScope(r.Model, modelInterfaces...)
	relationClearer, ok := db.(database.QueryRelationClearer)
	if !ok {
		return 0, errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
	}
	return relationClearer.QueryClearRelations(ctx, s, relation)
}

// GetScopes gets the 'Scopes' relationship for provided input 'model'.
func (r *_Roles) GetScopes(ctx context.Context, db database.DB, model *Role, relationFieldset ...string) ([]*AuthorizeScope, error) {
	if model == nil {
		return nil, errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return nil, errors.Wrap(mapping.ErrFieldValue, "model's: 'Role' primary key value has zero value")
	}
	relationField, err := r.Model.RelationByIndex(8)
	if err != nil {
		return nil, err
	}

	var fields []*mapping.StructField
	relationModel := relationField.Relationship().RelatedModelStruct()
	if len(relationFieldset) == 0 {
		fields = relationModel.Fields()
	} else {
		for _, field := range relationFieldset {
			sField, ok := relationModel.FieldByName(field)
			if !ok {
				return nil, errors.Wrapf(mapping.ErrInvalidModelField, "no field: '%s' found for the model: 'AuthorizeScope'", field)
			}
			fields = append(fields, sField)
		}
	}

	relations, err := db.GetRelations(ctx, r.Model, []mapping.Model{model}, relationField, fields...)
	if err != nil {
		return nil, err
	}
	if len(relations) == 0 {
		return []*AuthorizeScope{}, nil
	}
	result := make([]*AuthorizeScope, len(relations))
	for i, relation := range relations {
		result[i] = relation.(*AuthorizeScope)
	}
	return result, nil
}

// SetScopes sets the 'Scopes' relationship for provided input 'models'.
func (r *_Roles) SetScopes(ctx context.Context, db database.DB, model *Role, relations ...*AuthorizeScope) error {
	if model == nil {
		return errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return errors.Wrap(mapping.ErrFieldValue, "model's: 'Role' primary key value has zero value")
	}
	relationField, err := r.Model.RelationByIndex(8)
	if err != nil {
		return err
	}
	q := query.NewScope(r.Model, model)
	if len(relations) == 0 {
		return errors.Wrap(query.ErrNoModels, "no relation models provided")
	}
	relationModels := make([]mapping.Model, len(relations))
	for i, relation := range relations {
		if relation.IsPrimaryKeyZero() {
			return errors.Wrap(mapping.ErrFieldValue, "one of relation 'Scopes' model has zero value primary field")
		}
		relationModels[i] = relation
	}
	relationSetter, ok := db.(database.QueryRelationSetter)
	if !ok {
		return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationSetter interface: %T", db)
	}
	return relationSetter.QuerySetRelations(ctx, q, relationField, relationModels...)
}

// rolesQueryBuilder is the query builder used to create and execute
// queries for the Rolemodel.
type rolesQueryBuilder struct {
	builder database.Builder
	err     error
}

// Scope returns given query scope.
func (r *rolesQueryBuilder) Scope() *query.Scope {
	return r.builder.Scope()
}

// Err returns errors that occurred during query building process.
func (r *rolesQueryBuilder) Err() error {
	if r.err != nil {
		return r.err
	}
	return r.builder.Err()
}

// Ctx returns the context of given query builder.
func (r *rolesQueryBuilder) Ctx() context.Context {
	return r.builder.Ctx()
}

// Count returns the number of model instances for provided query.
func (r *rolesQueryBuilder) Count() (int64, error) {
	if r.err != nil {
		return 0, r.err
	}
	return r.builder.Count()
}

// Insert new 'Role' instance(s) into the store.
func (r *rolesQueryBuilder) Insert() error {
	if r.err != nil {
		return r.err
	}
	return r.builder.Insert()
}

// Update updates given 'Role' instances.
func (r *rolesQueryBuilder) Update() (int64, error) {
	if r.err != nil {
		return 0, r.err
	}
	return r.builder.Update()
}

// Find returns all Role models that matches to given query.
func (r *rolesQueryBuilder) Find() ([]*Role, error) {
	if r.err != nil {
		return nil, r.err
	}
	queryModels, err := r.builder.Find()
	if err != nil {
		return nil, err
	}
	models := make([]*Role, len(queryModels))
	for i := range queryModels {
		models[i] = queryModels[i].(*Role)
	}
	return models, nil
}

// Refresh refreshes input 'Role' model fields. It might be combine with the included relations.
func (r *rolesQueryBuilder) Refresh() error {
	if r.err != nil {
		return r.err
	}
	return r.builder.Refresh()
}

// Get returns single Role model that matches given query.
// If the model is not found the function returns error of query.ErrQueryNoResult.
func (r *rolesQueryBuilder) Get() (*Role, error) {
	if r.err != nil {
		return nil, r.err
	}
	model, err := r.builder.Get()
	if err != nil {
		return nil, err
	}
	return model.(*Role), nil
}

// Delete deletes Role instances that matches given query.
func (r *rolesQueryBuilder) Delete() (int64, error) {
	if r.err != nil {
		return 0, r.err
	}
	return r.builder.Delete()
}

// Filter adds the 'filter' to the given query.
func (r *rolesQueryBuilder) Filter(filter filter.Filter) *rolesQueryBuilder {
	if r.err != nil {
		return r
	}
	r.builder.Filter(filter)
	return r
}

// Where creates query with given 'filter' and 'values'.
func (r *rolesQueryBuilder) Where(filter string, values ...interface{}) *rolesQueryBuilder {
	if r.err != nil {
		return r
	}
	r.builder.Where(filter, values...)
	return r
}

// IncludeAccounts includes given 'relation' in the _Roles query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (r *rolesQueryBuilder) IncludeAccounts(accountsFieldset ...string) *rolesQueryBuilder {
	if r.err != nil {
		return r
	}
	relation, err := NRN_Roles.Model.RelationByIndex(7)
	if err != nil {
		r.err = errors.Wrapf(mapping.ErrInternal, "Getting 'Accounts' by index for model 'Role' failed: %v", err)
		return r
	}
	// check the fieldset for the relation.
	var relationFields []*mapping.StructField
	for _, field := range accountsFieldset {
		structField, ok := relation.ModelStruct().FieldByName(field)
		if !ok {
			r.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not found for the 'AccountRoles' model", field)
			return r
		}
		relationFields = append(relationFields, structField)
	}
	r.builder.Include(relation, relationFields...)
	return r
}

// IncludeScopes includes given 'relation' in the _Roles query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (r *rolesQueryBuilder) IncludeScopes(scopesFieldset ...string) *rolesQueryBuilder {
	if r.err != nil {
		return r
	}
	relation, err := NRN_Roles.Model.RelationByIndex(8)
	if err != nil {
		r.err = errors.Wrapf(mapping.ErrInternal, "Getting 'Scopes' by index for model 'Role' failed: %v", err)
		return r
	}
	// check the fieldset for the relation.
	var relationFields []*mapping.StructField
	for _, field := range scopesFieldset {
		structField, ok := relation.ModelStruct().FieldByName(field)
		if !ok {
			r.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not found for the 'AuthorizeScope' model", field)
			return r
		}
		relationFields = append(relationFields, structField)
	}
	r.builder.Include(relation, relationFields...)
	return r
}

// Limit sets the maximum number of objects returned by the Find process,
// Returns error if the given scope has already different type of pagination.
func (r *rolesQueryBuilder) Limit(limit int64) *rolesQueryBuilder {
	if r.err != nil {
		return r
	}
	r.builder.Limit(limit)
	return r
}

// Offset sets the query result's offset. It says to skip as many object's from the repository
// before beginning to return the result. 'Offset' 0 is the same as omitting the 'Offset' clause.
// Returns error if the given scope has already different type of pagination.
func (r *rolesQueryBuilder) Offset(offset int64) *rolesQueryBuilder {
	if r.err != nil {
		return r
	}
	r.builder.Offset(offset)
	return r
}

// Select adds the fields to the scope's fieldset.
// Allowed fields to select:
//  - ID / id
//  - ID / id
//  - CreatedAt / created_at
//  - UpdatedAt / updated_at
//  - DeletedAt / deleted_at
//  - Hierarchy / hierarchy
//  - Name / name
//  - Description / description
func (r *rolesQueryBuilder) Select(fields ...string) *rolesQueryBuilder {
	if r.err != nil {
		return r
	}
	var fieldSet []*mapping.StructField
	for _, field := range fields {
		structField, ok := NRN_Roles.Model.FieldByName(field)
		if !ok {
			r.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not valid for model: '_Roles'", field)
			return r
		}
		fieldSet = append(fieldSet, structField)
	}
	r.builder.Select(fieldSet...)
	return r
}

// OrderBy adds the sort fields into query scope. By default field is ordered ascending. In order to sort descending
// add '-' before the field name i.e. '-id'. The order of the fields relates to the significance of the sorting order.
// Allowed fields to sort:
//  - ID
//  - ID
//  - CreatedAt
//  - UpdatedAt
//  - DeletedAt
//  - Hierarchy
//  - Name
//  - Description
func (r *rolesQueryBuilder) OrderBy(fields ...string) *rolesQueryBuilder {
	if r.err != nil {
		return r
	}
	sortFields := make([]query.Sort, len(fields))
	for i, field := range fields {
		if len(field) == 0 {
			r.err = errors.Wrap(mapping.ErrInvalidModelField, "cannot set sorting order for an empty field for model: '_Roles'")
			return r
		}
		var order query.SortOrder
		if field[0] == '-' {
			order = query.DescendingOrder
			field = field[1:]
		}
		structField, ok := NRN_Roles.Model.FieldByName(field)
		if !ok {
			r.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not valid for model: '_Roles'", field)
			return r
		}
		sortFields[i] = query.SortField{StructField: structField, SortOrder: order}
	}
	r.builder.OrderBy(sortFields...)
	return r
}

// AddAccounts adds related model Accounts and matches to given Role.
func (r *rolesQueryBuilder) AddAccounts(_accounts ...*AccountRoles) error {
	if r.err != nil {
		return r.err
	}
	relation, err := NRN_Roles.Model.RelationByIndex(7)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'Accounts' relation by index for model 'Role' failed: %v", err)
	}
	models := make([]mapping.Model, len(_accounts))
	for i := range _accounts {
		models[i] = _accounts[i]
	}
	return r.builder.AddRelations(relation, models...)
}

// AddScopes adds related model Scopes and matches to given Role.
func (r *rolesQueryBuilder) AddScopes(_scopes ...*AuthorizeScope) error {
	if r.err != nil {
		return r.err
	}
	relation, err := NRN_Roles.Model.RelationByIndex(8)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'Scopes' relation by index for model 'Role' failed: %v", err)
	}
	models := make([]mapping.Model, len(_scopes))
	for i := range _scopes {
		models[i] = _scopes[i]
	}
	return r.builder.AddRelations(relation, models...)
}

// SetAccounts sets related model Accounts and matches to given Role.
func (r *rolesQueryBuilder) SetAccounts(_accounts ...*AccountRoles) error {
	if r.err != nil {
		return r.err
	}
	relation, err := NRN_Roles.Model.RelationByIndex(7)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'Accounts' relation by index for model 'Role' failed: %v", err)
	}
	models := make([]mapping.Model, len(_accounts))
	for i := range _accounts {
		models[i] = _accounts[i]
	}
	return r.builder.SetRelations(relation, models...)
}

// SetScopes sets related model Scopes and matches to given Role.
func (r *rolesQueryBuilder) SetScopes(_scopes ...*AuthorizeScope) error {
	if r.err != nil {
		return r.err
	}
	relation, err := NRN_Roles.Model.RelationByIndex(8)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'Scopes' relation by index for model 'Role' failed: %v", err)
	}
	models := make([]mapping.Model, len(_scopes))
	for i := range _scopes {
		models[i] = _scopes[i]
	}
	return r.builder.SetRelations(relation, models...)
}

// RemoveAccounts removes related model Accounts and matches to given Role.
func (r *rolesQueryBuilder) RemoveAccounts() (int64, error) {
	if r.err != nil {
		return 0, r.err
	}
	relation, err := NRN_Roles.Model.RelationByIndex(7)
	if err != nil {
		return 0, errors.Wrapf(mapping.ErrInternal, "getting 'Accounts' relation by index for model 'Role' failed: %v", err)
	}
	return r.builder.RemoveRelations(relation)
}

// RemoveScopes removes related model Scopes and matches to given Role.
func (r *rolesQueryBuilder) RemoveScopes() (int64, error) {
	if r.err != nil {
		return 0, r.err
	}
	relation, err := NRN_Roles.Model.RelationByIndex(8)
	if err != nil {
		return 0, errors.Wrapf(mapping.ErrInternal, "getting 'Scopes' relation by index for model 'Role' failed: %v", err)
	}
	return r.builder.RemoveRelations(relation)
}

// NRN_RoleScopes is the collection used to query RoleScopes model.
var NRN_RoleScopes = &_RoleScopes{}

type _RoleScopes struct {
	Model *mapping.ModelStruct
}

// InitializeCollection implements core.Initializer interface.
func (r *_RoleScopes) Initialize(_ctrl *core.Controller) error {
	mStruct, err := _ctrl.ModelStruct(&RoleScopes{})
	if err != nil {
		return err
	}
	NRN_RoleScopes = &_RoleScopes{Model: mStruct}
	return nil
}

// ToModels converts the input slice of RoleScopes into []mapping.Model
func (r *_RoleScopes) ToModels(input ...*RoleScopes) []mapping.Model {
	output := make([]mapping.Model, len(input))
	for i := range input {
		output[i] = input[i]
	}
	return output
}

// FromModels converts the input mapping.Model into []*RoleScopes.
func (r *_RoleScopes) FromModels(input ...mapping.Model) []*RoleScopes {
	output := make([]*RoleScopes, len(input))
	for i := range input {
		output[i] = input[i].(*RoleScopes)
	}
	return output
}

// Query creates the query for the RoleScopes.
func (r *_RoleScopes) Query(db database.DB, models ...*RoleScopes) *roleScopesQueryBuilder {
	var queryModels []mapping.Model
	if len(models) > 0 {
		queryModels = make([]mapping.Model, len(models))
		for i, model := range models {
			queryModels[i] = model
		}
	}
	builder := db.Query(r.Model, queryModels...)
	return &roleScopesQueryBuilder{builder: builder}
}

// QueryCtx creates the query for the RoleScopes with provided 'ctx' context.
func (r *_RoleScopes) QueryCtx(ctx context.Context, db database.DB, models ...*RoleScopes) *roleScopesQueryBuilder {
	var queryModels []mapping.Model
	if len(models) > 0 {
		queryModels = make([]mapping.Model, len(models))
		for i, model := range models {
			queryModels[i] = model
		}
	}
	builder := db.QueryCtx(ctx, r.Model, queryModels...)
	return &roleScopesQueryBuilder{builder: builder}
}

// Insert inserts RoleScopes into database.
func (r *_RoleScopes) Insert(ctx context.Context, db database.DB, models ...*RoleScopes) error {
	if len(models) == 0 {
		return errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Insert(ctx, r.Model, queryModels...)
}

// Update updates RoleScopes models into database.
func (r *_RoleScopes) Update(ctx context.Context, db database.DB, models ...*RoleScopes) (int64, error) {
	if len(models) == 0 {
		return 0, errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Update(ctx, r.Model, queryModels...)
}

// Delete deletes RoleScopes models in database.
func (r *_RoleScopes) Delete(ctx context.Context, db database.DB, models ...*RoleScopes) (int64, error) {
	if len(models) == 0 {
		return 0, errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Delete(ctx, r.Model, queryModels...)
}

// Refresh creates the query for the RoleScopes with provided 'ctx' context.
func (r *_RoleScopes) Refresh(ctx context.Context, db database.DB, models ...*RoleScopes) error {
	var queryModels []mapping.Model
	if len(models) == 0 {
		return errors.Wrap(query.ErrNoModels, "nothing to refresh")
	}
	queryModels = make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Refresh(ctx, r.Model, queryModels...)
}

// ClearScopeRelation clears the 'Scope' relationship for provided models. For relationships of type:
// BelongsTo, HasOne, HasMany if foreign key is not nullable than the function would return an error.
func (r *_RoleScopes) ClearScopeRelation(ctx context.Context, db database.DB, models ...*RoleScopes) (int64, error) {
	relation, err := r.Model.RelationByIndex(3)
	if err != nil {
		return 0, err
	}
	modelInterfaces := make([]mapping.Model, len(models))
	for i := range models {
		modelInterfaces[i] = models[i]
	}
	s := query.NewScope(r.Model, modelInterfaces...)
	relationClearer, ok := db.(database.QueryRelationClearer)
	if !ok {
		return 0, errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
	}
	return relationClearer.QueryClearRelations(ctx, s, relation)
}

// GetScope gets the 'Scope' relationship for provided input 'model'.
func (r *_RoleScopes) GetScope(ctx context.Context, db database.DB, model *RoleScopes, relationFieldset ...string) (*AuthorizeScope, error) {
	if model == nil {
		return nil, errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return nil, errors.Wrap(mapping.ErrFieldValue, "model's: 'RoleScopes' primary key value has zero value")
	}
	relationField, err := r.Model.RelationByIndex(3)
	if err != nil {
		return nil, err
	}

	var fields []*mapping.StructField
	relationModel := relationField.Relationship().RelatedModelStruct()
	if len(relationFieldset) == 0 {
		fields = relationModel.Fields()
	} else {
		for _, field := range relationFieldset {
			sField, ok := relationModel.FieldByName(field)
			if !ok {
				return nil, errors.Wrapf(mapping.ErrInvalidModelField, "no field: '%s' found for the model: 'AuthorizeScope'", field)
			}
			fields = append(fields, sField)
		}
	}

	relations, err := db.GetRelations(ctx, r.Model, []mapping.Model{model}, relationField, fields...)
	if err != nil {
		return nil, err
	}
	if len(relations) == 0 {
		return nil, nil
	}
	return relations[0].(*AuthorizeScope), nil
}

// SetScope sets the 'Scope' relationship for provided input 'models'.
func (r *_RoleScopes) SetScope(ctx context.Context, db database.DB, model *RoleScopes, relation *AuthorizeScope) error {
	if model == nil {
		return errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return errors.Wrap(mapping.ErrFieldValue, "model's: 'RoleScopes' primary key value has zero value")
	}
	relationField, err := r.Model.RelationByIndex(3)
	if err != nil {
		return err
	}
	q := query.NewScope(r.Model, model)
	if relation.IsPrimaryKeyZero() {
		return errors.Wrap(mapping.ErrFieldValue, "relation 'Scope' model has zero value primary field")
	}
	relationSetter, ok := db.(database.QueryRelationSetter)
	if !ok {
		return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationSetter interface: %T", db)
	}
	return relationSetter.QuerySetRelations(ctx, q, relationField, relation)
}

// ClearRoleRelation clears the 'Role' relationship for provided models. For relationships of type:
// BelongsTo, HasOne, HasMany if foreign key is not nullable than the function would return an error.
func (r *_RoleScopes) ClearRoleRelation(ctx context.Context, db database.DB, models ...*RoleScopes) (int64, error) {
	relation, err := r.Model.RelationByIndex(5)
	if err != nil {
		return 0, err
	}
	modelInterfaces := make([]mapping.Model, len(models))
	for i := range models {
		modelInterfaces[i] = models[i]
	}
	s := query.NewScope(r.Model, modelInterfaces...)
	relationClearer, ok := db.(database.QueryRelationClearer)
	if !ok {
		return 0, errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationAdder interface - %T", db)
	}
	return relationClearer.QueryClearRelations(ctx, s, relation)
}

// GetRole gets the 'Role' relationship for provided input 'model'.
func (r *_RoleScopes) GetRole(ctx context.Context, db database.DB, model *RoleScopes, relationFieldset ...string) (*Role, error) {
	if model == nil {
		return nil, errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return nil, errors.Wrap(mapping.ErrFieldValue, "model's: 'RoleScopes' primary key value has zero value")
	}
	relationField, err := r.Model.RelationByIndex(5)
	if err != nil {
		return nil, err
	}

	var fields []*mapping.StructField
	relationModel := relationField.Relationship().RelatedModelStruct()
	if len(relationFieldset) == 0 {
		fields = relationModel.Fields()
	} else {
		for _, field := range relationFieldset {
			sField, ok := relationModel.FieldByName(field)
			if !ok {
				return nil, errors.Wrapf(mapping.ErrInvalidModelField, "no field: '%s' found for the model: 'Role'", field)
			}
			fields = append(fields, sField)
		}
	}

	relations, err := db.GetRelations(ctx, r.Model, []mapping.Model{model}, relationField, fields...)
	if err != nil {
		return nil, err
	}
	if len(relations) == 0 {
		return nil, nil
	}
	return relations[0].(*Role), nil
}

// SetRole sets the 'Role' relationship for provided input 'models'.
func (r *_RoleScopes) SetRole(ctx context.Context, db database.DB, model *RoleScopes, relation *Role) error {
	if model == nil {
		return errors.Wrap(query.ErrNoModels, "provided nil model")
	}
	// Check if primary key has zero value.
	if model.IsPrimaryKeyZero() {
		return errors.Wrap(mapping.ErrFieldValue, "model's: 'RoleScopes' primary key value has zero value")
	}
	relationField, err := r.Model.RelationByIndex(5)
	if err != nil {
		return err
	}
	q := query.NewScope(r.Model, model)
	if relation.IsPrimaryKeyZero() {
		return errors.Wrap(mapping.ErrFieldValue, "relation 'Role' model has zero value primary field")
	}
	relationSetter, ok := db.(database.QueryRelationSetter)
	if !ok {
		return errors.WrapDetf(query.ErrInternal, "DB doesn't implement QueryRelationSetter interface: %T", db)
	}
	return relationSetter.QuerySetRelations(ctx, q, relationField, relation)
}

// roleScopesQueryBuilder is the query builder used to create and execute
// queries for the RoleScopesmodel.
type roleScopesQueryBuilder struct {
	builder database.Builder
	err     error
}

// Scope returns given query scope.
func (r *roleScopesQueryBuilder) Scope() *query.Scope {
	return r.builder.Scope()
}

// Err returns errors that occurred during query building process.
func (r *roleScopesQueryBuilder) Err() error {
	if r.err != nil {
		return r.err
	}
	return r.builder.Err()
}

// Ctx returns the context of given query builder.
func (r *roleScopesQueryBuilder) Ctx() context.Context {
	return r.builder.Ctx()
}

// Count returns the number of model instances for provided query.
func (r *roleScopesQueryBuilder) Count() (int64, error) {
	if r.err != nil {
		return 0, r.err
	}
	return r.builder.Count()
}

// Insert new 'RoleScopes' instance(s) into the store.
func (r *roleScopesQueryBuilder) Insert() error {
	if r.err != nil {
		return r.err
	}
	return r.builder.Insert()
}

// Update updates given 'RoleScopes' instances.
func (r *roleScopesQueryBuilder) Update() (int64, error) {
	if r.err != nil {
		return 0, r.err
	}
	return r.builder.Update()
}

// Find returns all RoleScopes models that matches to given query.
func (r *roleScopesQueryBuilder) Find() ([]*RoleScopes, error) {
	if r.err != nil {
		return nil, r.err
	}
	queryModels, err := r.builder.Find()
	if err != nil {
		return nil, err
	}
	models := make([]*RoleScopes, len(queryModels))
	for i := range queryModels {
		models[i] = queryModels[i].(*RoleScopes)
	}
	return models, nil
}

// Refresh refreshes input 'RoleScopes' model fields. It might be combine with the included relations.
func (r *roleScopesQueryBuilder) Refresh() error {
	if r.err != nil {
		return r.err
	}
	return r.builder.Refresh()
}

// Get returns single RoleScopes model that matches given query.
// If the model is not found the function returns error of query.ErrQueryNoResult.
func (r *roleScopesQueryBuilder) Get() (*RoleScopes, error) {
	if r.err != nil {
		return nil, r.err
	}
	model, err := r.builder.Get()
	if err != nil {
		return nil, err
	}
	return model.(*RoleScopes), nil
}

// Delete deletes RoleScopes instances that matches given query.
func (r *roleScopesQueryBuilder) Delete() (int64, error) {
	if r.err != nil {
		return 0, r.err
	}
	return r.builder.Delete()
}

// Filter adds the 'filter' to the given query.
func (r *roleScopesQueryBuilder) Filter(filter filter.Filter) *roleScopesQueryBuilder {
	if r.err != nil {
		return r
	}
	r.builder.Filter(filter)
	return r
}

// Where creates query with given 'filter' and 'values'.
func (r *roleScopesQueryBuilder) Where(filter string, values ...interface{}) *roleScopesQueryBuilder {
	if r.err != nil {
		return r
	}
	r.builder.Where(filter, values...)
	return r
}

// IncludeScope includes given 'relation' in the _RoleScopes query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (r *roleScopesQueryBuilder) IncludeScope(scopeFieldset ...string) *roleScopesQueryBuilder {
	if r.err != nil {
		return r
	}
	relation, err := NRN_RoleScopes.Model.RelationByIndex(3)
	if err != nil {
		r.err = errors.Wrapf(mapping.ErrInternal, "Getting 'Scope' by index for model 'RoleScopes' failed: %v", err)
		return r
	}
	// check the fieldset for the relation.
	var relationFields []*mapping.StructField
	for _, field := range scopeFieldset {
		structField, ok := relation.ModelStruct().FieldByName(field)
		if !ok {
			r.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not found for the 'AuthorizeScope' model", field)
			return r
		}
		relationFields = append(relationFields, structField)
	}
	r.builder.Include(relation, relationFields...)
	return r
}

// IncludeRole includes given 'relation' in the _RoleScopes query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (r *roleScopesQueryBuilder) IncludeRole(roleFieldset ...string) *roleScopesQueryBuilder {
	if r.err != nil {
		return r
	}
	relation, err := NRN_RoleScopes.Model.RelationByIndex(5)
	if err != nil {
		r.err = errors.Wrapf(mapping.ErrInternal, "Getting 'Role' by index for model 'RoleScopes' failed: %v", err)
		return r
	}
	// check the fieldset for the relation.
	var relationFields []*mapping.StructField
	for _, field := range roleFieldset {
		structField, ok := relation.ModelStruct().FieldByName(field)
		if !ok {
			r.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not found for the 'Role' model", field)
			return r
		}
		relationFields = append(relationFields, structField)
	}
	r.builder.Include(relation, relationFields...)
	return r
}

// Limit sets the maximum number of objects returned by the Find process,
// Returns error if the given scope has already different type of pagination.
func (r *roleScopesQueryBuilder) Limit(limit int64) *roleScopesQueryBuilder {
	if r.err != nil {
		return r
	}
	r.builder.Limit(limit)
	return r
}

// Offset sets the query result's offset. It says to skip as many object's from the repository
// before beginning to return the result. 'Offset' 0 is the same as omitting the 'Offset' clause.
// Returns error if the given scope has already different type of pagination.
func (r *roleScopesQueryBuilder) Offset(offset int64) *roleScopesQueryBuilder {
	if r.err != nil {
		return r
	}
	r.builder.Offset(offset)
	return r
}

// Select adds the fields to the scope's fieldset.
// Allowed fields to select:
//  - ID / id
//  - ID / id
//  - CreatedAt / created_at
//  - DeletedAt / deleted_at
//  - ScopeID / scope_id
//  - RoleID / role_id
func (r *roleScopesQueryBuilder) Select(fields ...string) *roleScopesQueryBuilder {
	if r.err != nil {
		return r
	}
	var fieldSet []*mapping.StructField
	for _, field := range fields {
		structField, ok := NRN_RoleScopes.Model.FieldByName(field)
		if !ok {
			r.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not valid for model: '_RoleScopes'", field)
			return r
		}
		fieldSet = append(fieldSet, structField)
	}
	r.builder.Select(fieldSet...)
	return r
}

// OrderBy adds the sort fields into query scope. By default field is ordered ascending. In order to sort descending
// add '-' before the field name i.e. '-id'. The order of the fields relates to the significance of the sorting order.
// Allowed fields to sort:
//  - ID
//  - ID
//  - CreatedAt
//  - DeletedAt
//  - ScopeID
//  - RoleID
func (r *roleScopesQueryBuilder) OrderBy(fields ...string) *roleScopesQueryBuilder {
	if r.err != nil {
		return r
	}
	sortFields := make([]query.Sort, len(fields))
	for i, field := range fields {
		if len(field) == 0 {
			r.err = errors.Wrap(mapping.ErrInvalidModelField, "cannot set sorting order for an empty field for model: '_RoleScopes'")
			return r
		}
		var order query.SortOrder
		if field[0] == '-' {
			order = query.DescendingOrder
			field = field[1:]
		}
		structField, ok := NRN_RoleScopes.Model.FieldByName(field)
		if !ok {
			r.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not valid for model: '_RoleScopes'", field)
			return r
		}
		sortFields[i] = query.SortField{StructField: structField, SortOrder: order}
	}
	r.builder.OrderBy(sortFields...)
	return r
}

// AddScope adds related model Scope and matches to given RoleScopes.
func (r *roleScopesQueryBuilder) AddScope(_scope *AuthorizeScope) error {
	if r.err != nil {
		return r.err
	}
	relation, err := NRN_RoleScopes.Model.RelationByIndex(3)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'Scope' relation by index for model 'RoleScopes' failed: %v", err)
	}
	return r.builder.AddRelations(relation, _scope)
}

// AddRole adds related model Role and matches to given RoleScopes.
func (r *roleScopesQueryBuilder) AddRole(_role *Role) error {
	if r.err != nil {
		return r.err
	}
	relation, err := NRN_RoleScopes.Model.RelationByIndex(5)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'Role' relation by index for model 'RoleScopes' failed: %v", err)
	}
	return r.builder.AddRelations(relation, _role)
}

// SetScope sets related model Scope and matches to given RoleScopes.
func (r *roleScopesQueryBuilder) SetScope(_scope *AuthorizeScope) error {
	if r.err != nil {
		return r.err
	}
	relation, err := NRN_RoleScopes.Model.RelationByIndex(3)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'Scope' relation by index for model 'RoleScopes' failed: %v", err)
	}
	return r.builder.SetRelations(relation, _scope)
}

// SetRole sets related model Role and matches to given RoleScopes.
func (r *roleScopesQueryBuilder) SetRole(_role *Role) error {
	if r.err != nil {
		return r.err
	}
	relation, err := NRN_RoleScopes.Model.RelationByIndex(5)
	if err != nil {
		return errors.Wrapf(mapping.ErrInternal, "getting 'Role' relation by index for model 'RoleScopes' failed: %v", err)
	}
	return r.builder.SetRelations(relation, _role)
}

// RemoveScope removes related model Scope and matches to given RoleScopes.
func (r *roleScopesQueryBuilder) RemoveScope() (int64, error) {
	if r.err != nil {
		return 0, r.err
	}
	relation, err := NRN_RoleScopes.Model.RelationByIndex(3)
	if err != nil {
		return 0, errors.Wrapf(mapping.ErrInternal, "getting 'Scope' relation by index for model 'RoleScopes' failed: %v", err)
	}
	return r.builder.RemoveRelations(relation)
}

// RemoveRole removes related model Role and matches to given RoleScopes.
func (r *roleScopesQueryBuilder) RemoveRole() (int64, error) {
	if r.err != nil {
		return 0, r.err
	}
	relation, err := NRN_RoleScopes.Model.RelationByIndex(5)
	if err != nil {
		return 0, errors.Wrapf(mapping.ErrInternal, "getting 'Role' relation by index for model 'RoleScopes' failed: %v", err)
	}
	return r.builder.RemoveRelations(relation)
}
