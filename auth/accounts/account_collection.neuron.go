// Code generated by neurogonesis. DO NOT EDIT.
// This file was generated at:
// Thu, 03 Sep 2020 11:31:00 +0200

package accounts

import (
	"context"

	"github.com/neuronlabs/neuron/database"
	"github.com/neuronlabs/neuron/errors"
	"github.com/neuronlabs/neuron/mapping"
	"github.com/neuronlabs/neuron/query"
	"github.com/neuronlabs/neuron/query/filter"
)

// NRN_Accounts is the query helper that provides model specific database API.
type NRN_Accounts struct {
	mStruct *mapping.ModelStruct
}

// ModelStruct gets the stored model struct.
func (_a *NRN_Accounts) ModelStruct() *mapping.ModelStruct {
	return _a.mStruct
}

func (_a *NRN_Accounts) modelStruct(_db database.DB) (*mapping.ModelStruct, error) {
	if _a.mStruct != nil {
		return _a.mStruct, nil
	}
	mStruct, err := _db.ModelMap().ModelStruct(&accounts.Account{})
	if err != nil {
		return nil, err
	}
	_a.mStruct = mStruct
	return mStruct, nil
}

// ToModels converts the input slice of accounts.Account into []mapping.Model
func (_a *NRN_Accounts) ToModels(input ...*accounts.Account) []mapping.Model {
	output := make([]mapping.Model, len(input))
	for i := range input {
		output[i] = input[i]
	}
	return output
}

// FromModels converts the input mapping.Model into []*accounts.Account.
func (_a *NRN_Accounts) FromModels(input ...mapping.Model) []*accounts.Account {
	output := make([]*accounts.Account, len(input))
	for i := range input {
		output[i] = input[i].(*accounts.Account)
	}
	return output
}

// Query creates the query for the accounts.Account.
func (_a *NRN_Accounts) Query(db database.DB, models ...*accounts.Account) *_accountsQueryBuilder {
	var queryModels []mapping.Model
	if len(models) > 0 {
		queryModels = make([]mapping.Model, len(models))
		for i, model := range models {
			queryModels[i] = model
		}
	}
	mStruct, err := _a.modelStruct(db)
	builder := db.Query(mStruct, queryModels...)
	return &_accountsQueryBuilder{builder: builder, err: err}
}

// QueryCtx creates the query for the accounts.Account with provided 'ctx' context.
func (_a *NRN_Accounts) QueryCtx(ctx context.Context, db database.DB, models ...*accounts.Account) *_accountsQueryBuilder {
	var queryModels []mapping.Model
	if len(models) > 0 {
		queryModels = make([]mapping.Model, len(models))
		for i, model := range models {
			queryModels[i] = model
		}
	}
	mStruct, err := _a.modelStruct(db)
	builder := db.QueryCtx(ctx, mStruct, queryModels...)
	return &_accountsQueryBuilder{builder: builder, err: err}
}

// Insert inserts accounts.Account into database.
func (_a *NRN_Accounts) Insert(ctx context.Context, db database.DB, models ...*accounts.Account) error {
	if len(models) == 0 {
		return errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	mStruct, err := _a.modelStruct(db)
	if err != nil {
		return err
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Insert(ctx, mStruct, queryModels...)
}

// Update updates accounts.Account models into database.
func (_a *NRN_Accounts) Update(ctx context.Context, db database.DB, models ...*accounts.Account) (int64, error) {
	if len(models) == 0 {
		return 0, errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	mStruct, err := _a.modelStruct(db)
	if err != nil {
		return 0, err
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Update(ctx, mStruct, queryModels...)
}

// Delete deletes accounts.Account models in database.
func (_a *NRN_Accounts) Delete(ctx context.Context, db database.DB, models ...*accounts.Account) (int64, error) {
	if len(models) == 0 {
		return 0, errors.Wrap(query.ErrNoModels, "nothing to insert")
	}
	mStruct, err := _a.modelStruct(db)
	if err != nil {
		return 0, err
	}
	queryModels := make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Delete(ctx, mStruct, queryModels...)
}

// Refresh creates the query for the accounts.Account with provided 'ctx' context.
func (_a *NRN_Accounts) Refresh(ctx context.Context, db database.DB, models ...*accounts.Account) error {
	var queryModels []mapping.Model
	if len(models) == 0 {
		return errors.Wrap(query.ErrNoModels, "nothing to refresh")
	}
	mStruct, err := _a.modelStruct(db)
	if err != nil {
		return err
	}
	queryModels = make([]mapping.Model, len(models))
	for i, model := range models {
		queryModels[i] = model
	}
	return db.Refresh(ctx, mStruct, queryModels...)
}

// _accountsQueryBuilder is the query builder used to create and execute
// queries for the accounts.Accountmodel.
type _accountsQueryBuilder struct {
	builder database.Builder
	err     error
}

// Scope returns given query scope.
func (_a *_accountsQueryBuilder) Scope() *query.Scope {
	return _a.builder.Scope()
}

// Err returns errors that occurred during query building process.
func (_a *_accountsQueryBuilder) Err() error {
	if _a.err != nil {
		return _a.err
	}
	return _a.builder.Err()
}

// Ctx returns the context of given query builder.
func (_a *_accountsQueryBuilder) Ctx() context.Context {
	return _a.builder.Ctx()
}

// Count returns the number of model instances for provided query.
func (_a *_accountsQueryBuilder) Count() (int64, error) {
	if _a.err != nil {
		return 0, _a.err
	}
	return _a.builder.Count()
}

// Insert new 'accounts.Account' instance(s) into the store.
func (_a *_accountsQueryBuilder) Insert() error {
	if _a.err != nil {
		return _a.err
	}
	return _a.builder.Insert()
}

// Update updates given 'accounts.Account' instances.
func (_a *_accountsQueryBuilder) Update() (int64, error) {
	if _a.err != nil {
		return 0, _a.err
	}
	return _a.builder.Update()
}

// Find returns all accounts.Account models that matches to given query.
func (_a *_accountsQueryBuilder) Find() ([]*accounts.Account, error) {
	if _a.err != nil {
		return nil, _a.err
	}
	queryModels, err := _a.builder.Find()
	if err != nil {
		return nil, err
	}
	models := make([]*accounts.Account, len(queryModels))
	for i := range queryModels {
		models[i] = queryModels[i].(*accounts.Account)
	}
	return models, nil
}

// Refresh refreshes input 'accounts.Account' model fields. It might be combine with the included relations.
func (_a *_accountsQueryBuilder) Refresh() error {
	if _a.err != nil {
		return _a.err
	}
	return _a.builder.Refresh()
}

// Get returns single accounts.Account model that matches given query.
// If the model is not found the function returns error of query.ErrQueryNoResult.
func (_a *_accountsQueryBuilder) Get() (*accounts.Account, error) {
	if _a.err != nil {
		return nil, _a.err
	}
	model, err := _a.builder.Get()
	if err != nil {
		return nil, err
	}
	return model.(*accounts.Account), nil
}

// Delete deletes accounts.Account instances that matches given query.
func (_a *_accountsQueryBuilder) Delete() (int64, error) {
	if _a.err != nil {
		return 0, _a.err
	}
	return _a.builder.Delete()
}

// Filter adds the 'filter' to the given query.
func (_a *_accountsQueryBuilder) Filter(filter filter.Filter) *_accountsQueryBuilder {
	if _a.err != nil {
		return _a
	}
	_a.builder.Filter(filter)
	return _a
}

// Where creates query with given 'filter' and 'values'.
func (_a *_accountsQueryBuilder) Where(filter string, values ...interface{}) *_accountsQueryBuilder {
	if _a.err != nil {
		return _a
	}
	_a.builder.Where(filter, values...)
	return _a
}

// Limit sets the maximum number of objects returned by the Find process,
// Returns error if the given scope has already different type of pagination.
func (_a *_accountsQueryBuilder) Limit(limit int64) *_accountsQueryBuilder {
	if _a.err != nil {
		return _a
	}
	_a.builder.Limit(limit)
	return _a
}

// Offset sets the query result's offset. It says to skip as many object's from the repository
// before beginning to return the result. 'Offset' 0 is the same as omitting the 'Offset' clause.
// Returns error if the given scope has already different type of pagination.
func (_a *_accountsQueryBuilder) Offset(offset int64) *_accountsQueryBuilder {
	if _a.err != nil {
		return _a
	}
	_a.builder.Offset(offset)
	return _a
}

// Select adds the fields to the scope's fieldset.
// Allowed fields to select:
//  - ID / id
//  - ID / id
//  - CreatedAt / created_at
//  - UpdatedAt / updated_at
//  - DeletedAt / deleted_at
//  - Username / username
//  - PasswordHash / password_hash
//  - PasswordSalt / password_salt
func (_a *_accountsQueryBuilder) Select(fields ...string) *_accountsQueryBuilder {
	if _a.err != nil {
		return _a
	}
	var fieldSet []*mapping.StructField
	for _, field := range fields {
		structField, ok := _a.builder.Scope().ModelStruct.FieldByName(field)
		if !ok {
			_a.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not valid for model: 'NRN_Accounts'", field)
			return _a
		}
		fieldSet = append(fieldSet, structField)
	}
	_a.builder.Select(fieldSet...)
	return _a
}

// OrderBy adds the sort fields into query scope. By default field is ordered ascending. In order to sort descending
// add '-' before the field name i.e. '-id'. The order of the fields relates to the significance of the sorting order.
// Allowed fields to sort:
//  - ID
//  - CreatedAt
//  - UpdatedAt
//  - DeletedAt
//  - Username
//  - PasswordHash
//  - PasswordSalt
func (_a *_accountsQueryBuilder) OrderBy(fields ...string) *_accountsQueryBuilder {
	if _a.err != nil {
		return _a
	}
	sortFields := make([]query.Sort, len(fields))
	for i, field := range fields {
		if len(field) == 0 {
			_a.err = errors.Wrap(mapping.ErrInvalidModelField, "cannot set sorting order for an empty field for model: 'NRN_Accounts'")
			return _a
		}
		var order query.SortOrder
		if field[0] == '-' {
			order = query.DescendingOrder
			field = field[1:]
		}
		structField, ok := _a.builder.Scope().ModelStruct.FieldByName(field)
		if !ok {
			_a.err = errors.Wrapf(mapping.ErrInvalidModelField, "field: '%s' is not valid for model: 'NRN_Accounts'", field)
			return _a
		}
		sortFields[i] = query.SortField{StructField: structField, SortOrder: order}
	}
	_a.builder.OrderBy(sortFields...)
	return _a
}
